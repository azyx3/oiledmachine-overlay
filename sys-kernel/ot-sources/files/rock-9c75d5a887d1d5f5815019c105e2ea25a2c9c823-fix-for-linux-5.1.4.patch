--- a/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c.orig	2019-05-26 17:08:03.459166669 -0700
+++ b/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c	2019-05-26 17:14:25.894117691 -0700
@@ -800,15 +800,26 @@ static int dm_suspend(void *handle)
 
 static struct amdgpu_dm_connector *
 amdgpu_dm_find_first_crtc_matching_connector(struct drm_atomic_state *state,
+#if DRM_VERSION_CODE < DRM_VERSION(4, 12, 0)
+					     struct drm_crtc *crtc,
+					     bool from_state_var)
+#else
 					     struct drm_crtc *crtc)
+#endif
 {
 	uint32_t i;
 	struct drm_connector_state *new_con_state;
 	struct drm_connector *connector;
 	struct drm_crtc *crtc_from_state;
 
+#if DRM_VERSION_CODE < DRM_VERSION(4, 12, 0)
+	for_each_connector_in_state(state, connector, new_con_state, i) {
+		crtc_from_state = from_state_var ? new_con_state->crtc :
+						   connector->state->crtc;
+#else
 	for_each_new_connector_in_state(state, connector, new_con_state, i) {
 		crtc_from_state = new_con_state->crtc;
+#endif
 
 		if (crtc_from_state == crtc)
 			return to_amdgpu_dm_connector(connector);
@@ -2118,7 +2129,7 @@ retry:
 			continue;
 		}
 
-		new_crtc_state = drm_atomic_get_new_crtc_state(state, &acrtc->base);
+		new_crtc_state = kcl_drm_atomic_get_new_crtc_state_before_commit(state, &acrtc->base);
 		dm_new_crtc_state = to_dm_crtc_state(new_crtc_state);
 
 		dm_new_crtc_state->base.vrr_enabled =
@@ -5259,7 +5270,12 @@ static void amdgpu_dm_atomic_commit_tail
 	}
 
 	/* update changed items */
+#if DRM_VERSION_CODE < DRM_VERSION(4, 12, 0)
+	for_each_crtc_in_state(state, crtc, old_crtc_state, i) {
+		new_crtc_state = crtc->state;
+#else
 	for_each_oldnew_crtc_in_state(state, crtc, old_crtc_state, new_crtc_state, i) {
+#endif
 		struct amdgpu_crtc *acrtc = to_amdgpu_crtc(crtc);
 
 		dm_new_crtc_state = to_dm_crtc_state(new_crtc_state);
@@ -5336,7 +5352,12 @@ static void amdgpu_dm_atomic_commit_tail
 		mutex_unlock(&dm->dc_lock);
 	}
 
+#if DRM_VERSION_CODE < DRM_VERSION(4, 12, 0)
+	list_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {
+		new_crtc_state = crtc->state;
+#else
 	for_each_new_crtc_in_state(state, crtc, new_crtc_state, i) {
+#endif
 		struct amdgpu_crtc *acrtc = to_amdgpu_crtc(crtc);
 
 		dm_new_crtc_state = to_dm_crtc_state(new_crtc_state);
@@ -5357,7 +5378,12 @@ static void amdgpu_dm_atomic_commit_tail
 	}
 
 	/* Handle connector state changes */
+#if DRM_VERSION_CODE < DRM_VERSION(4, 12, 0)
+	for_each_connector_in_state(state, connector, old_con_state, i) {
+		new_con_state = connector->state;
+#else
 	for_each_oldnew_connector_in_state(state, connector, old_con_state, new_con_state, i) {
+#endif
 		struct dm_connector_state *dm_new_con_state = to_dm_connector_state(new_con_state);
 		struct dm_connector_state *dm_old_con_state = to_dm_connector_state(old_con_state);
 		struct amdgpu_crtc *acrtc = to_amdgpu_crtc(dm_new_con_state->base.crtc);
@@ -5368,9 +5394,9 @@ static void amdgpu_dm_atomic_commit_tail
 		memset(&dummy_updates, 0, sizeof(dummy_updates));
 		memset(&stream_update, 0, sizeof(stream_update));
 
-		if (acrtc) {
-			new_crtc_state = drm_atomic_get_new_crtc_state(state, &acrtc->base);
-			old_crtc_state = drm_atomic_get_old_crtc_state(state, &acrtc->base);
+		if (acrtc){
+			new_crtc_state = kcl_drm_atomic_get_new_crtc_state_after_commit(state, &acrtc->base);
+			old_crtc_state = kcl_drm_atomic_get_old_crtc_state_after_commit(state, &acrtc->base);
 		}
 
 		/* Skip any modesets/resets */
@@ -5421,8 +5447,13 @@ static void amdgpu_dm_atomic_commit_tail
 		mutex_unlock(&dm->dc_lock);
 	}
 
+#if DRM_VERSION_CODE < DRM_VERSION(4, 12, 0)
+	for_each_crtc_in_state(state, crtc, old_crtc_state, i) {
+		new_crtc_state = crtc->state;
+#else
 	for_each_oldnew_crtc_in_state(state, crtc, old_crtc_state,
 			new_crtc_state, i) {
+#endif
 		/*
 		 * loop to enable interrupts on newly arrived crtc
 		 */
@@ -5452,7 +5483,12 @@ static void amdgpu_dm_atomic_commit_tail
 	}
 
 	/* update planes when needed per crtc*/
+#if DRM_VERSION_CODE < DRM_VERSION(4, 12, 0)
+	for_each_crtc_in_state(state, crtc, old_crtc_state, i) {
+		new_crtc_state = crtc->state;
+#else
 	for_each_new_crtc_in_state(state, crtc, new_crtc_state, j) {
+#endif
 		dm_new_crtc_state = to_dm_crtc_state(new_crtc_state);
 
 		if (dm_new_crtc_state->stream)
@@ -5460,13 +5496,18 @@ static void amdgpu_dm_atomic_commit_tail
 						dm, crtc, &wait_for_vblank);
 	}
 
-
+#if DRM_VERSION_CODE >= DRM_VERSION(4, 8, 0)
 	/*
 	 * send vblank event on all events not handled in flip and
 	 * mark consumed event for drm_atomic_helper_commit_hw_done
 	 */
 	spin_lock_irqsave(&adev->ddev->event_lock, flags);
+#if DRM_VERSION_CODE < DRM_VERSION(4, 12, 0)
+	for_each_crtc_in_state(state, crtc, old_crtc_state, i) {
+		new_crtc_state = crtc->state;
+#else
 	for_each_new_crtc_in_state(state, crtc, new_crtc_state, i) {
+#endif
 
 		if (new_crtc_state->event)
 			drm_send_event_locked(dev, &new_crtc_state->event->base);
@@ -5474,6 +5515,7 @@ static void amdgpu_dm_atomic_commit_tail
 		new_crtc_state->event = NULL;
 	}
 	spin_unlock_irqrestore(&adev->ddev->event_lock, flags);
+#endif
 
 	/* Signal HW programming completion */
 	drm_atomic_helper_commit_hw_done(state);
@@ -5707,7 +5749,7 @@ static int dm_update_crtc_state(struct a
 	dm_new_crtc_state = to_dm_crtc_state(new_crtc_state);
 	acrtc = to_amdgpu_crtc(crtc);
 
-	new_plane_state = drm_atomic_get_new_plane_state(state, new_crtc_state->crtc->primary);
+	new_plane_state = kcl_drm_atomic_get_new_plane_state_before_commit(state, new_crtc_state->crtc->primary);
 
 	if (new_crtc_state->enable && new_plane_state && !new_plane_state->fb) {
 		ret = -EINVAL;
@@ -5719,11 +5761,15 @@ static int dm_update_crtc_state(struct a
 	/* TODO This hack should go away */
 	if (aconnector && enable) {
 		/* Make sure fake sink is created in plug-in scenario */
+#if	DRM_VERSION_CODE >= DRM_VERSION(4, 12, 0)
 		drm_new_conn_state = drm_atomic_get_new_connector_state(state,
 							    &aconnector->base);
 		drm_old_conn_state = drm_atomic_get_old_connector_state(state,
 							    &aconnector->base);
-
+#else
+		drm_new_conn_state = drm_atomic_get_connector_state(state,
+							    &aconnector->base);
+#endif
 		if (IS_ERR(drm_new_conn_state)) {
 			ret = PTR_ERR_OR_ZERO(drm_new_conn_state);
 			goto fail;
@@ -5746,7 +5792,6 @@ static int dm_update_crtc_state(struct a
 		 * error, the OS will be updated after detection, and
 		 * will do the right thing on next atomic commit
 		 */
-
 		if (!new_stream) {
 			DRM_DEBUG_DRIVER("%s: Failed to create new stream for crtc %d\n",
 					__func__, acrtc->base.base.id);
@@ -5937,7 +5982,7 @@ static int dm_update_plane_state(struct
 		if (!old_plane_crtc)
 			return 0;
 
-		old_crtc_state = drm_atomic_get_old_crtc_state(
+		old_crtc_state = kcl_drm_atomic_get_old_crtc_state_before_commit(
 				state, old_plane_crtc);
 		dm_old_crtc_state = to_dm_crtc_state(old_crtc_state);
 
@@ -5969,14 +6014,17 @@ static int dm_update_plane_state(struct
 
 	} else { /* Add new planes */
 		struct dc_plane_state *dc_new_plane_state;
-
+#if DRM_VERSION_CODE < DRM_VERSION(4, 12, 0)
+		if (drm_atomic_plane_disabling(plane, old_plane_state))
+#else
 		if (drm_atomic_plane_disabling(plane->state, new_plane_state))
+#endif
 			return 0;
 
 		if (!new_plane_crtc)
 			return 0;
 
-		new_crtc_state = drm_atomic_get_new_crtc_state(state, new_plane_crtc);
+		new_crtc_state = kcl_drm_atomic_get_new_crtc_state_before_commit(state, new_plane_crtc);
 		dm_new_crtc_state = to_dm_crtc_state(new_crtc_state);
 
 		if (!dm_new_crtc_state->stream)
@@ -6221,10 +6269,18 @@ static int amdgpu_dm_atomic_check(struct
 	if (ret)
 		goto fail;
 
+#if DRM_VERSION_CODE < DRM_VERSION(4, 12, 0)
+	for_each_crtc_in_state(state, crtc, new_crtc_state, i) {
+		old_crtc_state = crtc->state;
+#else
 	for_each_oldnew_crtc_in_state(state, crtc, old_crtc_state, new_crtc_state, i) {
-		if (!drm_atomic_crtc_needs_modeset(new_crtc_state) &&
-		    !new_crtc_state->color_mgmt_changed &&
-		    old_crtc_state->vrr_enabled == new_crtc_state->vrr_enabled)
+#endif
+
+		if (!drm_atomic_crtc_needs_modeset(new_crtc_state)
+#if DRM_VERSION_CODE >= DRM_VERSION(4, 6, 0)
+		    && !new_crtc_state->color_mgmt_changed
+#endif
+		    && old_crtc_state->vrr_enabled == new_crtc_state->vrr_enabled)
 			continue;
 
 		if (!new_crtc_state->enable)
@@ -6329,14 +6385,23 @@ static int amdgpu_dm_atomic_check(struct
 	 * new stream into context w\o causing full reset. Need to
 	 * decide how to handle.
 	 */
+#if DRM_VERSION_CODE < DRM_VERSION(4, 12, 0)
+	for_each_connector_in_state(state, connector, new_con_state, i) {
+		old_con_state = connector->state;
+#else
 	for_each_oldnew_connector_in_state(state, connector, old_con_state, new_con_state, i) {
+#endif
 		struct dm_connector_state *dm_old_con_state = to_dm_connector_state(old_con_state);
 		struct dm_connector_state *dm_new_con_state = to_dm_connector_state(new_con_state);
 		struct amdgpu_crtc *acrtc = to_amdgpu_crtc(dm_new_con_state->base.crtc);
 
 		/* Skip any modesets/resets */
 		if (!acrtc || drm_atomic_crtc_needs_modeset(
+#if DRM_VERSION_CODE < DRM_VERSION(4, 12, 0)
+				acrtc->base.state))
+#else
 				drm_atomic_get_new_crtc_state(state, &acrtc->base)))
+#endif
 			continue;
 
 		/* Skip any thing not scale or underscan changes */
