Some of these files are dependencies for some Perl scripts.
Some were obtained or derived from libgphoto repo.
Some hunks come from: https://bugs.wireshark.org/bugzilla/show_bug.cgi?id=8431
Some files where dropped if they were already accepted upstream.
----
diff -urpN wireshark-3.2.1.orig/epan/proto.h wireshark-3.2.1/epan/proto.h
--- wireshark-3.2.1.orig/epan/proto.h	2020-01-15 10:12:58.000000000 -0800
+++ wireshark-3.2.1/epan/proto.h	2020-02-04 22:58:56.682430910 -0800
@@ -78,6 +78,9 @@ struct expert_field;
 /** Something to satisfy checkAPIs when you have a pointer to a value_string_ext (e.g., one built with value_string_ext_new()) */
 #define VALS_EXT_PTR(x) (cast_same(value_string_ext*, (x)))
 
+/** Make a const value_string_masked[] look like a _value_string_masked pointer, used to set header_field_info.strings */
+#define MVALS(x) (const struct _value_string_masked*)(x)
+
 /** Make a const true_false_string[] look like a _true_false_string pointer, used to set header_field_info.strings */
 #define TFS(x)      (cast_same(const struct true_false_string*, (x)))
 
diff -urpN wireshark-3.2.1.orig/epan/value_string.h wireshark-3.2.1/epan/value_string.h
--- wireshark-3.2.1.orig/epan/value_string.h	2020-01-15 10:12:58.000000000 -0800
+++ wireshark-3.2.1/epan/value_string.h	2020-02-04 22:58:56.702431689 -0800
@@ -341,6 +341,13 @@ WS_DLL_PUBLIC
 const gchar *
 try_bytesprefix_to_str(const guint8 *haystack, const size_t haystack_len, const bytes_string *bs);
 
+/* MASKED VALUE STRINGS */
+typedef struct _value_string_masked {
+    guint32       mask;
+    guint32       value;
+    const gchar   *strptr;
+} value_string_masked_t;
+
 /* MISC (generally do not use) */
 
 WS_DLL_LOCAL
diff -urpN wireshark-3.2.1.orig/tools/library.c wireshark-3.2.1/tools/library.c
--- wireshark-3.2.1.orig/tools/library.c	1969-12-31 16:00:00.000000000 -0800
+++ wireshark-3.2.1/tools/library.c	2020-02-04 22:58:56.702431689 -0800
@@ -0,0 +1,7381 @@
+/* library.c
+ *
+ * Copyright (C) 2001-2005 Mariusz Woloszyn <emsi@ipartners.pl>
+ * Copyright (C) 2003-2015 Marcus Meissner <marcus@jet.franken.de>
+ * Copyright (C) 2005 Hubert Figuiere <hfiguiere@teaser.fr>
+ * Copyright (C) 2009 Axel Waggershauser <awagger@web.de>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA  02110-1301  USA
+ */
+
+#define _DEFAULT_SOURCE
+#include "config.h"
+
+#include <stdlib.h>
+#include <string.h>
+#include <stdio.h>
+#include <stdarg.h>
+#include <time.h>
+#include <sys/time.h>
+#if defined(HAVE_ICONV) && defined(HAVE_LANGINFO_H)
+#include <langinfo.h>
+#endif
+#include <unistd.h>
+
+#include <gphoto2/gphoto2-library.h>
+#include <gphoto2/gphoto2-port-log.h>
+#include <gphoto2/gphoto2-setting.h>
+
+#ifdef ENABLE_NLS
+#  include <libintl.h>
+#  undef _
+#  define _(String) dgettext (GETTEXT_PACKAGE, String)
+#  ifdef gettext_noop
+#    define N_(String) gettext_noop (String)
+#  else
+#    define N_(String) (String)
+#  endif
+#else
+#  define textdomain(String) (String)
+#  define gettext(String) (String)
+#  define dgettext(Domain,Message) (Message)
+#  define dcgettext(Domain,Message,Type) (Message)
+#  define bindtextdomain(Domain,Directory) (Domain)
+#  define _(String) (String)
+#  define N_(String) (String)
+#endif
+
+#include "ptp.h"
+#include "ptp-bugs.h"
+#include "ptp-private.h"
+#include "ptp-pack.c"
+#include "olympus-wrap.h"
+
+#define USB_START_TIMEOUT 8000
+#define USB_CANON_START_TIMEOUT 1500	/* 1.5 seconds (0.5 was too low) */
+#define USB_NORMAL_TIMEOUT 20000
+static int normal_timeout = USB_NORMAL_TIMEOUT;
+#define USB_TIMEOUT_CAPTURE 100000
+static int capture_timeout = USB_TIMEOUT_CAPTURE;
+
+#define	SET_CONTEXT(camera, ctx) ((PTPData *) camera->pl->params.data)->context = ctx
+#define	SET_CONTEXT_P(p, ctx) ((PTPData *) p->data)->context = ctx
+
+/* below macro makes a copy of fn without leading character ('/'),
+ * removes the '/' at the end if present, and calls folder_to_handle()
+ * funtion proviging as the first argument the string after the second '/'.
+ * for example if fn is '/store_00010001/DCIM/somefolder/', the macro will
+ * call folder_to_handle() with 'DCIM/somefolder' as the very first argument.
+ * it's used to omit storage pseudofolder and remove trailing '/'
+ */
+
+#define find_folder_handle(params,fn,s,p)	{		\
+		{						\
+		int len=strlen(fn);				\
+		char *backfolder=malloc(len);			\
+		char *tmpfolder;				\
+		memcpy(backfolder,fn+1, len);			\
+		if (backfolder[len-2]=='/') backfolder[len-2]='\0';\
+		if ((tmpfolder=strchr(backfolder+1,'/'))==NULL) tmpfolder="/";\
+		p=folder_to_handle(params, tmpfolder+1,s,0,NULL);\
+		free(backfolder);				\
+		}						\
+}
+
+#define folder_to_storage(fn,s) {				\
+		if (!strncmp(fn,"/"STORAGE_FOLDER_PREFIX,strlen(STORAGE_FOLDER_PREFIX)+1))							\
+		{						\
+			if (strlen(fn)<strlen(STORAGE_FOLDER_PREFIX)+8+1) \
+				return (GP_ERROR);		\
+			s = strtoul(fn + strlen(STORAGE_FOLDER_PREFIX)+1, NULL, 16);								\
+		} else { 					\
+			gp_context_error (context, _("You need to specify a folder starting with /store_xxxxxxxxx/"));				\
+			return (GP_ERROR);			\
+		}						\
+}
+uint16_t ptp_list_folder (PTPParams *params, uint32_t storage, uint32_t handle);
+
+typedef int (*getfunc_t)(CameraFilesystem*, const char*, const char *, CameraFileType, CameraFile *, void *, GPContext *);
+typedef int (*putfunc_t)(CameraFilesystem*, const char*, CameraFile*, void*, GPContext*);
+
+struct special_file {
+	char		*name;
+	getfunc_t	getfunc;
+	putfunc_t	putfunc;
+};
+
+static unsigned int nrofspecial_files = 0;
+static struct special_file *special_files = NULL;
+
+static int
+add_special_file (char *name, getfunc_t getfunc, putfunc_t putfunc) {
+	C_MEM (special_files = realloc (special_files, sizeof(special_files[0])*(nrofspecial_files+1)));
+	C_MEM (special_files[nrofspecial_files].name = strdup(name));
+	special_files[nrofspecial_files].putfunc = putfunc;
+	special_files[nrofspecial_files].getfunc = getfunc;
+	nrofspecial_files++;
+	return (GP_OK);
+}
+
+#define STORAGE_FOLDER_PREFIX		"store_"
+
+int
+translate_ptp_result (uint16_t result)
+{
+	switch (result) {
+	case PTP_RC_OK:				return GP_OK;
+	case PTP_RC_ParameterNotSupported:	return GP_ERROR_BAD_PARAMETERS;
+	case PTP_RC_OperationNotSupported:	return GP_ERROR_NOT_SUPPORTED;
+	case PTP_RC_DeviceBusy:			return GP_ERROR_CAMERA_BUSY;
+	case PTP_ERROR_TIMEOUT:			return GP_ERROR_TIMEOUT;
+	case PTP_ERROR_CANCEL:			return GP_ERROR_CANCEL;
+	case PTP_ERROR_BADPARAM:		return GP_ERROR_BAD_PARAMETERS;
+	case PTP_ERROR_IO:
+	case PTP_ERROR_DATA_EXPECTED:
+	case PTP_ERROR_RESP_EXPECTED:		return GP_ERROR_IO;
+	default:				return GP_ERROR;
+	}
+}
+
+static void
+print_debug_deviceinfo (PTPParams *params, PTPDeviceInfo *di)
+{
+	unsigned int i;
+
+	GP_LOG_D ("Device info:");
+	GP_LOG_D ("Manufacturer: %s",di->Manufacturer);
+	GP_LOG_D ("  Model: %s", di->Model);
+	GP_LOG_D ("  device version: %s", di->DeviceVersion);
+	GP_LOG_D ("  serial number: '%s'",di->SerialNumber);
+	GP_LOG_D ("Vendor extension ID: 0x%08x",di->VendorExtensionID);
+	GP_LOG_D ("Vendor extension version: %d",di->VendorExtensionVersion);
+	GP_LOG_D ("Vendor extension description: %s",di->VendorExtensionDesc);
+	GP_LOG_D ("Functional Mode: 0x%04x",di->FunctionalMode);
+	GP_LOG_D ("PTP Standard Version: %d",di->StandardVersion);
+	GP_LOG_D ("Supported operations:");
+	for (i=0; i<di->OperationsSupported_len; i++) {
+		char buf[200];
+
+		ptp_render_opcode (params, di->OperationsSupported[i], sizeof(buf), buf);
+		GP_LOG_D ("  0x%04x (%s)", di->OperationsSupported[i], buf);
+	}
+	GP_LOG_D ("Events Supported:");
+	for (i=0; i<di->EventsSupported_len; i++)
+		GP_LOG_D ("  0x%04x", di->EventsSupported[i]);
+	GP_LOG_D ("Device Properties Supported:");
+	for (i=0; i<di->DevicePropertiesSupported_len; i++)
+		GP_LOG_D ("  0x%04x", di->DevicePropertiesSupported[i]);
+}
+
+/* Changes the ptp deviceinfo with additional hidden information available,
+ * or stuff that requires special tricks 
+ */
+int
+fixup_cached_deviceinfo (Camera *camera, PTPDeviceInfo *di) {
+	CameraAbilities a;
+	PTPParams	*params = &camera->pl->params;
+
+        gp_camera_get_abilities(camera, &a);
+
+	/* Panasonic hack */
+	if (	(di->VendorExtensionID == PTP_VENDOR_MICROSOFT) &&
+		(camera->port->type == GP_PORT_USB) &&
+		(a.usb_vendor == 0x04da)
+	) {
+		PTPPropertyValue propval;
+		/* Panasonic changes its device info if the MTP Initiator
+		 * is set, and e.g. adds DeleteObject.
+		 * (found in Windows USB traces) */
+
+		if (!ptp_property_issupported(params, PTP_DPC_MTP_SessionInitiatorInfo))
+			return GP_OK;
+
+		propval.str = "Windows/6.2.9200 MTPClassDriver/6.2.9200.16384";
+
+		C_PTP (ptp_setdevicepropvalue (params, PTP_DPC_MTP_SessionInitiatorInfo, &propval, PTP_DTC_STR));
+		C_PTP (ptp_getdeviceinfo (params, di));
+		return GP_OK;
+	}
+	/* XML style Olympus E series control. internal deviceInfos is encoded in XML. */
+	if (	di->Manufacturer && !strcmp(di->Manufacturer,"OLYMPUS") &&
+		(params->device_flags & DEVICE_FLAG_OLYMPUS_XML_WRAPPED)
+	) {
+		PTPDeviceInfo	ndi, newdi, *outerdi;
+		unsigned int	i;
+
+		C_PTP (ptp_getdeviceinfo (params, &params->outer_deviceinfo));
+		outerdi = &params->outer_deviceinfo;
+
+		C_PTP (ptp_olympus_getdeviceinfo (&camera->pl->params, &ndi));
+
+		/* Now merge the XML (inner) and outer (PictBridge) Deviceinfo. */
+		memcpy (&newdi, outerdi, sizeof(PTPDeviceInfo));
+
+		/* dup the strings */
+		if (outerdi->VendorExtensionDesc)	C_MEM (newdi.VendorExtensionDesc = strdup (outerdi->VendorExtensionDesc));
+		if (outerdi->Manufacturer)		C_MEM (newdi.Manufacturer = strdup (outerdi->Manufacturer));
+		if (outerdi->Model)			C_MEM (newdi.Model = strdup (outerdi->Model));
+		if (outerdi->DeviceVersion)		C_MEM (newdi.DeviceVersion = strdup (outerdi->DeviceVersion));
+		if (outerdi->SerialNumber)		C_MEM (newdi.SerialNumber = strdup (outerdi->SerialNumber));
+
+		/* Dup and merge the lists */
+#define DI_MERGE(x) \
+		C_MEM (newdi.x = malloc(sizeof(outerdi->x[0])*(ndi.x##_len + outerdi->x##_len)));\
+		for (i = 0; i < outerdi->x##_len ; i++) 					\
+			newdi.x[i] = outerdi->x[i];						\
+		for (i = 0; i < ndi.x##_len ; i++)						\
+			newdi.x[i+outerdi->x##_len] = ndi.x[i];					\
+		newdi.x##_len = ndi.x##_len + outerdi->x##_len;
+
+		DI_MERGE(OperationsSupported);
+		DI_MERGE(EventsSupported);
+		DI_MERGE(DevicePropertiesSupported);
+		DI_MERGE(CaptureFormats);
+		DI_MERGE(ImageFormats);
+
+		/* libgphoto2 specific for usage in config trees */
+		newdi.VendorExtensionID = PTP_VENDOR_GP_OLYMPUS;
+
+		GP_LOG_D ("Dumping Olympus Deviceinfo");
+
+
+		print_debug_deviceinfo (params, &newdi);
+		ptp_free_DI (di);
+		memcpy (di, &newdi, sizeof(newdi));
+		return GP_OK;
+	}
+
+	/* for USB class matches on unknown cameras that were matches with PTP generic... */
+	if (!a.usb_vendor && di->Manufacturer) {
+		if (strstr (di->Manufacturer,"Canon"))
+			a.usb_vendor = 0x4a9;
+		if (strstr (di->Manufacturer,"Nikon"))
+			a.usb_vendor = 0x4b0;
+	}
+	/* Switch the PTP vendor, so that the vendor specific sets become available. */
+	if (	(di->VendorExtensionID == PTP_VENDOR_MICROSOFT) &&
+		di->Manufacturer
+	) {
+		if (strstr (di->Manufacturer,"Canon"))
+			di->VendorExtensionID = PTP_VENDOR_CANON;
+		if (strstr (di->Manufacturer,"Nikon"))
+			di->VendorExtensionID = PTP_VENDOR_NIKON;
+	}
+
+	/* Newer Canons say that they are MTP devices. Restore Canon vendor extid. */
+	if (	(di->VendorExtensionID == PTP_VENDOR_MICROSOFT) &&
+		(camera->port->type == GP_PORT_USB) &&
+		(a.usb_vendor == 0x4a9)
+	) {
+		/*camera->pl->bugs |= PTP_MTP;*/
+		di->VendorExtensionID = PTP_VENDOR_CANON;
+	}
+
+	/* Newer Nikons (D40) say that they are MTP devices. Restore Nikon vendor extid. */
+	if (	(di->VendorExtensionID == PTP_VENDOR_MICROSOFT) &&
+		(camera->port->type == GP_PORT_USB) &&
+		(a.usb_vendor == 0x4b0)
+	) {
+		/*camera->pl->bugs |= PTP_MTP;*/
+		di->VendorExtensionID = PTP_VENDOR_NIKON;
+	}
+
+	/* Fuji S5 Pro mostly, make its vendor set available. */
+	if (	(di->VendorExtensionID == PTP_VENDOR_MICROSOFT) &&
+		(camera->port->type == GP_PORT_USB) &&
+		(a.usb_vendor == 0x4cb) &&
+		strstr(di->VendorExtensionDesc,"fujifilm.co.jp: 1.0;")
+	) {
+		/*camera->pl->bugs |= PTP_MTP;*/
+		di->VendorExtensionID = PTP_VENDOR_FUJI;
+	}
+
+	/* Nikon DSLR hide its newer opcodes behind another vendor specific query,
+	 * do that and merge it into the generic PTP deviceinfo. */
+	if (di->VendorExtensionID == PTP_VENDOR_NIKON) {
+		unsigned int i;
+		unsigned int nikond;
+
+		/* Nikon V* and J* advertise the new Nikon stuff, but only do the generic
+		 * PTP capture. FIXME: could use flags. */
+		if (params->deviceinfo.Model && (
+			(params->deviceinfo.Model[0]=='J') ||	/* J1 - J3 currently */
+			(params->deviceinfo.Model[0]=='V') ||	/* V1 - V3 currently */
+			(params->deviceinfo.Model[0]=='S')	/* S1 - S2 currently */
+			)
+		) {
+			if (!NIKON_1(&camera->pl->params)) {
+				GP_LOG_E ("if camera is Nikon 1 series, camera should probably have flag NIKON_1 set. report that to the libgphoto2 project");
+				camera->pl->params.device_flags |= PTP_NIKON_1;
+			}
+
+			/* The 1 hides some commands from us ... */
+			if ( ptp_operation_issupported(&camera->pl->params, PTP_OC_NIKON_CheckEvent) &&
+			    !ptp_operation_issupported(&camera->pl->params, PTP_OC_NIKON_GetVendorPropCodes)
+			) {
+				C_MEM (di->OperationsSupported = realloc(di->OperationsSupported,sizeof(di->OperationsSupported[0])*(di->OperationsSupported_len + 1)));
+				di->OperationsSupported[di->OperationsSupported_len+0] = PTP_OC_NIKON_GetVendorPropCodes;
+				/* probably more */
+				di->OperationsSupported_len += 1;
+			}
+		}
+		if (params->deviceinfo.Model && !strcmp(params->deviceinfo.Model,"COOLPIX A")) {
+			/* The A also hides some commands from us ... */
+			if (!ptp_operation_issupported(&camera->pl->params, PTP_OC_NIKON_GetVendorPropCodes)) {
+				C_MEM (di->OperationsSupported = realloc(di->OperationsSupported,sizeof(di->OperationsSupported[0])*(di->OperationsSupported_len + 1)));
+				di->OperationsSupported[di->OperationsSupported_len+0] = PTP_OC_NIKON_GetVendorPropCodes;
+				/* probably more */
+				di->OperationsSupported_len += 1;
+			}
+		}
+		if (params->deviceinfo.Model && (sscanf(params->deviceinfo.Model,"D%d", &nikond)))
+		{
+			if ((nikond >= 3000) && (nikond < 3199)) {
+				GP_LOG_D("The D3xxx series hides commands from us ... adding all D3000 ones");
+				if (!ptp_operation_issupported(&camera->pl->params, PTP_OC_NIKON_GetVendorPropCodes)) {
+					C_MEM (di->OperationsSupported = realloc(di->OperationsSupported,sizeof(di->OperationsSupported[0])*(di->OperationsSupported_len + 15)));
+					di->OperationsSupported[di->OperationsSupported_len+0]  = PTP_OC_NIKON_GetVendorPropCodes;
+					di->OperationsSupported[di->OperationsSupported_len+1]  = PTP_OC_NIKON_CheckEvent;
+					di->OperationsSupported[di->OperationsSupported_len+2]  = PTP_OC_NIKON_Capture;
+					di->OperationsSupported[di->OperationsSupported_len+3]  = PTP_OC_NIKON_AfDrive;
+					di->OperationsSupported[di->OperationsSupported_len+4]  = PTP_OC_NIKON_SetControlMode;
+					di->OperationsSupported[di->OperationsSupported_len+5]  = PTP_OC_NIKON_DeviceReady;
+					di->OperationsSupported[di->OperationsSupported_len+6]  = PTP_OC_NIKON_AfCaptureSDRAM;
+					di->OperationsSupported[di->OperationsSupported_len+7]  = PTP_OC_NIKON_DelImageSDRAM;
+
+					di->OperationsSupported[di->OperationsSupported_len+8]  = PTP_OC_NIKON_GetPreviewImg;
+					di->OperationsSupported[di->OperationsSupported_len+9]  = PTP_OC_NIKON_StartLiveView;
+					di->OperationsSupported[di->OperationsSupported_len+10] = PTP_OC_NIKON_EndLiveView;
+					di->OperationsSupported[di->OperationsSupported_len+11] = PTP_OC_NIKON_GetLiveViewImg;
+					di->OperationsSupported[di->OperationsSupported_len+12] = PTP_OC_NIKON_MfDrive;
+					di->OperationsSupported[di->OperationsSupported_len+13] = PTP_OC_NIKON_ChangeAfArea;
+					di->OperationsSupported[di->OperationsSupported_len+14] = PTP_OC_NIKON_AfDriveCancel;
+					/* only opcodes up to 9206 ... I think. */
+					di->OperationsSupported_len += 15;
+				}
+			}
+			if ((nikond >= 3200) && (nikond < 3999)) {
+				GP_LOG_D("The D3xxx series hides commands from us ... adding all D7100 ones");
+				if (!ptp_operation_issupported(&camera->pl->params, PTP_OC_NIKON_GetVendorPropCodes)) {
+					C_MEM (di->OperationsSupported = realloc(di->OperationsSupported,sizeof(di->OperationsSupported[0])*(di->OperationsSupported_len + 19)));
+					di->OperationsSupported[di->OperationsSupported_len+0]  = PTP_OC_NIKON_GetVendorPropCodes;
+					di->OperationsSupported[di->OperationsSupported_len+1]  = PTP_OC_NIKON_CheckEvent;
+					di->OperationsSupported[di->OperationsSupported_len+2]  = PTP_OC_NIKON_Capture;
+					di->OperationsSupported[di->OperationsSupported_len+3]  = PTP_OC_NIKON_AfDrive;
+					di->OperationsSupported[di->OperationsSupported_len+4]  = PTP_OC_NIKON_SetControlMode;
+					di->OperationsSupported[di->OperationsSupported_len+5]  = PTP_OC_NIKON_DeviceReady;
+					di->OperationsSupported[di->OperationsSupported_len+6]  = PTP_OC_NIKON_AfCaptureSDRAM;
+					di->OperationsSupported[di->OperationsSupported_len+7]  = PTP_OC_NIKON_DelImageSDRAM;
+
+					di->OperationsSupported[di->OperationsSupported_len+8]  = PTP_OC_NIKON_GetPreviewImg;
+					di->OperationsSupported[di->OperationsSupported_len+9]  = PTP_OC_NIKON_StartLiveView;
+					di->OperationsSupported[di->OperationsSupported_len+10] = PTP_OC_NIKON_EndLiveView;
+					di->OperationsSupported[di->OperationsSupported_len+11] = PTP_OC_NIKON_GetLiveViewImg;
+					di->OperationsSupported[di->OperationsSupported_len+12] = PTP_OC_NIKON_MfDrive;
+					di->OperationsSupported[di->OperationsSupported_len+13] = PTP_OC_NIKON_ChangeAfArea;
+					di->OperationsSupported[di->OperationsSupported_len+14] = PTP_OC_NIKON_InitiateCaptureRecInMedia;
+					di->OperationsSupported[di->OperationsSupported_len+15] = PTP_OC_NIKON_AfDriveCancel;
+					di->OperationsSupported[di->OperationsSupported_len+15] = PTP_OC_NIKON_AfDriveCancel;
+					di->OperationsSupported[di->OperationsSupported_len+16] = PTP_OC_NIKON_StartMovieRecInCard;
+					di->OperationsSupported[di->OperationsSupported_len+17] = PTP_OC_NIKON_EndMovieRec;
+					di->OperationsSupported[di->OperationsSupported_len+18] = PTP_OC_NIKON_TerminateCapture;
+					/* probably more */
+					di->OperationsSupported_len += 19;
+				}
+			}
+		}
+
+		if (ptp_operation_issupported(&camera->pl->params, PTP_OC_NIKON_GetVendorPropCodes)) {
+			uint16_t  	*xprops;
+			unsigned int	xsize;
+
+			if (PTP_RC_OK == LOG_ON_PTP_E (ptp_nikon_get_vendorpropcodes (&camera->pl->params, &xprops, &xsize))) {
+				di->DevicePropertiesSupported = realloc(di->DevicePropertiesSupported,sizeof(di->DevicePropertiesSupported[0])*(di->DevicePropertiesSupported_len + xsize));
+				if (!di->DevicePropertiesSupported) {
+					free (xprops);
+					C_MEM (di->DevicePropertiesSupported);
+				}
+				for (i=0;i<xsize;i++)
+					di->DevicePropertiesSupported[i+di->DevicePropertiesSupported_len] = xprops[i];
+				di->DevicePropertiesSupported_len += xsize;
+				free (xprops);
+			}
+		}
+
+
+#if 0
+		if (!ptp_operation_issupported(&camera->pl->params, 0x9207)) {
+			C_MEM (di->OperationsSupported = realloc(di->OperationsSupported,sizeof(di->OperationsSupported[0])*(di->OperationsSupported_len + 2)));
+			di->OperationsSupported[di->OperationsSupported_len+0] = PTP_OC_NIKON_Capture;
+			di->OperationsSupported[di->OperationsSupported_len+1] = PTP_OC_NIKON_AfCaptureSDRAM;
+			di->OperationsSupported_len+=2;
+		}
+#endif
+	}
+
+	/* Sony DSLR also hide its newer opcodes behind another vendor specific query,
+	 * do that and merge it into the generic PTP deviceinfo. */
+	if (di->VendorExtensionID == PTP_VENDOR_SONY) {
+		unsigned int i;
+
+		if (ptp_operation_issupported(&camera->pl->params, PTP_OC_SONY_GetSDIOGetExtDeviceInfo)) {
+			int opcodes = 0, propcodes = 0, events = 0, j,k,l;
+			uint16_t  	*xprops;
+			unsigned int	xsize;
+
+			C_PTP (ptp_sony_sdioconnect (&camera->pl->params, 1, 0, 0));
+			C_PTP (ptp_sony_sdioconnect (&camera->pl->params, 2, 0, 0));
+			C_PTP (ptp_sony_get_vendorpropcodes (&camera->pl->params, &xprops, &xsize));
+
+			for (i=0;i<xsize;i++) {
+				switch (xprops[i] & 0x7000) {
+				case 0x1000: opcodes++; break;
+				case 0x4000: events++; break;
+				case 0x5000: propcodes++; break;
+				default: 
+					GP_LOG_E ("ptp_sony_get_vendorpropcodes() unknown opcode %x", xprops[i]);
+					break;
+				}
+			}
+			C_MEM (di->DevicePropertiesSupported = realloc(di->DevicePropertiesSupported,sizeof(di->DevicePropertiesSupported[0])*(di->DevicePropertiesSupported_len + propcodes)));
+			C_MEM (di->OperationsSupported       = realloc(di->OperationsSupported,      sizeof(di->OperationsSupported[0])*(di->OperationsSupported_len + opcodes)));
+			C_MEM (di->EventsSupported           = realloc(di->EventsSupported,          sizeof(di->EventsSupported[0])*(di->EventsSupported_len + events)));
+			j = 0; k = 0; l = 0;
+			for (i=0;i<xsize;i++) {
+				GP_LOG_D ("sony code: %x", xprops[i]);
+				switch (xprops[i] & 0x7000) {
+				case 0x1000:
+					di->OperationsSupported[(k++)+di->OperationsSupported_len] = xprops[i];
+					break;
+				case 0x4000:
+					di->EventsSupported[(l++)+di->EventsSupported_len] = xprops[i];
+					break;
+				case 0x5000:
+					di->DevicePropertiesSupported[(j++)+di->DevicePropertiesSupported_len] = xprops[i];
+					break;
+				default: 
+					break;
+				}
+			}
+			di->DevicePropertiesSupported_len += propcodes;
+			di->EventsSupported_len += events;
+			di->OperationsSupported_len += opcodes;
+			free (xprops);
+			C_PTP (ptp_sony_sdioconnect (&camera->pl->params, 3, 0, 0));
+		}
+	}
+#if 0 /* Marcus: not regular ptp properties, not queryable via getdevicepropertyvalue */
+	if (di->VendorExtensionID == PTP_VENDOR_CANON) {
+		if (ptp_operation_issupported(&camera->pl->params, PTP_OC_CANON_EOS_GetDeviceInfoEx)) {
+			PTPCanonEOSDeviceInfo  	eosdi;
+			int i;
+
+			C_PTP (ptp_canon_eos_getdeviceinfo (&camera->pl->params, &eosdi));
+			C_MEM (di->DevicePropertiesSupported = realloc(di->DevicePropertiesSupported,sizeof(di->DevicePropertiesSupported[0])*(di->DevicePropertiesSupported_len + eosdi.DevicePropertiesSupported_len)));
+			for (i=0;i<eosdi.DevicePropertiesSupported_len;i++)
+				di->DevicePropertiesSupported[i+di->DevicePropertiesSupported_len] = eosdi.DevicePropertiesSupported[i];
+			di->DevicePropertiesSupported_len += eosdi.DevicePropertiesSupported_len;
+		}
+	}
+#endif
+	return GP_OK;
+}
+
+static uint16_t
+nikon_wait_busy(PTPParams *params, int waitms, int timeout) {
+	uint16_t	res;
+	int		tries;
+
+	/* wait either 1 second, or 50 tries */
+	if (waitms)
+		tries=timeout/waitms;
+	else
+		tries=50;
+
+	do {
+		res = ptp_nikon_device_ready(params);
+		if (res != PTP_RC_DeviceBusy)
+			return res;
+		if (waitms) usleep(waitms*1000)/*wait a bit*/;
+	} while (tries--);
+	return res;
+}
+
+
+static struct {
+	const char *model;
+	unsigned short usb_vendor;
+	unsigned short usb_product;
+	unsigned long device_flags;
+} models[] = {
+	/*
+	 * The very first PTP camera (with special firmware only), also
+	 * called "PTP Prototype", may report non PTP interface class
+	 */
+	{"Kodak:DC240 (PTP mode)",  0x040a, 0x0121, 0},
+	/*
+	 * Old DC-4800 firmware reported custom interface class, so we have
+	 * to detect it by product/vendor IDs
+	 */
+	{"Kodak:DC4800", 0x040a, 0x0160, 0},
+	/* Below other camers known to be detected by interface class */
+
+	{"Kodak:DX3900", 0x040a, 0x0170, 0},
+	{"Kodak:MC3",    0x040a, 0x0400, 0},
+	/* reported by Ken Moffat */
+	{"Kodak:Z7590",  0x040a, 0x0403, 0},
+	{"Kodak:DX3500", 0x040a, 0x0500, 0},
+	{"Kodak:DX3600", 0x040a, 0x0510, 0},
+	{"Kodak:DX3215", 0x040a, 0x0525, 0},
+	{"Kodak:DX3700", 0x040a, 0x0530, 0},
+	{"Kodak:CX4230", 0x040a, 0x0535, 0},
+	{"Kodak:LS420",  0x040a, 0x0540, 0},
+	{"Kodak:DX4900", 0x040a, 0x0550, 0},
+	{"Kodak:DX4330", 0x040a, 0x0555, 0},
+	{"Kodak:CX4200", 0x040a, 0x0560, 0},
+	{"Kodak:CX4210", 0x040a, 0x0560, 0},
+	{"Kodak:LS743",  0x040a, 0x0565, 0},
+	/* both above with different product IDs
+	   normal/retail versions of the same model */
+	{"Kodak:CX4300", 0x040a, 0x0566, 0},
+	{"Kodak:CX4310", 0x040a, 0x0566, 0},
+	{"Kodak:LS753",  0x040a, 0x0567, 0},
+	{"Kodak:LS443",  0x040a, 0x0568, 0},
+	{"Kodak:LS663",  0x040a, 0x0569, 0},
+	{"Kodak:DX6340", 0x040a, 0x0570, 0},
+	{"Kodak:CX6330", 0x040a, 0x0571, 0},
+	{"Kodak:DX6440", 0x040a, 0x0572, 0},
+	{"Kodak:CX6230", 0x040a, 0x0573, 0},
+	{"Kodak:CX6200", 0x040a, 0x0574, 0},
+	{"Kodak:DX6490", 0x040a, 0x0575, 0},
+	{"Kodak:DX4530", 0x040a, 0x0576, 0},
+	{"Kodak:DX7630", 0x040a, 0x0577, 0},
+	{"Kodak:CX7300", 0x040a, 0x0578, 0},
+	{"Kodak:CX7310", 0x040a, 0x0578, 0},
+	{"Kodak:CX7220", 0x040a, 0x0579, 0},
+	{"Kodak:CX7330", 0x040a, 0x057a, 0},
+	{"Kodak:CX7430", 0x040a, 0x057b, 0},
+	{"Kodak:CX7530", 0x040a, 0x057c, 0},
+	{"Kodak:DX7440", 0x040a, 0x057d, 0},
+	/* c300 Pau Rodriguez-Estivill <prodrigestivill@yahoo.es> */
+	{"Kodak:C300",   0x040a, 0x057e, 0},
+	{"Kodak:DX7590", 0x040a, 0x057f, 0},
+	{"Kodak:Z730",   0x040a, 0x0580, 0},
+	{"Kodak:CX6445", 0x040a, 0x0584, 0},
+	/* Francesco Del Prete <italyanker@gmail.com> */
+	{"Kodak:M893 IS",0x040a, 0x0585, 0},
+	{"Kodak:CX7525", 0x040a, 0x0586, 0},
+	/* a sf bugreporter */
+	{"Kodak:Z700",   0x040a, 0x0587, 0},
+	/* EasyShare Z740, Benjamin Mesing <bensmail@gmx.net> */
+	{"Kodak:Z740",   0x040a, 0x0588, 0},
+	/* EasyShare C360, Guilherme de S. Pastore via Debian */
+ 	{"Kodak:C360",   0x040a, 0x0589, 0},
+	/* Giulio Salani <ilfunambolo@gmail.com> */
+	{"Kodak:C310",   0x040a, 0x058a, 0},
+	/* Brandon Sharitt */
+	{"Kodak:C330",   0x040a, 0x058c, 0},
+	/* c340 Maurizio Daniele <hayabusa@portalis.it> */
+	{"Kodak:C340",   0x040a, 0x058d, 0},
+	{"Kodak:V530",   0x040a, 0x058e, 0},
+	/* v550 Jon Burgess <jburgess@uklinux.net> */
+	{"Kodak:V550",   0x040a, 0x058f, 0},
+	/* https://sourceforge.net/tracker/?func=detail&atid=358874&aid=1618878&group_id=8874 */
+	{"Kodak:V570",   0x040a, 0x0591, 0},
+	{"Kodak:P850",   0x040a, 0x0592, 0},
+	{"Kodak:P880",   0x040a, 0x0593, 0},
+	/* Илья Розановский <rozanovskii.ilia@gmail.com> */
+	{"Kodak:Z8612 IS",0x040a, 0x0595, 0},
+	/* https://launchpad.net/distros/ubuntu/+source/libgphoto2/+bug/67532 */
+	{"Kodak:C530",   0x040a, 0x059a, 0},
+	/* Ivan Baldo, http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=387998 */
+	{"Kodak:CD33",   0x040a, 0x059c, 0},
+	/* https://sourceforge.net/tracker/?func=detail&atid=208874&aid=1565144&group_id=8874 */
+	{"Kodak:Z612",   0x040a, 0x059d, 0},
+	/* David D. Huff Jr. <David.Huff@computer-critters.com> */
+	{"Kodak:Z650",   0x040a, 0x059e, 0},
+	/* Sonja Krause-Harder */
+	{"Kodak:M753",   0x040a, 0x059f, 0},
+	/* irc reporter */
+	{"Kodak:V603",   0x040a, 0x05a0, 0},
+	/* http://sourceforge.net/tracker/index.php?func=detail&aid=1547142&group_id=8874&atid=358874 */
+	{"Kodak:C533",   0x040a, 0x05a2, 0},
+	/* Marc Santhoff <M.Santhoff@t-online.de> */
+	{"Kodak:C643",   0x040a, 0x05a7, 0},
+	/* Eric Kibbee <eric@kibbee.ca> */
+	{"Kodak:C875",   0x040a, 0x05a9, 0},
+	/* https://launchpad.net/bugs/64146 */
+	{"Kodak:C433",   0x040a, 0x05aa, 0},
+	/* https://launchpad.net/bugs/64146 */
+	{"Kodak:V705",   0x040a, 0x05ab, 0},
+	/* https://launchpad.net/bugs/67532 */
+	{"Kodak:V610",   0x040a, 0x05ac, 0},
+	/* http://sourceforge.net/tracker/index.php?func=detail&aid=1861193&group_id=8874&atid=358874 */
+	{"Kodak:M883",   0x040a, 0x05ad, 0},
+	/* from Thomas <tomtechguy@gmail.com> */
+	{"Kodak:C743",   0x040a, 0x05ae, 0},
+	/* via IRC */
+	{"Kodak:C653",   0x040a, 0x05af, 0},
+	/* "William L. Thomson Jr." <wlt@obsidian-studios.com> */
+	{"Kodak:Z710",	 0x040a, 0x05b3, 0},
+	/* Nicolas Brodu <nicolas.brodu@free.fr> */
+	{"Kodak:Z712 IS",0x040a, 0x05b4, 0},
+	/* http://sourceforge.net/tracker/index.php?func=detail&aid=1904224&group_id=8874&atid=358874 */
+	{"Kodak:Z812 IS",0x040a, 0x05b5, 0},
+	/* */
+	{"Kodak:C613",   0x040a, 0x05b7, 0},
+	/* msp@debian.org https://bugs.kde.org/show_bug.cgi?id=190795 */
+	{"Kodak:V803",   0x040a, 0x05b8, 0},
+	/* via IRC */
+	{"Kodak:C633",   0x040a, 0x05ba, 0},
+	/* https://bugs.launchpad.net/bugs/203402 */
+	{"Kodak:ZD710",	 0x040a, 0x05c0, 0},
+	/* https://bugs.launchpad.net/ubuntu/+source/libgphoto2/+bug/385432 */
+	{"Kodak:M863",	 0x040a, 0x05c1, 0},
+	/* Peter F Bradshaw <pfb@exadios.com> */
+	{"Kodak:C813",	 0x040a, 0x05c3, 0},
+	/* reported by Christian Le Corre <lecorrec@gmail.com> */
+	{"Kodak:C913",   0x040a, 0x05c6, 0},
+	/* IRC reporter */
+	{"Kodak:Z950",   0x040a, 0x05cd, 0},
+	/* reported by Jim Nelson <jim@yorba.org> */
+	{"Kodak:M1063",  0x040a, 0x05ce, 0},
+	/* http://sourceforge.net/tracker/index.php?func=detail&aid=2889451&group_id=8874&atid=358874 */
+	{"Kodak:Z915",   0x040a, 0x05cf, 0},
+	/* l.w.winter@web.de */
+	{"Kodak:M531",   0x040a, 0x0600, 0},
+	/* rschweikert@novell.com */
+	{"Kodak:C183",   0x040a, 0x060b, 0},
+	/* ra4veiV6@lavabit.com */
+	{"Kodak:C1530",  0x040a, 0x0617, 0},
+
+	/* HP PTP cameras */
+#if 0
+	/* 0x4002 seems to be the mass storage ID, which various forums suggest. -Marcus */
+	{"HP:PhotoSmart ... ", 		 0x03f0, 0x4002, 0},
+#endif
+	{"HP:PhotoSmart 812 (PTP mode)", 0x03f0, 0x4202, 0},
+	{"HP:PhotoSmart 850 (PTP mode)", 0x03f0, 0x4302, 0},
+	/* HP PhotoSmart 935: T. Kaproncai, 25 Jul 2003*/
+	{"HP:PhotoSmart 935 (PTP mode)", 0x03f0, 0x4402, 0},
+	/* HP:PhotoSmart 945: T. Jelbert, 2004/03/29	*/
+	{"HP:PhotoSmart 945 (PTP mode)", 0x03f0, 0x4502, 0},
+	{"HP:PhotoSmart C500 (PTP mode)", 0x03f0, 0x6002, 0},
+	{"HP:PhotoSmart 318 (PTP mode)", 0x03f0, 0x6302, 0},
+	{"HP:PhotoSmart 612 (PTP mode)", 0x03f0, 0x6302, 0},
+	{"HP:PhotoSmart 715 (PTP mode)", 0x03f0, 0x6402, 0},
+	{"HP:PhotoSmart 120 (PTP mode)", 0x03f0, 0x6502, 0},
+	{"HP:PhotoSmart 320 (PTP mode)", 0x03f0, 0x6602, 0},
+	{"HP:PhotoSmart 720 (PTP mode)", 0x03f0, 0x6702, 0},
+	{"HP:PhotoSmart 620 (PTP mode)", 0x03f0, 0x6802, 0},
+	{"HP:PhotoSmart 735 (PTP mode)", 0x03f0, 0x6a02, 0},	
+	{"HP:PhotoSmart 707 (PTP mode)", 0x03f0, 0x6b02, 0},
+	{"HP:PhotoSmart 733 (PTP mode)", 0x03f0, 0x6c02, 0},
+	{"HP:PhotoSmart 607 (PTP mode)", 0x03f0, 0x6d02, 0},
+	{"HP:PhotoSmart 507 (PTP mode)", 0x03f0, 0x6e02, 0},
+        {"HP:PhotoSmart 635 (PTP mode)", 0x03f0, 0x7102, 0},
+	/* report from Federico Prat Villar <fprat@lsi.uji.es> */
+	{"HP:PhotoSmart 43x (PTP mode)", 0x03f0, 0x7202, 0},
+	{"HP:PhotoSmart M307 (PTP mode)", 0x03f0, 0x7302, 0},
+	{"HP:PhotoSmart 407 (PTP mode)",  0x03f0, 0x7402, 0},
+	{"HP:PhotoSmart M22 (PTP mode)",  0x03f0, 0x7502, 0},
+	{"HP:PhotoSmart 717 (PTP mode)",  0x03f0, 0x7602, 0},
+	{"HP:PhotoSmart 817 (PTP mode)",  0x03f0, 0x7702, 0},
+	{"HP:PhotoSmart 417 (PTP mode)",  0x03f0, 0x7802, 0},
+	{"HP:PhotoSmart 517 (PTP mode)",  0x03f0, 0x7902, 0},
+	/* http://sourceforge.net/tracker/index.php?func=detail&aid=1365941&group_id=8874&atid=108874 */
+	{"HP:PhotoSmart M415 (PTP mode)", 0x03f0, 0x7a02, 0},
+	/* irc contact, YGingras */
+	{"HP:PhotoSmart M23 (PTP mode)",  0x03f0, 0x7b02, 0},
+	{"HP:PhotoSmart 217 (PTP mode)",  0x03f0, 0x7c02, 0},
+	/* irc contact */
+	{"HP:PhotoSmart 317 (PTP mode)",  0x03f0, 0x7d02, 0},
+	{"HP:PhotoSmart 818 (PTP mode)",  0x03f0, 0x7e02, 0},
+	/* Robin <diilbert.atlantis@gmail.com> */
+	{"HP:PhotoSmart M425 (PTP mode)", 0x03f0, 0x8002, 0},
+	{"HP:PhotoSmart M525 (PTP mode)", 0x03f0, 0x8102, 0},
+	{"HP:PhotoSmart M527 (PTP mode)", 0x03f0, 0x8202, 0},
+	{"HP:PhotoSmart M725 (PTP mode)", 0x03f0, 0x8402, 0},
+	{"HP:PhotoSmart M727 (PTP mode)", 0x03f0, 0x8502, 0},
+	/* http://sourceforge.net/tracker/index.php?func=detail&aid=1584447&group_id=8874&atid=358874 */
+	{"HP:PhotoSmart R927 (PTP mode)", 0x03f0, 0x8702, 0},
+	/* R967 - Far Jump <far.jmp@gmail.com> */
+	{"HP:PhotoSmart R967 (PTP mode)", 0x03f0, 0x8802, 0},
+	{"HP:PhotoSmart E327 (PTP mode)", 0x03f0, 0x8b02, 0},
+	/* https://sourceforge.net/tracker/?func=detail&atid=358874&aid=1589879&group_id=8874  */
+	{"HP:PhotoSmart E427 (PTP mode)", 0x03f0, 0x8c02, 0},
+	/* Martin Laberge <mlsoft@videotron.ca> */
+	{"HP:PhotoSmart M737 (PTP mode)", 0x03f0, 0x9602, 0},
+	/* https://bugs.launchpad.net/bugs/178916 */
+	{"HP:PhotoSmart R742 (PTP mode)", 0x03f0, 0x9702, 0},
+	/* http://sourceforge.net/tracker/index.php?func=detail&aid=1814147&group_id=8874&atid=358874 */
+	{"HP:PhotoSmart M547 (PTP mode)", 0x03f0, 0x9b02, 0},
+
+	/* Most Sony PTP cameras use the same product/vendor IDs. */
+	{"Sony:PTP",                  0x054c, 0x004e, 0},
+	{"Sony:DSC-H1 (PTP mode)",    0x054c, 0x004e, 0},
+	{"Sony:DSC-H2 (PTP mode)",    0x054c, 0x004e, 0},
+	{"Sony:DSC-H5 (PTP mode)",    0x054c, 0x004e, 0},
+	{"Sony:DSC-N2 (PTP mode)",    0x054c, 0x004e, 0},
+	{"Sony:DSC-P5 (PTP mode)",    0x054c, 0x004e, 0},
+	{"Sony:DSC-P10 (PTP mode)",   0x054c, 0x004e, 0},
+	{"Sony:DSC-F707V (PTP mode)", 0x054c, 0x004e, 0},
+	{"Sony:DSC-F717 (PTP mode)",  0x054c, 0x004e, 0},
+	{"Sony:DSC-F828 (PTP mode)",  0x054c, 0x004e, 0},
+	{"Sony:DSC-P30 (PTP mode)",   0x054c, 0x004e, 0},
+	/* P32 reported on May 1st by Justin Alexander <justin (at) harshangel.com> */
+	{"Sony:DSC-P31 (PTP mode)",   0x054c, 0x004e, 0},
+	{"Sony:DSC-P32 (PTP mode)",   0x054c, 0x004e, 0},
+	{"Sony:DSC-P41 (PTP mode)",   0x054c, 0x004e, 0},
+	{"Sony:DSC-P43 (PTP mode)",   0x054c, 0x004e, 0},
+	{"Sony:DSC-P50 (PTP mode)",   0x054c, 0x004e, 0},
+	{"Sony:DSC-P51 (PTP mode)",   0x054c, 0x004e, 0},
+	{"Sony:DSC-P52 (PTP mode)",   0x054c, 0x004e, 0},
+	{"Sony:DSC-P71 (PTP mode)",   0x054c, 0x004e, 0},
+	{"Sony:DSC-P72 (PTP mode)",   0x054c, 0x004e, 0},
+	{"Sony:DSC-P73 (PTP mode)",   0x054c, 0x004e, 0},
+	{"Sony:DSC-P92 (PTP mode)",   0x054c, 0x004e, 0},
+	{"Sony:DSC-P93 (PTP mode)",   0x054c, 0x004e, 0},
+	{"Sony:DSC-P100 (PTP mode)",  0x054c, 0x004e, 0},
+	{"Sony:DSC-P120 (PTP mode)",  0x054c, 0x004e, 0},
+	{"Sony:DSC-P200 (PTP mode)",  0x054c, 0x004e, 0},
+	{"Sony:DSC-R1 (PTP mode)",    0x054c, 0x004e, 0},
+	{"Sony:DSC-S40 (PTP mode)",   0x054c, 0x004e, 0},
+	{"Sony:DSC-S60 (PTP mode)",   0x054c, 0x004e, 0},
+	{"Sony:DSC-S75 (PTP mode)",   0x054c, 0x004e, 0},
+	{"Sony:DSC-S85 (PTP mode)",   0x054c, 0x004e, 0},
+	{"Sony:DSC-T1 (PTP mode)",    0x054c, 0x004e, 0},
+	{"Sony:DSC-T3 (PTP mode)",    0x054c, 0x004e, 0},
+	{"Sony:DSC-T10 (PTP mode)",   0x054c, 0x004e, 0},
+	{"Sony:DSC-U20 (PTP mode)",   0x054c, 0x004e, 0},
+	{"Sony:DSC-V1 (PTP mode)",    0x054c, 0x004e, 0},
+	{"Sony:DSC-W1 (PTP mode)",    0x054c, 0x004e, 0},
+	{"Sony:DSC-W12 (PTP mode)",   0x054c, 0x004e, 0},
+	{"Sony:DSC-W35 (PTP mode)",   0x054c, 0x004e, 0},
+	{"Sony:DSC-W55 (PTP mode)",   0x054c, 0x004e, 0},
+	{"Sony:MVC-CD300 (PTP mode)", 0x054c, 0x004e, 0},
+	{"Sony:MVC-CD500 (PTP mode)", 0x054c, 0x004e, 0},
+	{"Sony:DSC-U10 (PTP mode)",   0x054c, 0x004e, 0},
+	/* "Riccardo (C10uD)" <c10ud.dev@gmail.com> */
+	{"Sony:DSC-S730 (PTP mode)",  0x054c, 0x0296, 0},
+	{"Sony:DSC-S780 (PTP mode)",  0x054c, 0x0296, 0},
+	/* Fernando Santoro <fernando.lopezjr@gmail.com> */
+	{"Sony:DSC-A100 (PTP mode)",  0x054c, 0x02c0, 0},
+	/* Sam Tseng <samtz1223@gmail.com> */
+	{"Sony:DSC-A900 (PTP mode)",  0x054c, 0x02e7, PTP_CAP},
+	/* new id?! Reported by Ruediger Oertel. */
+	{"Sony:DSC-W200 (PTP mode)",  0x054c, 0x02f8, 0},
+	/* Martin Vala <vala.martin@gmail.com> */
+	{"Sony:SLT-A350 (PTP mode)",   0x054c, 0x0321, 0},
+	/* http://sourceforge.net/tracker/index.php?func=detail&aid=1946931&group_id=8874&atid=308874 */
+	{"Sony:DSC-W130 (PTP mode)",  0x054c, 0x0343, 0},
+	/* https://sourceforge.net/p/gphoto/support-requests/115/ */
+	{"Sony:DSC-HX5V (PTP mode)",  0x054c, 0x0491, 0},
+	/* tux droid <gnutuxdroid@gmail.com> */
+	{"Sony:SLT-A55 (PTP mode)",   0x054c, 0x04a3, 0},
+	/* http://sourceforge.net/tracker/?func=detail&atid=358874&aid=3515558&group_id=8874 */
+	{"Sony:SLT-A35 (PTP mode)",   0x054c, 0x04a7, 0},
+	/* t.ludewig@gmail.com */
+	{"Sony:DSC-RX100 (PTP mode)", 0x054c, 0x052a, 0},
+	/* Stuart Nettleton <snettlet@gmail.com> */
+	{"Sony:DSC-RX1 (PTP mode)",   0x054c, 0x052b, 0},
+	/* Maptz <m13.maptz@gmail.com> */
+	{"Sony:DSC-W510 (PTP mode)",  0x054c, 0x053c, 0},
+	/* t.ludewig@gmail.com */
+	{"Sony:SLT-A65V (PTP mode)",  0x054c, 0x0574, 0},
+	/* Rudi */
+	{"Sony:DSC-HX100V (PTP mode)",0x054c, 0x0543, 0},
+
+	/* t.ludewig@gmail.com */
+	{"Sony:DSC-HX200V (PTP mode)",0x054c, 0x061f, 0},
+
+	/* https://sourceforge.net/p/gphoto/feature-requests/424/ */
+	{"Sony:SLT-A57", 	      0x054c, 0x0669, 0},
+
+	/* Mike Breeuwer <info@mikebreeuwer.com> */
+	{"Sony:SLT-A99v", 	      0x054c, 0x0675, 0},
+
+	/* Ramon Carlos Garcia Bruna <ramongarciabruna@gmail.com> */
+	{"Sony:NEX-6", 	      	      0x054c, 0x0678, 0},
+
+	/* t.ludewig@gmail.com */
+	{"Sony:DSC-HX300 (PTP mode)", 0x054c, 0x06ee, 0},
+
+	/* t.ludewig@gmail.com */
+	{"Sony:NEX-3N (PTP mode)",    0x054c, 0x072f, 0},
+
+	/* Thorsten Ludewig <t.ludewig@gmail.com> */
+	{"Sony:SLT-A58",	      0x054c, 0x0736, 0},
+	/* Marcus Meissner */
+	{"Sony:SLT-A58 (Control)",    0x054c, 0x0737, PTP_CAP},
+
+	/* Thorsten Ludewig <t.ludewig@gmail.com> */
+	{"Sony:DSC-RX100M2",	      0x054c, 0x074b, 0},
+	/* Thorsten Ludewig <t.ludewig@gmail.com> */
+	{"Sony:Alpha-A3000",	      0x054c, 0x074e, 0},
+
+	/* https://sourceforge.net/p/gphoto/support-requests/127/ */
+	{"Sony:Alpha-A5000 (Control)",0x054c, 0x07c6, PTP_CAP},
+
+	/* https://sourceforge.net/p/libmtp/bugs/1310/ */
+	{"Sony:DSC-HX60V (MTP)",      0x054c, 0x08ad, 0},
+
+	/* Sascha Peilicke at SUSE */
+	{"Sony:Alpha-A6000 (MTP)",    0x054c, 0x08b7, 0},
+
+	/* https://sourceforge.net/p/gphoto/feature-requests/456/ */
+	{"Sony:Alpha-A7S (MTP)",      0x054c, 0x08e2, 0},
+
+	/* Markus Oertel */
+	{"Sony:Alpha-A5100 (MTP)",    0x054c, 0x08e7, 0},
+
+	/* https://sourceforge.net/p/gphoto/feature-requests/442/ */
+	{"Sony:Alpha-A7r (Control)",  0x054c, 0x094d, PTP_CAP},
+
+	{"Sony:Alpha-A6000 (Control)",0x054c, 0x094e, PTP_CAP},
+
+	/* Nick Clarke <nick.clarke@gmail.com> */
+	{"Sony:Alpha-A77 M2 (Control)",0x054c, 0x0953, PTP_CAP},
+
+	/* Markus Oertel */
+	{"Sony:Alpha-A5100 (Control)",0x054c, 0x0957, PTP_CAP},
+
+	/* http://sourceforge.net/p/gphoto/feature-requests/456/ */
+	{"Sony:Alpha-A7S (Control)",  0x054c, 0x0954, PTP_CAP},
+
+	/* Nikon Coolpix 2500: M. Meissner, 05 Oct 2003 */
+	{"Nikon:Coolpix 2500 (PTP mode)", 0x04b0, 0x0109, 0},
+	/* Nikon Coolpix 5700: A. Tanenbaum, 29 Oct 2002 */
+	/* no capture complete: https://sourceforge.net/tracker/index.php?func=detail&aid=3018517&group_id=8874&atid=108874 */
+	{"Nikon:Coolpix 5700 (PTP mode)", 0x04b0, 0x010d, PTP_CAP|PTP_NO_CAPTURE_COMPLETE},
+	/* Nikon Coolpix 4500: T. Kaproncai, 22 Aug 2003 */
+	{"Nikon:Coolpix 4500 (PTP mode)", 0x04b0, 0x010b, 0},
+	/* Nikon Coolpix 4300: Marco Rodriguez, 10 dic 2002 */
+	{"Nikon:Coolpix 4300 (PTP mode)", 0x04b0, 0x010f, 0},
+	/* Nikon Coolpix 3500: M. Meissner, 07 May 2003 */
+	{"Nikon:Coolpix 3500 (PTP mode)", 0x04b0, 0x0111, 0},
+	/* Nikon Coolpix 885: S. Anderson, 19 nov 2002 */
+	{"Nikon:Coolpix 885 (PTP mode)",  0x04b0, 0x0112, 0},
+	/* Nikon Coolpix 5000, Firmware v1.7 or later */
+	{"Nikon:Coolpix 5000 (PTP mode)", 0x04b0, 0x0113, PTP_CAP|PTP_NO_CAPTURE_COMPLETE},
+	/* Nikon Coolpix 3100 */
+	{"Nikon:Coolpix 3100 (PTP mode)", 0x04b0, 0x0115, 0},
+	/* Nikon Coolpix 2100 */
+	{"Nikon:Coolpix 2100 (PTP mode)", 0x04b0, 0x0117, 0},
+	/* Nikon Coolpix 5400: T. Kaproncai, 25 Jul 2003 */
+	{"Nikon:Coolpix 5400 (PTP mode)", 0x04b0, 0x0119, PTP_CAP|PTP_NO_CAPTURE_COMPLETE},
+	/* Nikon Coolpix 3700: T. Ehlers, 18 Jan 2004 */
+	{"Nikon:Coolpix 3700 (PTP mode)", 0x04b0, 0x011d, PTP_CAP|PTP_NO_CAPTURE_COMPLETE},
+	/* https://sourceforge.net/tracker/index.php?func=detail&aid=2110825&group_id=8874&atid=108874 */
+	{"Nikon:Coolpix 8700 (PTP mode)", 0x04b0, 0x011f, 0},
+	/* Nikon Coolpix 3200 */
+	{"Nikon:Coolpix 3200 (PTP mode)", 0x04b0, 0x0121, 0},
+	/* Nikon Coolpix 2200 */
+	{"Nikon:Coolpix 2200 (PTP mode)", 0x04b0, 0x0122, PTP_CAP|PTP_NIKON_BROKEN_CAP},
+
+	/* Jonathan Marten <jonathanmarten@users.sf.net> 
+	 * https://sourceforge.net/p/gphoto/bugs/968/ */
+	{"Nikon:Coolpix 2200v1.1 (PTP mode)", 0x04b0, 0x0123, PTP_CAP|PTP_NO_CAPTURE_COMPLETE},
+
+	/* Harry Reisenleiter <harrylr@earthlink.net> */
+	{"Nikon:Coolpix 8800 (PTP mode)", 0x04b0, 0x0127, PTP_CAP},
+	/* Nikon Coolpix 4800 */
+	{"Nikon:Coolpix 4800 (PTP mode)", 0x04b0, 0x0129, 0},
+	/* Nikon Coolpix SQ: M. Holzbauer, 07 Jul 2003 */
+	{"Nikon:Coolpix 4100 (PTP mode)", 0x04b0, 0x012d, 0},
+	/* Nikon Coolpix 5600: Andy Shevchenko, 11 Aug 2005 */
+	{"Nikon:Coolpix 5600 (PTP mode)", 0x04b0, 0x012e, PTP_CAP|PTP_NIKON_BROKEN_CAP},
+	/* 4600: Martin Klaffenboeck <martin.klaffenboeck@gmx.at> */
+	{"Nikon:Coolpix 4600 (PTP mode)", 0x04b0, 0x0130, 0},
+	/* 4600: Roberto Costa <roberto.costa@ensta.org>, 22 Oct 2006 */
+	{"Nikon:Coolpix 4600a (PTP mode)", 0x04b0, 0x0131,PTP_CAP|PTP_NO_CAPTURE_COMPLETE},
+	{"Nikon:Coolpix 5900 (PTP mode)", 0x04b0, 0x0135, PTP_CAP|PTP_NIKON_BROKEN_CAP},
+	/* http://sourceforge.net/tracker/index.php?func=detail&aid=1846012&group_id=8874&atid=358874 */
+	{"Nikon:Coolpix 7900 (PTP mode)", 0x04b0, 0x0137, PTP_CAP|PTP_NIKON_BROKEN_CAP},
+	/* Egil Kvaleberg: USB says "NIKON DSC E7600-PTP" */
+	{"Nikon:Coolpix 7600 (PTP mode)", 0x04b0, 0x0139, PTP_CAP},
+
+	{"Nikon:Coolpix P1 (PTP mode)",   0x04b0, 0x0140, PTP_CAP|PTP_NIKON_BROKEN_CAP},
+	/* Marcus Meissner */
+	{"Nikon:Coolpix P2 (PTP mode)",   0x04b0, 0x0142, PTP_CAP|PTP_NO_CAPTURE_COMPLETE},
+	/* Richard SCHNEIDER <Richard.SCHNEIDER@tilak.at> */
+	{"Nikon:Coolpix S4 (PTP mode)",   0x04b0, 0x0144, 0},
+	/* Lowe, John Michael <jomlowe@iupui.edu> */
+	{"Nikon:Coolpix S2 (PTP mode)",   0x04b0, 0x014e, 0},
+	{"Nikon:Coolpix S6 (PTP mode)",   0x04b0, 0x014e, 0},
+	/* http://sourceforge.net/tracker/index.php?func=detail&aid=3114250&group_id=8874&atid=358874 */
+	{"Nikon:Coolpix S7c (PTP mode)",  0x04b0, 0x0157, 0},
+	/* Ole Aamot <ole@gnome.org> */
+	{"Nikon:Coolpix P5000 (PTP mode)",0x04b0, 0x015b, PTP_CAP|PTP_NIKON_BROKEN_CAP},
+	/* Peter Pregler <Peter_Pregler@email.com> */
+	{"Nikon:Coolpix S500 (PTP mode)", 0x04b0, 0x015d, 0},
+	{"Nikon:Coolpix L12 (PTP mode)",  0x04b0, 0x015f, PTP_CAP},
+	/* Marius Groeger <marius.groeger@web.de> */
+	{"Nikon:Coolpix S200 (PTP mode)", 0x04b0, 0x0161, PTP_CAP|PTP_NIKON_BROKEN_CAP},
+	/* Submitted on IRC by kallepersson */
+	{"Nikon:Coolpix P5100 (PTP mode)", 0x04b0, 0x0163, 0},
+	/* https://sourceforge.net/tracker/index.php?func=detail&aid=2589245&group_id=8874&atid=108874 */
+	{"Nikon:Coolpix P50 (PTP mode)",  0x04b0, 0x0169, 0},
+	/* Clodoaldo <clodoaldo.pinto.neto@gmail.com> via
+         * https://bugs.kde.org/show_bug.cgi?id=315268 */
+	{"Nikon:Coolpix P80 (PTP mode)",  0x04b0, 0x016b, PTP_CAP|PTP_NIKON_BROKEN_CAP},
+
+	/* TJ <wxtofly@gmail.com> */
+	{"Nikon:Coolpix P80 v1.1 (PTP mode)",  0x04b0, 0x016c, PTP_CAP|PTP_NIKON_BROKEN_CAP},
+
+	/* http://sourceforge.net/tracker/index.php?func=detail&aid=2951663&group_id=8874&atid=358874 */
+	{"Nikon:Coolpix P6000 (PTP mode)",0x04b0, 0x016f, PTP_CAP|PTP_NIKON_BROKEN_CAP},
+	/*   http://bugs.debian.org/520752 */
+	{"Nikon:Coolpix S60 (PTP mode)",  0x04b0, 0x0171, 0},
+	/* Mike Strickland <livinwell@georgianatives.net> */
+	{"Nikon:Coolpix P90 (PTP mode)",  0x04b0, 0x0173, 0},
+	/* Christoph Muehlmann <c.muehlmann@nagnag.de> */
+	{"Nikon:Coolpix S220 (PTP mode)", 0x04b0, 0x0177, PTP_CAP|PTP_NIKON_BROKEN_CAP},
+	/* */
+	{"Nikon:Coolpix S225 (PTP mode)", 0x04b0, 0x0178, PTP_CAP|PTP_NIKON_BROKEN_CAP},
+
+	/* Ryan Nestor <ryan@monadnock.org> */
+	{"Nikon:Coolpix P100 (PTP mode)", 0x04b0, 0x017d, PTP_CAP|PTP_NIKON_BROKEN_CAP},
+	/* Štěpán Němec <stepnem@gmail.com> */
+	{"Nikon:Coolpix P7000 (PTP mode)",0x04b0, 0x017f, PTP_CAP|PTP_NO_CAPTURE_COMPLETE},
+
+	/* http://sourceforge.net/tracker/index.php?func=detail&aid=3019787&group_id=8874&atid=358874 */
+	/* probably no need for nikon_broken_Cap as it worked without this flag for the user */
+	{"Nikon:Coolpix L110 (PTP mode)", 0x04b0, 0x017e, PTP_CAP},
+
+	/* miguel@rozsas.eng.br */
+	{"Nikon:Coolpix P500 (PTP mode)", 0x04b0, 0x0184, PTP_CAP},
+	/* Graeme Wyatt <graeme.wyatt@nookawarra.com> */
+	{"Nikon:Coolpix L120 (PTP mode)", 0x04b0, 0x0185, PTP_CAP},
+	/* Kévin Ottens <ervin@ipsquad.net> */
+	{"Nikon:Coolpix S9100 (PTP mode)",0x04b0, 0x0186, PTP_CAP},
+
+	/* johnnolan@comcast.net */
+	{"Nikon:Coolpix AW100 (PTP mode)",0x04b0, 0x0188, PTP_CAP},
+
+	/* Dale Pontius <DEPontius@edgehp.net> */
+	{"Nikon:Coolpix P7100 (PTP mode)",0x04b0, 0x018b, PTP_CAP},
+
+	/* "Dr. Ing. Dieter Jurzitza" <dieter.jurzitza@t-online.de> */
+	{"Nikon:Coolpix 9400  (PTP mode)",0x04b0, 0x0191, PTP_CAP},
+
+	/* t.ludewig@gmail.com */
+	{"Nikon:Coolpix L820  (PTP mode)",0x04b0, 0x0192, PTP_CAP},
+	/* https://sourceforge.net/p/gphoto/feature-requests/429/ */
+	{"Nikon:Coolpix S9500 (PTP mode)",0x04b0, 0x0193, PTP_CAP},
+
+	{"Nikon:Coolpix SQ (PTP mode)",   0x04b0, 0x0202, 0},
+	/* lars marowski bree, 16.8.2004 */
+	{"Nikon:Coolpix 4200 (PTP mode)", 0x04b0, 0x0204, 0},
+	/* Nikon Coolpix 5200: Andy Shevchenko, 18 Jul 2005 */
+	{"Nikon:Coolpix 5200 (PTP mode)", 0x04b0, 0x0206, 0},
+	/* https://launchpad.net/bugs/63473 */
+	{"Nikon:Coolpix L1 (PTP mode)",   0x04b0, 0x0208, 0},
+	{"Nikon:Coolpix P4 (PTP mode)",   0x04b0, 0x020c, PTP_CAP},
+	/* Bo Masser <bo@massers.se> */
+	{"Nikon:Coolpix S620 (PTP mode)", 0x04b0, 0x021c, 0},
+	{"Nikon:Coolpix S6000 (PTP mode)",0x04b0, 0x021e, 0},
+	/* http://sourceforge.net/tracker/index.php?func=detail&aid=3135935&group_id=8874&atid=358874 */
+	{"Nikon:Coolpix S8000 (PTP mode)",0x04b0, 0x021f, 0},
+	/* Aleksej Serdjukov <deletesoftware@yandex.ru> */
+	{"Nikon:Coolpix S5100 (PTP mode)",0x04b0, 0x0220, 0},
+	/* wlady.cs@gmail.com */
+	{"Nikon:Coolpix P300 (PTP mode)", 0x04b0, 0x0221, 0},
+	/* t.ludewig@gmail.com */
+	{"Nikon:Coolpix S8200",           0x04b0, 0x0222, 0},
+	{"Nikon:Coolpix P510 (PTP mode)", 0x04b0, 0x0223, 0},
+	/* Bernhard Schiffner <bernhard@schiffner-limbach.de> */
+	{"Nikon:Coolpix P7700 (PTP mode)",0x04b0, 0x0225, 0},
+
+	/* t.ludewig@gmail.com */
+	/* N CP A seems capture capable, but does not list vendor commands */
+	/* Reports 0x400d aka CaptureComplete event ... but has no 
+	 * vendor commands? yeah right ... */
+	/* It might be similar to the 1? lets try ... Marcus 20140706 */
+	{"Nikon:Coolpix A (PTP mode)",	  0x04b0, 0x0226, PTP_CAP|PTP_NIKON_1}, /* PTP_CAP */
+
+	/* Jonas Stein <news@jonasstein.de> */
+	{"Nikon:Coolpix P330 (PTP mode)", 0x04b0, 0x0227, PTP_CAP},
+
+	/* Malcolm Lee <mallee@mallee45.ukfsn.org> */
+	{"Nikon:Coolpix P7800 (PTP mode)", 0x04b0, 0x0229, 0},
+
+	/* t.ludewig@gmail.com */
+	/* Also reports 0x400d aka CaptureComplete event ... but has no 
+	 * vendor commands? yeah right... */
+	{"Nikon:Coolpix P520 (PTP mode)", 0x04b0, 0x0228, 0}, /* PTP_CAP */
+
+	/* Nikon Coolpix 2000 */
+	{"Nikon:Coolpix 2000 (PTP mode)", 0x04b0, 0x0302, 0},
+	/* From IRC reporter. */
+	{"Nikon:Coolpix L4 (PTP mode)",   0x04b0, 0x0305, 0},
+	/* from Magnus Larsson */
+	{"Nikon:Coolpix L11 (PTP mode)",  0x04b0, 0x0309, 0},
+	/* From IRC reporter. */
+	{"Nikon:Coolpix L10 (PTP mode)",  0x04b0, 0x030b, 0},
+	/* Philippe ENTZMANN <philippe@phec.net> */
+	{"Nikon:Coolpix P60 (PTP mode)",  0x04b0, 0x0311, PTP_CAP|PTP_NIKON_BROKEN_CAP},
+	/* Stas Timokhin <st@ngs.ru> */
+	{"Nikon:Coolpix L16 (PTP mode)",  0x04b0, 0x0315, PTP_CAP|PTP_NIKON_BROKEN_CAP},
+	/* https://sourceforge.net/tracker/index.php?func=detail&aid=2977303&group_id=8874&atid=358874 */
+	{"Nikon:Coolpix L20 (PTP mode)",  0x04b0, 0x0317, PTP_CAP|PTP_NIKON_BROKEN_CAP},
+	/* https://sourceforge.net/tracker/index.php?func=detail&aid=2947644&group_id=8874&atid=108874 */
+	{"Nikon:Coolpix L19 (PTP mode)",  0x04b0, 0x0318, PTP_CAP|PTP_NIKON_BROKEN_CAP},
+	/* IRC reporter */
+	{"Nikon:Coolpix S3000 (PTP mode)",0x04b0, 0x031b, PTP_CAP},
+	/* christian.moll@tudor.lu */
+	{"Nikon:Coolpix S3100 (PTP mode)",0x04b0, 0x0320, PTP_CAP},
+	/* Teemu rytilahti of KDE */
+	{"Nikon:Coolpix S2500 (PTP mode)",0x04b0, 0x0321, PTP_CAP},
+	/* Fabio <ctrlaltca@gmail.com> */
+	{"Nikon:Coolpix L23 (PTP mode)",  0x04b0, 0x0324, PTP_CAP},
+	/* Novell bugzilla 852551 */
+	{"Nikon:Coolpix S4300 (PTP mode)",0x04b0, 0x0329, PTP_CAP/*?*/},
+	/* "M.-A. DARCHE" <ma.darche@cynode.org> . gets capturecomplete events nicely */
+	{"Nikon:Coolpix S3300 (PTP mode)",0x04b0, 0x032a, PTP_CAP},
+	/* sakax <sakamotox@gmail.com> */
+	{"Nikon:Coolpix S2600 (PTP mode)",0x04b0, 0x032d, PTP_CAP},
+
+	/* Borja Latorre <borja.latorre@csic.es> */
+	{"Nikon:Coolpix S3200",		  0x04b0, 0x0334, PTP_CAP},
+
+
+	/* t.ludewig@gmail.com */
+	{"Nikon:Coolpix S01",  		  0x04b0, 0x0337, PTP_CAP},
+
+	/* https://sourceforge.net/p/gphoto/bugs/971/ */
+	{"Nikon:Coolpix S2700", 	  0x04b0, 0x033f, PTP_CAP},
+
+	/* Jeremy Harkcom <jeremy@harkcom.co.uk> */
+	{"Nikon:Coolpix L27",		  0x04b0, 0x0343, PTP_CAP},
+
+	/* t.ludewig@gmail.com */
+	{"Nikon:Coolpix S02",  		  0x04b0, 0x0346, PTP_CAP},
+
+	/* t.ludewig@gmail.com */
+	/* seems not to report events? but has full liveview caps_ */
+	{"Nikon:Coolpix S9700", 	  0x04b0, 0x034b, PTP_CAP|PTP_CAP_PREVIEW|PTP_NIKON_BROKEN_CAP},
+
+	/* Nikon D100 has a PTP mode: westin 2002.10.16 */
+	{"Nikon:DSC D100 (PTP mode)",     0x04b0, 0x0402, 0},
+	/* D2H SLR in PTP mode from Steve Drew <stevedrew@gmail.com> */
+	{"Nikon:D2H SLR (PTP mode)",      0x04b0, 0x0404, 0},
+	{"Nikon:DSC D70 (PTP mode)",      0x04b0, 0x0406, PTP_CAP},
+	/* Justin Case <justin_case@gmx.net> */
+	{"Nikon:D2X SLR (PTP mode)",      0x04b0, 0x0408, PTP_CAP},
+	/* Niclas Gustafsson (nulleman @ sf) */
+	{"Nikon:D50 (PTP mode)",          0x04b0, 0x040a, PTP_CAP}, /* no hidden props */
+	/* Didier Gasser-Morlay <didiergm@gmail.com> */
+	{"Nikon:D2Hs (PTP mode)",	  0x04b0, 0x040c, PTP_CAP},
+	{"Nikon:DSC D70s (PTP mode)",     0x04b0, 0x040e, PTP_CAP},
+	/* Jana Jaeger <jjaeger.suse.de> */
+	{"Nikon:DSC D200 (PTP mode)",     0x04b0, 0x0410, PTP_CAP},
+	/* Christian Deckelmann @ SUSE */
+	{"Nikon:DSC D80 (PTP mode)",      0x04b0, 0x0412, PTP_CAP},
+	/* Huy Hoang <hoang027@umn.edu> */
+	{"Nikon:DSC D40 (PTP mode)",      0x04b0, 0x0414, PTP_CAP},
+	/* Mark de Ruijter <mark@ridersoft.net> */
+	{"Nikon:DSC D2Xs (PTP mode)",     0x04b0, 0x0416, PTP_CAP},
+	/* Luca Gervasi <luca.gervasi@gmail.com> */
+	{"Nikon:DSC D40x (PTP mode)",     0x04b0, 0x0418, PTP_CAP},
+	/* Andreas Jaeger <aj@suse.de>.
+	 * Marcus: MTP Proplist does not return objectsizes ... useless. */
+	{"Nikon:DSC D300 (PTP mode)",	  0x04b0, 0x041a, PTP_CAP},
+	/* Pat Shanahan, http://sourceforge.net/tracker/index.php?func=detail&aid=1924511&group_id=8874&atid=358874 */
+	{"Nikon:D3 (PTP mode)",		  0x04b0, 0x041c, PTP_CAP},
+	/* irc reporter Benjamin Schindler */
+	{"Nikon:DSC D60 (PTP mode)",	  0x04b0, 0x041e, PTP_CAP},
+
+	/* pbj304 pbj@ecs.soton.ac.uk */
+	{"Nikon:DSC D3x (PTP mode)",	  0x04b0, 0x0420, PTP_CAP|PTP_CAP_PREVIEW},
+
+	/* Will Stephenson at SUSE and wstephenson@flickr */
+	{"Nikon:DSC D90 (PTP mode)",	  0x04b0, 0x0421, PTP_CAP|PTP_CAP_PREVIEW},
+	/* Borrowed D700 by deckel / marcus at SUSE */
+	{"Nikon:DSC D700 (PTP mode)",	  0x04b0, 0x0422, PTP_CAP|PTP_CAP_PREVIEW},
+	/* Stephan Barth at SUSE */
+	{"Nikon:DSC D5000 (PTP mode)",    0x04b0, 0x0423, PTP_CAP|PTP_CAP_PREVIEW},
+	/* IRC reporter */
+	{"Nikon:DSC D3000 (PTP mode)",    0x04b0, 0x0424, PTP_CAP|PTP_CAP_PREVIEW},
+	/* Andreas Dielacher <andreas.dielacher@gmail.com> */
+	{"Nikon:DSC D300s (PTP mode)",    0x04b0, 0x0425, PTP_CAP|PTP_CAP_PREVIEW},
+	/* Matthias Blaicher <blaicher@googlemail.com> */
+	{"Nikon:DSC D3s (PTP mode)",      0x04b0, 0x0426, PTP_CAP|PTP_CAP_PREVIEW},
+	/* SWPLinux IRC reporter... does not have liveview -lowend model. */
+	{"Nikon:DSC D3100 (PTP mode)",	  0x04b0, 0x0427, PTP_CAP|PTP_CAP_PREVIEW},
+	/* http://sourceforge.net/tracker/?func=detail&atid=358874&aid=3140014&group_id=8874 */
+	{"Nikon:DSC D7000 (PTP mode)",    0x04b0, 0x0428, PTP_CAP|PTP_CAP_PREVIEW},
+
+	/* IRC Reporter popolon */
+	{"Nikon:DSC D5100 (PTP mode)",    0x04b0, 0x0429, PTP_CAP|PTP_CAP_PREVIEW},
+
+	/* "François G." <francois@webcampak.com> */
+	{"Nikon:DSC D800",	          0x04b0, 0x042a, PTP_CAP|PTP_CAP_PREVIEW},
+
+	/* Christian Deckelmann of Xerox */
+	{"Nikon:DSC D4",	          0x04b0, 0x042b, PTP_CAP|PTP_CAP_PREVIEW},
+
+	/* Lihuijun <lihuiplus@hotmail.com> */
+	{"Nikon:DSC D3200",	          0x04b0, 0x042c, PTP_CAP|PTP_CAP_PREVIEW},
+
+	/* t.ludewig@gmail.com */
+	{"Nikon:DSC D600",	          0x04b0, 0x042d, PTP_CAP|PTP_CAP_PREVIEW},
+	/* Roderick Stewart <roderick.stewart@gmail.com> */
+	{"Nikon:DSC D800E",               0x04b0, 0x042e, PTP_CAP|PTP_CAP_PREVIEW},
+	/* Simeon Pilgrim <simeon.pilgrim@gmail.com> */
+	{"Nikon:DSC D5200",               0x04b0, 0x042f, PTP_CAP|PTP_CAP_PREVIEW},
+
+	/* t.ludewig@gmail.com */
+	{"Nikon:DSC D7100",               0x04b0, 0x0430, PTP_CAP|PTP_CAP_PREVIEW},
+
+	/* Kirill Bogdanenk <kirill.bogdanenko@gmail.com> via kde bug 336523 */
+	{"Nikon:DSC D5300",               0x04b0, 0x0431, PTP_CAP|PTP_CAP_PREVIEW},
+
+	/* https://sourceforge.net/p/gphoto/feature-requests/449/ */
+	{"Nikon:DSC D3300",               0x04b0, 0x0433, PTP_CAP|PTP_CAP_PREVIEW},
+
+	/* Andre Crone <andre@elysia.nl> */
+	{"Nikon:DSC D610",                0x04b0, 0x0434, PTP_CAP|PTP_CAP_PREVIEW},
+
+	/* Andre Crone <andre@elysia.nl> */
+	{"Nikon:DSC D4s",		  0x04b0, 0x0435, PTP_CAP|PTP_CAP_PREVIEW},
+
+	/* Jeremie FROLI <jfroli@webmail.alten.fr> */
+	{"Nikon:DSC D810",                0x04b0, 0x0436, PTP_CAP|PTP_CAP_PREVIEW},
+
+	/*Jürgen Blumenschein <blumenschein@huntington-info.eu> */
+	{"Nikon:DSC D750",                0x04b0, 0x0437, PTP_CAP|PTP_CAP_PREVIEW},
+
+	/* http://sourceforge.net/tracker/?func=detail&aid=3536904&group_id=8874&atid=108874 */
+	{"Nikon:V1",    		  0x04b0, 0x0601, PTP_CAP|PTP_NIKON_1},
+	/* https://sourceforge.net/tracker/?func=detail&atid=358874&aid=3556403&group_id=8874 */
+	{"Nikon:J1",    		  0x04b0, 0x0602, PTP_CAP|PTP_NIKON_1},
+	/* https://bugzilla.novell.com/show_bug.cgi?id=814622 Martin Caj at SUSE */
+	{"Nikon:J2",    		  0x04b0, 0x0603, PTP_CAP|PTP_NIKON_1},
+	/* https://sourceforge.net/p/gphoto/feature-requests/432/ */
+	{"Nikon:V2",    		  0x04b0, 0x0604, PTP_CAP|PTP_NIKON_1},
+	/* Ralph Schindler <ralph@ralphschindler.com> */
+	{"Nikon:J3",    		  0x04b0, 0x0605, PTP_CAP|PTP_NIKON_1},
+	/* Markus Karlhuber <markus.karlhuber@gmail.com> */
+	{"Nikon:S1",    		  0x04b0, 0x0606, PTP_CAP|PTP_NIKON_1},
+	/* Raj Kumar <raj@archive.org> */
+	{"Nikon:J4",    		  0x04b0, 0x0609, PTP_CAP|PTP_NIKON_1},
+	
+#if 0
+	/* Thomas Luzat <thomas.luzat@gmx.net> */
+	/* this was reported as not working, mass storage only:
+	 * http://sourceforge.net/tracker/index.php?func=detail&aid=1847471&group_id=8874&atid=108874
+	{"Panasonic:DMC-FZ20 (alternate id)", 0x04da, 0x2372, 0},
+	*/
+	/* http://sourceforge.net/tracker/index.php?func=detail&aid=1350226&group_id=8874&atid=208874 */
+	{"Panasonic:DMC-LZ2",             0x04da, 0x2372, 0},
+	/* https://sourceforge.net/tracker/index.php?func=detail&aid=1405541&group_id=8874&atid=358874 */
+	{"Panasonic:DMC-LC1",             0x04da, 0x2372, 0},
+	/* http://sourceforge.net/tracker/index.php?func=detail&aid=1275100&group_id=8874&atid=358874 */
+	{"Panasonic:Lumix FZ5",           0x04da, 0x2372, 0},
+#endif
+
+	{"Panasonic:DMC-FZ20",            0x04da, 0x2374, 0},
+	{"Panasonic:DMC-FZ45",            0x04da, 0x2374, 0},
+	{"Panasonic:DMC-FZ38",            0x04da, 0x2374, 0},
+	{"Panasonic:DMC-FZ50",            0x04da, 0x2374, 0},
+	{"Panasonic:DMC-LS2",             0x04da, 0x2374, 0},
+	/* from Tomas Herrdin <tomas.herrdin@swipnet.se> */
+	{"Panasonic:DMC-LS3",             0x04da, 0x2374, 0},
+	/* https://sourceforge.net/tracker/index.php?func=detail&aid=2070864&group_id=8874&atid=358874 */
+	{"Panasonic:DMC-TZ15",		  0x04da, 0x2374, 0},
+	/* https://sourceforge.net/tracker/?func=detail&atid=358874&aid=2950529&group_id=8874 */
+	{"Panasonic:DMC-FS62",		  0x04da, 0x2374, 0},
+	{"Panasonic:DMC-TZ18",		  0x04da, 0x2374, 0},
+	/* Jean Ribière <jean.ribiere@orange.fr> */
+	{"Panasonic:DMC-TZ8",		  0x04da, 0x2374, 0},
+	{"Panasonic:DMC-LX7",		  0x04da, 0x2374, 0},
+	/* Constantin B <klochto@gmail.com> */
+	{"Panasonic:DMC-GF1",             0x04da, 0x2374, 0},
+
+	/* Søren Krarup Olesen <sko@acoustics.aau.dk> */
+	{"Leica:D-LUX 2",                 0x04da, 0x2375, 0},
+
+	/* http://callendor.zongo.be/wiki/OlympusMju500 */
+	{"Olympus:mju 500",               0x07b4, 0x0113, 0},
+
+        /* Olympus wrap test code */
+	{"Olympus:E series (Control)",	  0x07b4, 0x0110, PTP_OLYMPUS_XML},
+
+#if 0 /* talks PTP via SCSI vendor command backchannel, like above. */
+	{"Olympus:E-410 (UMS 2 mode)",    0x07b4, 0x0118, 0}, /* not XML wrapped */
+#endif
+
+	/* From VICTOR <viaaurea@yahoo.es> */
+	{"Olympus:C-350Z",                0x07b4, 0x0114, 0},
+	{"Olympus:D-560Z",                0x07b4, 0x0114, 0},
+	{"Olympus:X-250",                 0x07b4, 0x0114, 0},
+	/* http://sourceforge.net/tracker/index.php?func=detail&aid=1349900&group_id=8874&atid=108874 */
+	{"Olympus:C-310Z",                0x07b4, 0x0114, 0},
+	{"Olympus:D-540Z",                0x07b4, 0x0114, 0},
+	{"Olympus:X-100",                 0x07b4, 0x0114, 0},
+	/* https://sourceforge.net/tracker/index.php?func=detail&aid=1442115&group_id=8874&atid=358874 */
+	{"Olympus:C-55Z",                 0x07b4, 0x0114, 0},
+	{"Olympus:C-5500Z",               0x07b4, 0x0114, 0},
+
+	/* https://sourceforge.net/tracker/?func=detail&atid=358874&aid=1272944&group_id=8874 */
+	{"Olympus:IR-300",                0x07b4, 0x0114, 0},
+
+	/* Marcus */
+	{"Olympus:FE4000",                0x07b4, 0x0116, 0},
+	{"Olympus:X920",                  0x07b4, 0x0116, 0},
+	{"Olympus:X925",                  0x07b4, 0x0116, 0},
+
+	/* t.ludewig@gmail.com */
+	{"Olympus:SP-720UZ",		  0x07b4, 0x012f, 0},
+	{"Olympus:E-PL5",		  0x07b4, 0x012f, 0},
+	/* Rafał Bryndza <abigor82@gmail.com> */
+	{"Olympus:E-M5",		  0x07b4, 0x012f, 0},
+
+	/* IRC report */
+	{"Casio:EX-Z120",                 0x07cf, 0x1042, 0},
+	/* Andrej Semen (at suse) */
+	{"Casio:EX-S770",                 0x07cf, 0x1049, 0},
+	/* https://launchpad.net/bugs/64146 */
+	{"Casio:EX-Z700",                 0x07cf, 0x104c, 0},
+	/* IRC Reporter */
+	{"Casio:EX-Z65",                  0x07cf, 0x104d, 0},
+
+	/* Juan Carlos Bretal Fernandez <juanc.bretal@gmail.com> */
+	{"Casio:EX-ZR700",                0x07cf, 0x117a, 0},
+
+	/* (at least some) newer Canon cameras can be switched between
+	 * PTP and "normal" (i.e. Canon) mode
+	 * Canon PS G3: A. Marinichev, 20 nov 2002
+	 */
+	{"Canon:PowerShot S45 (PTP mode)",      0x04a9, 0x306d, PTPBUG_DELETE_SENDS_EVENT},
+		/* 0x306c is S45 in normal (canon) mode */
+	{"Canon:PowerShot G3 (PTP mode)",       0x04a9, 0x306f, PTPBUG_DELETE_SENDS_EVENT|PTP_CAP|PTP_CAP_PREVIEW},
+		/* 0x306e is G3 in normal (canon) mode */
+	{"Canon:PowerShot S230 (PTP mode)",     0x04a9, 0x3071, PTPBUG_DELETE_SENDS_EVENT|PTP_CAP|PTP_CAP_PREVIEW},
+		/* 0x3070 is S230 in normal (canon) mode */
+	{"Canon:Digital IXUS v3 (PTP mode)",    0x04a9, 0x3071, PTPBUG_DELETE_SENDS_EVENT|PTP_CAP|PTP_CAP_PREVIEW},
+		/* it's the same as S230 */
+
+	{"Canon:Digital IXUS II (PTP mode)",    0x04a9, 0x3072, PTPBUG_DELETE_SENDS_EVENT|PTP_CAP|PTP_CAP_PREVIEW},
+	{"Canon:PowerShot SD100 (PTP mode)",    0x04a9, 0x3072, PTPBUG_DELETE_SENDS_EVENT|PTP_CAP|PTP_CAP_PREVIEW},
+	{"Canon:PowerShot A70 (PTP)",           0x04a9, 0x3073, PTPBUG_DELETE_SENDS_EVENT|PTP_CAP|PTP_CAP_PREVIEW},
+	{"Canon:PowerShot A60 (PTP)",           0x04a9, 0x3074, PTPBUG_DELETE_SENDS_EVENT|PTP_CAP|PTP_CAP_PREVIEW},
+		/* IXUS 400 has the same PID in both modes, Till Kamppeter */
+	{"Canon:Digital IXUS 400 (PTP mode)",   0x04a9, 0x3075, PTPBUG_DELETE_SENDS_EVENT|PTP_CAP|PTP_CAP_PREVIEW},
+	{"Canon:PowerShot S400 (PTP mode)",	0x04a9, 0x3075, PTPBUG_DELETE_SENDS_EVENT|PTP_CAP|PTP_CAP_PREVIEW},
+	{"Canon:PowerShot A300 (PTP mode)",     0x04a9, 0x3076, PTPBUG_DELETE_SENDS_EVENT|PTP_CAP|PTP_CAP_PREVIEW},
+	{"Canon:PowerShot S50 (PTP mode)",      0x04a9, 0x3077, PTPBUG_DELETE_SENDS_EVENT|PTP_CAP|PTP_CAP_PREVIEW},
+	{"Canon:PowerShot G5 (PTP mode)",       0x04a9, 0x3085, PTPBUG_DELETE_SENDS_EVENT|PTP_CAP|PTP_CAP_PREVIEW},
+	{"Canon:Elura 50 (PTP mode)",           0x04a9, 0x3087, PTPBUG_DELETE_SENDS_EVENT},
+	{"Canon:MVX3i (PTP mode)",              0x04a9, 0x308d, PTPBUG_DELETE_SENDS_EVENT},
+		/* 0x3084 is the EOS 300D/Digital Rebel in normal (canon) mode */
+	{"Canon:EOS 300D (PTP mode)",           0x04a9, 0x3099, 0},
+	{"Canon:EOS Digital Rebel (PTP mode)",  0x04a9, 0x3099, 0},
+	{"Canon:EOS Kiss Digital (PTP mode)",   0x04a9, 0x3099, 0},
+	{"Canon:PowerShot A80 (PTP)",           0x04a9, 0x309a, PTPBUG_DELETE_SENDS_EVENT|PTP_CAP|PTP_CAP_PREVIEW},
+	{"Canon:Digital IXUS i (PTP mode)",     0x04a9, 0x309b, PTPBUG_DELETE_SENDS_EVENT},
+	{"Canon:PowerShot S1 IS (PTP mode)",    0x04a9, 0x309c, PTPBUG_DELETE_SENDS_EVENT|PTP_CAP|PTP_CAP_PREVIEW},
+	{"Canon:MV750i (PTP mode)",    		0x04a9, 0x30a0, PTPBUG_DELETE_SENDS_EVENT},
+	/* Canon Elura 65, provolone on #gphoto on 2006-12-17 */
+	{"Canon:Elura 65 (PTP mode)",           0x04a9, 0x30a5, PTPBUG_DELETE_SENDS_EVENT},
+	{"Canon:Powershot S70 (PTP mode)",      0x04a9, 0x30b1, PTPBUG_DELETE_SENDS_EVENT|PTP_CAP|PTP_CAP_PREVIEW},
+	{"Canon:Powershot S60 (PTP mode)",      0x04a9, 0x30b2, PTPBUG_DELETE_SENDS_EVENT|PTP_CAP|PTP_CAP_PREVIEW},
+	{"Canon:Powershot G6 (PTP mode)",       0x04a9, 0x30b3, PTPBUG_DELETE_SENDS_EVENT|PTP_CAP|PTP_CAP_PREVIEW},
+	{"Canon:Digital IXUS 500 (PTP mode)",   0x04a9, 0x30b4, PTPBUG_DELETE_SENDS_EVENT|PTP_CAP|PTP_CAP_PREVIEW},
+	{"Canon:PowerShot S500 (PTP mode)",     0x04a9, 0x30b4, PTPBUG_DELETE_SENDS_EVENT|PTP_CAP|PTP_CAP_PREVIEW},
+	{"Canon:PowerShot A75 (PTP mode)",      0x04a9, 0x30b5, PTPBUG_DELETE_SENDS_EVENT|PTP_CAP|PTP_CAP_PREVIEW},
+	{"Canon:PowerShot SD110 (PTP mode)",    0x04a9, 0x30b6, PTPBUG_DELETE_SENDS_EVENT|PTP_CAP|PTP_CAP_PREVIEW},
+	{"Canon:Digital IXUS IIs (PTP mode)",   0x04a9, 0x30b6, PTPBUG_DELETE_SENDS_EVENT|PTP_CAP|PTP_CAP_PREVIEW},
+	{"Canon:PowerShot A400 (PTP mode)",     0x04a9, 0x30b7, PTPBUG_DELETE_SENDS_EVENT|PTP_CAP|PTP_CAP_PREVIEW},
+	{"Canon:PowerShot A310 (PTP mode)",     0x04a9, 0x30b8, PTPBUG_DELETE_SENDS_EVENT|PTP_CAP|PTP_CAP_PREVIEW},
+	{"Canon:PowerShot A85 (PTP mode)",      0x04a9, 0x30b9, PTPBUG_DELETE_SENDS_EVENT|PTP_CAP|PTP_CAP_PREVIEW},
+	{"Canon:Digital IXUS 430 (PTP mode)",   0x04a9, 0x30ba, PTPBUG_DELETE_SENDS_EVENT|PTP_CAP|PTP_CAP_PREVIEW},
+ 	{"Canon:PowerShot S410 (PTP mode)",     0x04a9, 0x30ba, PTPBUG_DELETE_SENDS_EVENT|PTP_CAP|PTP_CAP_PREVIEW},
+ 	{"Canon:PowerShot A95 (PTP mode)",      0x04a9, 0x30bb, PTPBUG_DELETE_SENDS_EVENT|PTP_CAP|PTP_CAP_PREVIEW},
+ 	{"Canon:EOS 10D (PTP mode)",      	0x04a9, 0x30bc, PTPBUG_DELETE_SENDS_EVENT},
+	{"Canon:Digital IXUS 40 (PTP mode)",    0x04a9, 0x30bf, PTPBUG_DELETE_SENDS_EVENT},
+ 	{"Canon:PowerShot SD200 (PTP mode)",    0x04a9, 0x30c0, PTPBUG_DELETE_SENDS_EVENT|PTP_CAP|PTP_CAP_PREVIEW},
+ 	{"Canon:Digital IXUS 30 (PTP mode)",    0x04a9, 0x30c0, PTPBUG_DELETE_SENDS_EVENT|PTP_CAP|PTP_CAP_PREVIEW},
+ 	{"Canon:PowerShot A520 (PTP mode)",     0x04a9, 0x30c1, PTPBUG_DELETE_SENDS_EVENT|PTP_CAP|PTP_CAP_PREVIEW},
+	{"Canon:PowerShot A510 (PTP mode)",     0x04a9, 0x30c2, PTPBUG_DELETE_SENDS_EVENT|PTP_CAP|PTP_CAP_PREVIEW},
+	{"Canon:EOS 1D Mark II (PTP mode)",     0x04a9, 0x30ea, 0},
+ 	{"Canon:EOS 20D (PTP mode)",            0x04a9, 0x30ec, 0},
+	/* 30ef is the ID in explicit PTP mode.
+	 * 30ee is the ID with the camera in Canon mode, but the camera reacts to
+	 * PTP commands according to:
+	 * https://sourceforge.net/tracker/?func=detail&atid=108874&aid=1394326&group_id=8874
+	 * They need to have different names.
+	 */
+	{"Canon:EOS 350D (PTP mode)",           0x04a9, 0x30ee, 0},
+	{"Canon:EOS 350D",                      0x04a9, 0x30ef, 0},
+	{"Canon:PowerShot S2 IS (PTP mode)",    0x04a9, 0x30f0, PTPBUG_DELETE_SENDS_EVENT|PTP_CAP|PTP_CAP_PREVIEW},
+	{"Canon:PowerShot SD430 (PTP mode)",    0x04a9, 0x30f1, PTPBUG_DELETE_SENDS_EVENT},
+	{"Canon:Digital IXUS Wireless (PTP mode)",0x04a9, 0x30f1, PTPBUG_DELETE_SENDS_EVENT},
+	{"Canon:Digital IXUS 700 (PTP mode)",   0x04a9, 0x30f2, PTPBUG_DELETE_SENDS_EVENT},
+	{"Canon:PowerShot SD500 (PTP mode)",    0x04a9, 0x30f2, PTPBUG_DELETE_SENDS_EVENT|PTP_CAP|PTP_CAP_PREVIEW},
+	/* reported by Gilles Dartiguelongue <dartigug@esiee.fr> */
+	{"Canon:Digital IXUS iZ (PTP mode)",    0x04a9, 0x30f4, PTPBUG_DELETE_SENDS_EVENT},
+	/* A340, Andreas Stempfhuber <andi@afulinux.de> */
+	{"Canon:PowerShot A430 (PTP mode)",     0x04a9, 0x30f8, PTPBUG_DELETE_SENDS_EVENT},
+	/* Conan Colx, A410, gphoto-Feature Requests-1342538 */
+	{"Canon:PowerShot A410 (PTP mode)",     0x04a9, 0x30f9, PTPBUG_DELETE_SENDS_EVENT},
+	/* http://sourceforge.net/tracker/index.php?func=detail&aid=1411976&group_id=8874&atid=358874 */
+	{"Canon:PowerShot S80 (PTP mode)",      0x04a9, 0x30fa, PTPBUG_DELETE_SENDS_EVENT|PTP_CAP|PTP_CAP_PREVIEW},
+	/* A620, Tom Roelz */
+	{"Canon:PowerShot A620 (PTP mode)",     0x04a9, 0x30fc, PTPBUG_DELETE_SENDS_EVENT|PTP_CAP|PTP_CAP_PREVIEW},
+	/* A610, Andriy Kulchytskyy <whoops@ukrtop.com> */
+	{"Canon:PowerShot A610 (PTP mode)",     0x04a9, 0x30fd, PTPBUG_DELETE_SENDS_EVENT},
+	/* Irc Reporter */
+	{"Canon:PowerShot SD630 (PTP mode)",	0x04a9, 0x30fe, PTPBUG_DELETE_SENDS_EVENT},
+	{"Canon:Digital IXUS 65 (PTP mode)",	0x04a9, 0x30fe, PTPBUG_DELETE_SENDS_EVENT},
+	/* Rob Lensen <rob@bsdfreaks.nl> */
+	{"Canon:Digital IXUS 55 (PTP mode)",    0x04a9, 0x30ff, 0},
+	{"Canon:PowerShot SD450 (PTP mode)",    0x04a9, 0x30ff, 0},
+ 	{"Canon:Optura 600 (PTP mode)",         0x04a9, 0x3105, 0},
+	/* Jeff Mock <jeff@mock.com> */
+ 	{"Canon:EOS 5D (PTP mode)",             0x04a9, 0x3102, 0},
+	/* Nick Richards <nick@nedrichards.com> */
+	{"Canon:Digital IXUS 50 (PTP mode)",    0x04a9, 0x310e, PTPBUG_DELETE_SENDS_EVENT},
+	/* http://sourceforge.net/tracker/index.php?func=detail&aid=1640547&group_id=8874&atid=358874 */
+	{"Canon:PowerShot A420 (PTP mode)",     0x04a9, 0x310f, PTPBUG_DELETE_SENDS_EVENT},
+	/* Some Canon 400D do not have the infamous PTP bug, but some do.
+	 * see http://bugs.kde.org/show_bug.cgi?id=141577 -Marcus */
+	{"Canon:EOS 400D (PTP mode)",           0x04a9, 0x3110, PTP_CAP},
+	{"Canon:EOS Digital Rebel XTi (PTP mode)", 0x04a9, 0x3110, PTP_CAP},
+	{"Canon:EOS Kiss Digital X (PTP mode)", 0x04a9, 0x3110, PTP_CAP},
+	/* https://sourceforge.net/tracker/?func=detail&atid=358874&aid=1456391&group_id=8874 */
+	{"Canon:EOS 30D (PTP mode)",            0x04a9, 0x3113, PTP_CAP},
+	{"Canon:Digital IXUS 900Ti (PTP mode)", 0x04a9, 0x3115, 0},
+	{"Canon:PowerShot SD900 (PTP mode)",    0x04a9, 0x3115, 0},
+	{"Canon:Digital IXUS 750 (PTP mode)",   0x04a9, 0x3116, PTPBUG_DELETE_SENDS_EVENT},
+	{"Canon:PowerShot A700 (PTP mode)",     0x04a9, 0x3117, PTPBUG_DELETE_SENDS_EVENT},
+	/* http://sourceforge.net/tracker/index.php?func=detail&aid=1498577&group_id=8874&atid=358874 */
+	{"Canon:PowerShot SD700 (PTP mode)",    0x04a9, 0x3119, PTPBUG_DELETE_SENDS_EVENT},
+	{"Canon:Digital IXUS 800 (PTP mode)",   0x04a9, 0x3119, PTPBUG_DELETE_SENDS_EVENT},
+	/* Gert Vervoort <gert.vervoort@hccnet.nl> */
+	{"Canon:PowerShot S3 IS (PTP mode)",    0x04a9, 0x311a, PTP_CAP|PTP_CAP_PREVIEW},
+	/* David Goodenough <david.goodenough at linkchoose.co.uk> */
+	{"Canon:PowerShot A540 (PTP mode)",     0x04a9, 0x311b, PTPBUG_DELETE_SENDS_EVENT},
+	/* Irc reporter */
+	{"Canon:Digital IXUS 60 (PTP mode)",    0x04a9, 0x311c, PTPBUG_DELETE_SENDS_EVENT},
+	{"Canon:PowerShot SD600 (PTP mode)",    0x04a9, 0x311c, PTPBUG_DELETE_SENDS_EVENT},
+	/* Harald Dunkel <harald.dunkel@t-online.de> */
+	{"Canon:PowerShot G7 (PTP mode)",	0x04a9, 0x3125, PTPBUG_DELETE_SENDS_EVENT|PTP_CAP|PTP_CAP_PREVIEW},
+	/* Ales Kozumplik <kozumplik@gmail.com> */
+	{"Canon:PowerShot A530 (PTP mode)",     0x04a9, 0x3126, PTPBUG_DELETE_SENDS_EVENT},
+	/* Jerome Vizcaino <vizcaino_jerome@yahoo.fr> */
+	{"Canon:Digital IXUS 850 IS (PTP mode)",0x04a9, 0x3136, PTPBUG_DELETE_SENDS_EVENT},
+	/* https://launchpad.net/bugs/64146 */
+	{"Canon:PowerShot SD40 (PTP mode)",	0x04a9, 0x3137, PTPBUG_DELETE_SENDS_EVENT},
+	/* http://sourceforge.net/tracker/index.php?func=detail&aid=1565043&group_id=8874&atid=358874 */
+	{"Canon:PowerShot A710 IS (PTP mode)",  0x04a9, 0x3138, PTPBUG_DELETE_SENDS_EVENT},
+	/* Thomas Roelz at SUSE, MTP proplist does not work (hangs) */
+	{"Canon:PowerShot A640 (PTP mode)",     0x04a9, 0x3139, PTPBUG_DELETE_SENDS_EVENT|PTP_CAP|PTP_CAP_PREVIEW},
+	{"Canon:PowerShot A630 (PTP mode)",     0x04a9, 0x313a, PTPBUG_DELETE_SENDS_EVENT},
+	/* Deti Fliegl.
+	 * Marcus: supports MTP proplists, but these are 2 times slower than regular
+	 * data retrieval. */
+	{"Canon:EOS 450D (PTP mode)",    	0x04a9, 0x3145, PTP_CAP|PTP_CAP_PREVIEW|PTPBUG_DELETE_SENDS_EVENT},
+	{"Canon:EOS Rebel XSi (PTP mode)",    	0x04a9, 0x3145, PTP_CAP|PTP_CAP_PREVIEW|PTPBUG_DELETE_SENDS_EVENT},
+	{"Canon:EOS Kiss X2 (PTP mode)",    	0x04a9, 0x3145, PTP_CAP|PTP_CAP_PREVIEW|PTPBUG_DELETE_SENDS_EVENT},
+	/* reported by Ferry Huberts */
+	{"Canon:EOS 40D (PTP mode)",    	0x04a9, 0x3146, PTP_CAP|PTP_CAP_PREVIEW|PTPBUG_DELETE_SENDS_EVENT},
+
+	/* reported by: gphoto@lunkwill.org */
+	{"Canon:EOS 1D Mark III (PTP mode)",	0x04a9, 0x3147, PTP_CAP},
+
+	{"Canon:PowerShot S5 IS (PTP mode)",    0x04a9, 0x3148, PTP_CAP|PTP_CAP_PREVIEW},
+	/* AlannY <alanny@starlink.ru> */
+	{"Canon:PowerShot A460 (PTP mode)",	0x04a9, 0x3149, PTP_CAP|PTP_CAP_PREVIEW},
+	/* Tobias Blaser <tblaser@gmx.ch> */
+	{"Canon:Digital IXUS 950 IS (PTP mode)",0x04a9, 0x314b, PTPBUG_DELETE_SENDS_EVENT},
+	/* https://bugs.launchpad.net/bugs/206627 */
+	{"Canon:PowerShot SD850 (PTP mode)",	0x04a9, 0x314b, PTPBUG_DELETE_SENDS_EVENT},
+	{"Canon:PowerShot A570 IS (PTP mode)",  0x04a9, 0x314c, PTPBUG_DELETE_SENDS_EVENT},
+	{"Canon:PowerShot A560 (PTP mode)", 	0x04a9, 0x314d, PTPBUG_DELETE_SENDS_EVENT},
+	/* mailreport from sec@dschroeder.info */
+	{"Canon:Digital IXUS 75 (PTP mode)",    0x04a9, 0x314e, PTPBUG_DELETE_SENDS_EVENT},
+	{"Canon:PowerShot SD750 (PTP mode)",    0x04a9, 0x314e, PTPBUG_DELETE_SENDS_EVENT},
+	/* Marcus: MTP Proplist does not work at all here, it just hangs */
+	{"Canon:Digital IXUS 70 (PTP mode)",    0x04a9, 0x314f, PTPBUG_DELETE_SENDS_EVENT},
+	{"Canon:PowerShot SD1000 (PTP mode)",   0x04a9, 0x314f, PTPBUG_DELETE_SENDS_EVENT},
+	{"Canon:PowerShot A550 (PTP mode)",     0x04a9, 0x3150, PTPBUG_DELETE_SENDS_EVENT},
+	/* https://launchpad.net/bugs/64146 */
+	{"Canon:PowerShot A450 (PTP mode)",     0x04a9, 0x3155, PTPBUG_DELETE_SENDS_EVENT},
+	/* Harald Dunkel <harald.dunkel@t-online.de> */
+	{"Canon:PowerShot G9 (PTP mode)",       0x04a9, 0x315a, PTPBUG_DELETE_SENDS_EVENT|PTP_CAP|PTP_CAP_PREVIEW},
+	/* Barrie Stott <zen146410@zen.co.uk> */
+	{"Canon:PowerShot A650IS (PTP mode)",   0x04a9, 0x315b, PTP_CAP|PTP_CAP_PREVIEW},
+	/* Roger Lynn <roger@rilynn.demon.co.uk> */
+	{"Canon:PowerShot A720 IS (PTP mode)",	0x04a9, 0x315d, PTPBUG_DELETE_SENDS_EVENT},
+	/* Mats Petersson <mats.petersson@ltu.se> */
+	{"Canon:Powershot SX100 IS (PTP mode)",	0x04a9, 0x315e, PTPBUG_DELETE_SENDS_EVENT|PTP_CAP|PTP_CAP_PREVIEW},
+	/* "[AvataR]" <public.avatar@gmail.com> */
+	{"Canon:Digital IXUS 960 IS (PTP mode)",0x04a9, 0x315f, PTPBUG_DELETE_SENDS_EVENT},
+	/* Ruben Vandamme <vandamme.ruben@belgacom.net> */
+	{"Canon:Digital IXUS 860 IS",		0x04a9, 0x3160, PTPBUG_DELETE_SENDS_EVENT},
+
+	/* Christian P. Schmidt" <schmidt@digadd.de> */
+	{"Canon:Digital IXUS 970 IS",		0x04a9, 0x3173, PTPBUG_DELETE_SENDS_EVENT},
+
+	/* Martin Lasarsch at SUSE. MTP_PROPLIST returns just 0 entries */
+	{"Canon:Digital IXUS 90 IS",		0x04a9, 0x3174, PTPBUG_DELETE_SENDS_EVENT},
+	/* Daniel Moyne <daniel.moyne@free.fr> */
+	{"Canon:Powershot SD790 IS",		0x04a9, 0x3174, PTPBUG_DELETE_SENDS_EVENT},
+
+	/* https://sourceforge.net/tracker/?func=detail&aid=2722422&group_id=8874&atid=358874 */
+	{"Canon:Digital IXUS 85 IS",		0x04a9, 0x3174, PTPBUG_DELETE_SENDS_EVENT},
+
+	/* Theodore Kilgore <kilgota@banach.math.auburn.edu> */
+	{"Canon:PowerShot SD770 IS",		0x04a9, 0x3175, PTPBUG_DELETE_SENDS_EVENT},
+
+	/* Olaf Hering at SUSE */
+	{"Canon:PowerShot A590 IS",		0x04a9, 0x3176, PTPBUG_DELETE_SENDS_EVENT},
+	
+	/* Dmitriy Khanzhin <jinn@altlinux.org> */
+	{"Canon:PowerShot A580",		0x04a9, 0x3177, PTPBUG_DELETE_SENDS_EVENT},
+
+	/* https://sourceforge.net/tracker/index.php?func=detail&aid=2602638&group_id=8874&atid=108874 */
+	{"Canon:PowerShot A470",		0x04a9, 0x317a, PTPBUG_DELETE_SENDS_EVENT},
+	/* Michael Plucik <michaelplucik@googlemail.com> */
+	{"Canon:EOS 1000D",			0x04a9, 0x317b, PTP_CAP|PTP_CAP_PREVIEW|PTPBUG_DELETE_SENDS_EVENT},
+
+	/* https://sourceforge.net/tracker/?func=detail&atid=358874&aid=1910010&group_id=8874 */
+	{"Canon:Digital IXUS 80 IS",		0x04a9, 0x3184, PTPBUG_DELETE_SENDS_EVENT},
+	/* https://sourceforge.net/tracker/index.php?func=detail&aid=2391422&group_id=8874&atid=358874 */
+	{"Canon:Powershot SD1100 IS",		0x04a9, 0x3184, PTPBUG_DELETE_SENDS_EVENT},
+	/* Hubert Mercier <hubert.mercier@unilim.fr> */
+	{"Canon:PowerShot SX10 IS",		0x04a9, 0x318d, PTPBUG_DELETE_SENDS_EVENT},
+
+	/* Novell Bugzilla 852551, Dean Martin <deano_ferrari@hotmail.com> */
+	{"Canon:PowerShot A1000 IS",		0x04a9, 0x318e, PTPBUG_DELETE_SENDS_EVENT},
+
+	/* Paul Tinsley */
+	{"Canon:PowerShot G10",			0x04a9, 0x318f, PTPBUG_DELETE_SENDS_EVENT|PTP_CAP|PTP_CAP_PREVIEW},
+
+	/* Nikolay Rysev <nrysev@gmail.com> */
+	{"Canon:PowerShot A2000 IS",		0x04a9, 0x3191, PTPBUG_DELETE_SENDS_EVENT},
+	/* Chris Rodley <chris@takeabreak.co.nz> */
+	{"Canon:PowerShot SX110 IS",		0x04a9, 0x3192, PTPBUG_DELETE_SENDS_EVENT|PTP_CAP|PTP_CAP_PREVIEW},
+
+	/* Kurt Garloff at SUSE */
+	{"Canon:Digital IXUS 980 IS",		0x04a9, 0x3193, PTPBUG_DELETE_SENDS_EVENT},
+	{"Canon:PowerShot SD990",		0x04a9, 0x3193, PTPBUG_DELETE_SENDS_EVENT},
+	{"Canon:IXY 3000 IS",			0x04a9, 0x3193, PTPBUG_DELETE_SENDS_EVENT},
+
+	/* https://sourceforge.net/tracker/index.php?func=detail&aid=2750875&group_id=8874&atid=358874 */
+	{"Canon:PowerShot SD880 IS",		0x04a9, 0x3196, PTPBUG_DELETE_SENDS_EVENT},
+
+	/* IRC Reporter */
+	{"Canon:EOS 5D Mark II",		0x04a9, 0x3199, PTP_CAP|PTP_CAP_PREVIEW|PTPBUG_DELETE_SENDS_EVENT},
+	/* Thomas Tanner <thomas@tannerlab.com> */
+	{"Canon:EOS 7D",			0x04a9, 0x319a, PTP_CAP|PTP_CAP_PREVIEW|PTPBUG_DELETE_SENDS_EVENT},
+	/* mitch <debianuser@mll.dissimulo.com> */
+	{"Canon:EOS 50D",			0x04a9, 0x319b, PTP_CAP|PTP_CAP_PREVIEW|PTPBUG_DELETE_SENDS_EVENT},
+
+	/* https://bugs.launchpad.net/ubuntu/+source/libgphoto2/+bug/569419 */
+	/* "T. Ludewig" <t.ludewig@gmail.com> */
+	{"Canon:PowerShot D10",			0x04a9, 0x31bc, PTPBUG_DELETE_SENDS_EVENT},
+
+	/* Carsten Grohmann <carstengrohmann@gmx.de> */
+	{"Canon:Digital IXUS 110 IS",		0x04a9, 0x31bd, PTPBUG_DELETE_SENDS_EVENT},
+
+	/* Willy Tarreau <w@1wt.eu> */
+	{"Canon:PowerShot A2100 IS",		0x04a9, 0x31be, PTPBUG_DELETE_SENDS_EVENT},
+
+	{"Canon:PowerShot A480",		0x04a9, 0x31bf, PTPBUG_DELETE_SENDS_EVENT},
+
+	/* IRC Reporter */
+	{"Canon:PowerShot SX200 IS",		0x04a9, 0x31c0, 0},
+	/* https://sourceforge.net/tracker/index.php?func=detail&aid=2789326&group_id=8874&atid=358874 */
+	{"Canon:Digital IXUS 990 IS",		0x04a9, 0x31c1, PTPBUG_DELETE_SENDS_EVENT},
+	/* Michael Ole Olsen <gnu@gmx.net> */
+	{"Canon:PowerShot SD970 IS",		0x04a9, 0x31c1, PTPBUG_DELETE_SENDS_EVENT},
+	/* https://sourceforge.net/tracker/?func=detail&aid=2769511&group_id=8874&atid=208874 */
+	/* Do not confuse with PowerShot SX100IS */
+	{"Canon:Digital IXUS 100 IS",           0x04a9, 0x31c2, PTPBUG_DELETE_SENDS_EVENT},
+	/* https://sourceforge.net/tracker/?func=detail&aid=2769511&group_id=8874&atid=208874 */
+	{"Canon:PowerShot SD780 IS",		0x04a9, 0x31c2, PTPBUG_DELETE_SENDS_EVENT},
+	/* Matthew Vernon <matthew@sel.cam.ac.uk> */
+	{"Canon:PowerShot A1100 IS",		0x04a9, 0x31c3, PTPBUG_DELETE_SENDS_EVENT},
+	/* Joshua Hoke <jdh@people.homeip.net> */
+	{"Canon:Powershot SD1200 IS",		0x04a9, 0x31c4, PTPBUG_DELETE_SENDS_EVENT},
+	/* RalfGesellensetter <rgx@gmx.de> */
+	{"Canon:Digital IXUS 95 IS",		0x04a9, 0x31c4, PTPBUG_DELETE_SENDS_EVENT},
+	/* https://sourceforge.net/tracker/index.php?func=detail&aid=2796275&group_id=8874&atid=358874 */
+	{"Canon:EOS 500D",			0x04a9, 0x31cf, PTP_CAP|PTP_CAP_PREVIEW},
+	{"Canon:EOS Rebel T1i",			0x04a9, 0x31cf, PTP_CAP|PTP_CAP_PREVIEW},
+	{"Canon:EOS Kiss X3",			0x04a9, 0x31cf, PTP_CAP|PTP_CAP_PREVIEW},
+
+	/* Peter Lawrence <peter@pjlcentral.com> */
+	{"Canon:EOS 1D Mark IV",		0x04a9, 0x31d0, PTP_CAP|PTP_CAP_PREVIEW},
+
+	/* From: Franck GIRARDIN - OPTOCONCEPT <fgirardin@optoconcept.com> */
+	{"Canon:PowerShot G11",			0x04a9, 0x31df, 0},
+
+	/* The Wanderer <wanderer@fastmail.fm> */
+	{"Canon:PowerShot SX120 IS",		0x04a9, 0x31e0, PTPBUG_DELETE_SENDS_EVENT},
+	/* via libmtp */
+	{"Canon:PowerShot SX20 IS",		0x04a9, 0x31e4, PTPBUG_DELETE_SENDS_EVENT},
+	/* http://sourceforge.net/tracker/index.php?func=detail&aid=2918540&group_id=8874&atid=358874 */
+	{"Canon:IXY 220 IS",			0x04a9, 0x31e6, PTPBUG_DELETE_SENDS_EVENT},
+	{"Canon:Digital IXUS 120 IS",		0x04a9, 0x31e6, PTPBUG_DELETE_SENDS_EVENT},
+	{"Canon:PowerShot SD940 IS",		0x04a9, 0x31e6, PTPBUG_DELETE_SENDS_EVENT},
+	/* IRC reporter */
+	{"Canon:EOS 550D",			0x04a9, 0x31ea, PTP_CAP|PTP_CAP_PREVIEW},
+	/* Mauricio Pasquier Juan <mauricio@pasquierjuan.com.ar> */
+	{"Canon:Rebel T2i",			0x04a9, 0x31ea, PTP_CAP|PTP_CAP_PREVIEW},
+
+	/* Andrés Farfán <nafraf@linuxmail.org> */
+	{"Canon:Powershot A495",		0x04a9, 0x31ef, PTPBUG_DELETE_SENDS_EVENT},
+
+	/* ErVito on IRC */
+	{"Canon:PowerShot A3100 IS",		0x04a9, 0x31f1, PTPBUG_DELETE_SENDS_EVENT},
+
+	{"Canon:PowerShot A3000 IS",		0x04a9, 0x31f2, PTPBUG_DELETE_SENDS_EVENT},
+	{"Canon:Digital IXUS 130",		0x04a9, 0x31f3, PTPBUG_DELETE_SENDS_EVENT},
+	/* Mark Voorhies <mvoorhie@yahoo.com> */
+	{"Canon:PowerShot SD1300 IS",		0x04a9, 0x31f4, PTPBUG_DELETE_SENDS_EVENT},
+	/* Juergen Weigert */
+	{"Canon:PowerShot SX210 IS",		0x04a9, 0x31f6, PTPBUG_DELETE_SENDS_EVENT},
+	/* name correct? https://bugs.launchpad.net/ubuntu/+source/gvfs/+bug/1296275?comments=all */
+	{"Canon:Digital IXUS 300 HS",		0x04a9, 0x31f7, PTPBUG_DELETE_SENDS_EVENT},
+	/* http://sourceforge.net/tracker/index.php?func=detail&aid=3153412&group_id=8874&atid=358874 */
+	{"Canon:PowerShot SX130 IS",		0x04a9, 0x3211, PTPBUG_DELETE_SENDS_EVENT},
+	/* novell bugzilla 871944 */
+	{"Canon:PowerShot S95",			0x04a9, 0x3212, PTPBUG_DELETE_SENDS_EVENT},
+	/* IRC Reporter */
+	{"Canon:EOS 60D",			0x04a9, 0x3215, PTP_CAP|PTP_CAP_PREVIEW},
+	/* https://sourceforge.net/tracker/?func=detail&atid=358874&aid=3312353&group_id=8874 */
+	{"Canon:EOS 1100D",			0x04a9, 0x3217, PTP_CAP|PTP_CAP_PREVIEW},
+	{"Canon:Rebel T3",			0x04a9, 0x3217, PTP_CAP|PTP_CAP_PREVIEW},
+	/* https://sourceforge.net/tracker/?func=detail&atid=358874&aid=3310995&group_id=8874 */
+	{"Canon:EOS 600D",			0x04a9, 0x3218, PTP_CAP|PTP_CAP_PREVIEW},
+
+	/* Brian L Murphy <brian.l.murphy@gmail.com> */
+	{"Canon:EOS 1D X",			0x04a9, 0x3219, PTP_CAP|PTP_CAP_PREVIEW},
+
+	/* "T. Ludewig" <t.ludewig@gmail.com> */
+	{"Canon:IXUS 310IS",			0x04a9, 0x3225, PTPBUG_DELETE_SENDS_EVENT},
+
+	/* analemma88@gmail.com */
+	{"Canon:PowerShot A800",		0x04a9, 0x3226, PTPBUG_DELETE_SENDS_EVENT},
+
+	/* Juha Pesonen <juha.e.pesonen@gmail.com> */
+	{"Canon:PowerShot SX230HS",		0x04a9, 0x3228, PTPBUG_DELETE_SENDS_EVENT},
+
+	/* Andrés Farfán <nafraf@linuxmail.org> */
+	{"Canon:PowerShot A2200",		0x04a9, 0x322a, PTPBUG_DELETE_SENDS_EVENT},
+
+	/* http://sourceforge.net/tracker/?func=detail&atid=358874&aid=3572477&group_id=8874 */
+	{"Canon:PowerShot SX220HS",		0x04a9, 0x322c, PTPBUG_DELETE_SENDS_EVENT},
+
+	/* "T. Ludewig" <t.ludewig@gmail.com> */
+	{"Canon:PowerShot G1 X",		0x04a9, 0x3233, PTPBUG_DELETE_SENDS_EVENT},
+	/* Dean Martin <deano_ferrari@hotmail.com>, Novell Bugzilla 852551 */
+	{"Canon:PowerShot SX150 IS",		0x04a9, 0x3234, PTPBUG_DELETE_SENDS_EVENT},
+
+	/* IRC reporter */
+	{"Canon:PowerShot S100",		0x04a9, 0x3236, PTPBUG_DELETE_SENDS_EVENT},
+	/* "T. Ludewig" <t.ludewig@gmail.com> */
+	{"Canon:PowerShot SX40HS",		0x04a9, 0x3238, PTPBUG_DELETE_SENDS_EVENT},
+	/* Axel Waggershauser <awagger@web.de> */
+	{"Canon:EOS 5D Mark III",		0x04a9, 0x323a, PTP_CAP|PTP_CAP_PREVIEW|PTPBUG_DELETE_SENDS_EVENT},
+	/* "T. Ludewig" <t.ludewig@gmail.com> */
+	{"Canon:EOS 650D",			0x04a9, 0x323b, PTP_CAP|PTP_CAP_PREVIEW},
+	/* "T. Ludewig" <t.ludewig@gmail.com> */
+	{"Canon:Rebel T4i",			0x04a9, 0x323b, PTP_CAP|PTP_CAP_PREVIEW},
+
+	/* "T. Ludewig" <t.ludewig@gmail.com> */
+	{"Canon:EOS M",				0x04a9, 0x323d, 0/*PTP_CAP|PTP_CAP_PREVIEW ... might be unknown opcodes -Marcus */},
+	/* via https://bugs.kde.org/show_bug.cgi?id=311393 */
+	{"Canon:PowerShot A1300IS",		0x04a9, 0x323e, PTPBUG_DELETE_SENDS_EVENT},
+	/* https://forums.opensuse.org/showthread.php/493692-canon-usb-camera-a810-not-detected */
+	{"Canon:PowerShot A810",		0x04a9, 0x323f, PTPBUG_DELETE_SENDS_EVENT},
+
+	/* Giulio Fidente <gfidente@gmail.com> */
+	{"Canon:IXUS 125HS",			0x04a9, 0x3241, PTPBUG_DELETE_SENDS_EVENT},
+	/* "T. Ludewig" <t.ludewig@gmail.com> */
+	{"Canon:PowerShot A4000IS",		0x04a9, 0x3243, PTPBUG_DELETE_SENDS_EVENT},
+	/* Peter Ivanyi <ipeter88@gmail.com> */
+	{"Canon:PowerShot SX260HS",		0x04a9, 0x3244, PTPBUG_DELETE_SENDS_EVENT},
+	/* "T. Ludewig" <t.ludewig@gmail.com> */
+	{"Canon:PowerShot SX240HS",		0x04a9, 0x3245, PTPBUG_DELETE_SENDS_EVENT},
+	/* "T. Ludewig" <t.ludewig@gmail.com> */
+	{"Canon:PowerShot A2400IS",		0x04a9, 0x3249, PTPBUG_DELETE_SENDS_EVENT},
+	/* Coro Fe <corofecoro@gmail.com> */
+	{"Canon:PowerShot A2300IS",		0x04a9, 0x324a, PTPBUG_DELETE_SENDS_EVENT},
+
+	/* "François G." <francois@webcampak.com> */
+	{"Canon:EOS 6D",			0x04a9, 0x3250, PTP_CAP|PTP_CAP_PREVIEW},
+	/* Thorsten Ludewig <t.ludewig@gmail.com> */
+	{"Canon:EOS 70D",			0x04a9, 0x3253, PTP_CAP|PTP_CAP_PREVIEW},
+
+	/* Thorsten Ludewig <t.ludewig@gmail.com> */
+	{"Canon:PowerShot G15",			0x04a9, 0x3258, PTPBUG_DELETE_SENDS_EVENT},
+
+	/* Andrés Farfán <nafraf@linuxmail.org> */
+	{"Canon:PowerShot SX160IS",		0x04a9, 0x325a, PTPBUG_DELETE_SENDS_EVENT},
+
+	/* "T. Ludewig" <t.ludewig@gmail.com> */
+	{"Canon:PowerShot S110 (PTP Mode)",	0x04a9, 0x325b, PTPBUG_DELETE_SENDS_EVENT},
+	/* "T. Ludewig" <t.ludewig@gmail.com> */
+	{"Canon:PowerShot SX500IS",		0x04a9, 0x325c, PTPBUG_DELETE_SENDS_EVENT},
+
+	/* Andrés Farfán <nafraf@linuxmail.org> */
+	{"Canon:PowerShot SX280HS",		0x04a9, 0x325f, PTPBUG_DELETE_SENDS_EVENT},
+
+	/* Marcus Meissner */
+	{"Canon:PowerShot A3500IS",		0x04a9, 0x3261, PTPBUG_DELETE_SENDS_EVENT},
+
+	/* Canon Powershot A2600 */
+	{"Canon:PowerShot A2600",		0x04a9, 0x3262, PTPBUG_DELETE_SENDS_EVENT},
+
+	/* Andrés Farfán <nafraf@linuxmail.org> */
+	{"Canon:PowerShot A1400",		0x04a9, 0x3264, PTPBUG_DELETE_SENDS_EVENT},
+	/* https://bugs.launchpad.net/ubuntu/+source/gvfs/+bug/1296275?comments=all  */
+	{"Canon:Digital IXUS 255HS",		0x04a9, 0x3268, PTPBUG_DELETE_SENDS_EVENT},
+
+	/* t.ludewig@gmail.com */
+	{"Canon:EOS 7D MarkII",			0x04a9, 0x326f, PTP_CAP|PTP_CAP_PREVIEW},
+
+	/* "T. Ludewig" <t.ludewig@gmail.com> */
+	{"Canon:EOS 100D",			0x04a9, 0x3270, PTP_CAP|PTP_CAP_PREVIEW},
+
+	/* Ronny Kalusniok <ladiko@gmail.com> */
+	{"Canon:PowerShot A2500",		0x04a9, 0x3271, PTPBUG_DELETE_SENDS_EVENT},
+
+	/* "T. Ludewig" <t.ludewig@gmail.com> */
+	{"Canon:EOS 700D",			0x04a9, 0x3272, PTP_CAP|PTP_CAP_PREVIEW},
+
+	/* From: Gerwin Voorsluijs <g.m.voorsluijs@online.nl> */
+	{"Canon:PowerShot S120",		0x04a9, 0x3275, PTPBUG_DELETE_SENDS_EVENT},
+
+	/* Andrés Farfán <nafraf@linuxmail.org> */
+	{"Canon:PowerShot SX170 IS",		0x04a9, 0x3276, PTPBUG_DELETE_SENDS_EVENT},
+
+	/* Andrés Farfán <nafraf@linuxmail.org> */
+	{"Canon:PowerShot SX510 HS",		0x04a9, 0x3277, PTPBUG_DELETE_SENDS_EVENT},
+
+	/* thinkgareth <thinkgareth@users.sf.net> */
+	{"Canon:EOS 1200D",			0x04a9, 0x327f, PTP_CAP|PTP_CAP_PREVIEW},
+
+	/* https://sourceforge.net/p/gphoto/feature-requests/445/ */
+	{"Canon:PowerShot Elph135",		0x04a9, 0x3288, PTPBUG_DELETE_SENDS_EVENT},
+
+	/* Reed Johnson <rmjohns1@gmail.com> */
+	{"Canon:PowerShot Elph340HS",		0x04a9, 0x3289, PTPBUG_DELETE_SENDS_EVENT},
+
+	/* Nykhedimus S <nykhedimus@gmail.com> */
+	{"Canon:EOS M3",			0x04a9, 0x3299, PTPBUG_DELETE_SENDS_EVENT},
+	/* pravsripad@gmail.com */
+	{"Canon:PowerShot SX520 HS",		0x04a9, 0x329b, PTPBUG_DELETE_SENDS_EVENT},
+
+	/* Kiss Tamas <kisst@bgk.bme.hu> */
+	{"Canon:IXUS 165",			0x04a9, 0x32a9, PTPBUG_DELETE_SENDS_EVENT},
+
+	/* Konica-Minolta PTP cameras */
+	{"Konica-Minolta:DiMAGE A2 (PTP mode)",        0x132b, 0x0001, 0},
+	{"Konica-Minolta:DiMAGE Z2 (PictBridge mode)", 0x132b, 0x0007, 0},
+	{"Konica-Minolta:DiMAGE X21 (PictBridge mode)",0x132b, 0x0009, 0},
+	{"Konica-Minolta:DiMAGE Z3 (PictBridge mode)", 0x132b, 0x0018, 0},
+	{"Konica-Minolta:DiMAGE A200 (PictBridge mode)",0x132b, 0x0019, 0},
+	{"Konica-Minolta:DiMAGE Z5 (PictBridge mode)", 0x132b, 0x0022, 0},
+
+	/* Fuji PTP cameras */
+	{"Fuji:FinePix S7000",			0x04cb, 0x0142, 0},
+	{"Fuji:FinePix A330",			0x04cb, 0x014a, 0},
+	/* Hans-Joachim Baader <hjb@pro-linux.de> */
+	{"Fuji:FinePix S9500",			0x04cb, 0x018f, 0},
+	{"Fuji:FinePix E900",			0x04cb, 0x0193, 0},
+	{"Fuji:FinePix F30",			0x04cb, 0x019b, 0},
+	/* https://sourceforge.net/tracker/?func=detail&atid=358874&aid=1620750&group_id=8874 */
+	{"Fuji:FinePix S6500fd",		0x04cb, 0x01bf, 0},
+	/* https://launchpad.net/bugs/89743 */
+	{"Fuji:FinePix F20",			0x04cb, 0x01c0, 0},
+	/* launchpad 67532 */
+	{"Fuji:FinePix F31fd",			0x04cb, 0x01c1, 0},
+	/* http://sourceforge.net/tracker/?func=detail&atid=358874&aid=2881948&group_id=8874 */
+	{"Fuji:S5 Pro",			        0x04cb, 0x01c3, PTP_CAP},
+	{"Fuji:FinePix S5700",			0x04cb, 0x01c4, 0},
+	{"Fuji:FinePix F40fd",			0x04cb, 0x01c5, 0},
+	/* http://sourceforge.net/tracker/index.php?func=detail&aid=1800289&group_id=8874&atid=358874 */
+	{"Fuji:FinePix A820",			0x04cb, 0x01c6, 0},
+	/* g4@catking.net */
+	{"Fuji:FinePix A800",			0x04cb, 0x01d2, 0},
+	/* Gerhard Schmidt <gerd@dg4fac.de> */
+	{"Fuji:FinePix A920",			0x04cb, 0x01d3, 0},
+	/* Teppo Jalava <tjjalava@gmail.com> */
+	{"Fuji:FinePix F50fd",			0x04cb, 0x01d4, 0},
+	/* IRC reporter */
+	{"Fuji:FinePix S5800",			0x04cb, 0x01d7, 0},
+	/* https://sourceforge.net/tracker/?func=detail&atid=108874&aid=1945259&group_id=8874 */
+	{"Fuji:FinePix Z100fd",			0x04cb, 0x01d8, 0},
+	/* http://sourceforge.net/tracker/index.php?func=detail&aid=2017171&group_id=8874&atid=358874 */
+	{"Fuji:FinePix S100fs",			0x04cb, 0x01db, 0},
+	/* https://sourceforge.net/tracker/index.php?func=detail&aid=2772199&group_id=8874&atid=358874 */
+	{"Fuji:FinePix S1000fd",		0x04cb, 0x01dd, 0},
+	/* https://sourceforge.net/tracker/index.php?func=detail&aid=2203316&group_id=8874&atid=358874 */
+	{"Fuji:FinePix F100fd",			0x04cb, 0x01e0, 0},
+	/*https://sourceforge.net/tracker/index.php?func=detail&aid=2820380&group_id=8874&atid=358874 */
+	{"Fuji:FinePix F200 EXR",		0x04cb, 0x01e4, 0},
+	/* https://sourceforge.net/tracker/index.php?func=detail&aid=2993118&group_id=8874&atid=358874  */
+	{"Fuji:FinePix F60fd",			0x04cb, 0x01e6, 0},
+	/* Gerhard Schmidt <gerd@dg4fac.de> */
+	{"Fuji:FinePix S2000HD",		0x04cb, 0x01e8, 0},
+	{"Fuji:FinePix S1500",			0x04cb, 0x01ef, 0},
+	/* http://sourceforge.net/tracker/index.php?func=detail&aid=3018889&group_id=8874&atid=358874 */
+	{"Fuji:FinePix F70 EXR",		0x04cb, 0x01fa, 0},
+	/* http://sourceforge.net/tracker/index.php?func=detail&aid=3111790&group_id=8874&atid=358874 */
+	{"Fuji:Fujifilm A220",			0x04cb, 0x01fe, 0},
+	/* NoOp <glgxg@sbcglobal.net> */
+	{"Fuji:FinePix S1800",			0x04cb, 0x0200, 0},
+	/* Luke Symes <allsymes@gmail.com> */
+	{"Fuji:FinePix Z35",			0x04cb, 0x0201, 0},
+	/* "Steven A. McIntosh" <mcintosh@cotterochan.co.uk> */
+	{"Fuji:FinePix S2500HD",		0x04cb, 0x0209, 0},
+	/* Erik Hahn <erik_hahn@gmx.de> */
+	{"Fuji:FinePix F80EXR",			0x04cb, 0x020e, 0},
+	/* salsaman <salsaman@gmail.com> */
+	{"Fuji:FinePix Z700EXR",		0x04cb, 0x020d, 0},
+	/* https://bugs.launchpad.net/ubuntu/+source/gvfs/+bug/1311953 */
+	{"Fuji:FinePix AV-150",			0x04cb, 0x021b, 0},
+	/* Gregor Voss <gregor.voss@gmx.de> */
+	{"Fuji:FinePix H20EXR",			0x04cb, 0x022d, 0},
+	/* https://bugs.launchpad.net/ubuntu/+source/gvfs/+bug/1296275?comments=all  */
+	{"Fuji:FinePix T200",			0x04cb, 0x0233, 0},
+	/* https://sourceforge.net/tracker/index.php?func=detail&aid=3556692&group_id=8874&atid=108874 */
+	{"Fuji:FinePix S2950",			0x04cb, 0x0240, 0},
+	/* https://sourceforge.net/p/gphoto/bugs/974/ */
+	{"Fuji:FinePix JX370",			0x04cb, 0x0250, 0},
+	/* Luis Arias <kaaloo@gmail.com> */
+	{"Fuji:FinePix X10",			0x04cb, 0x0263, 0},
+	/* t.ludewig@gmail.com */
+	{"Fuji:FinePix S4300",			0x04cb, 0x0265, 0},
+	/* t.ludewig@gmail.com */
+	{"Fuji:FinePix X-S1",			0x04cb, 0x026e, 0},
+	/* t.ludewig@gmail.com */
+	{"Fuji:FinePix HS30EXR",		0x04cb, 0x0271, 0},
+	/* Marcel Bonnet <marcelbonnet@gmail.com> */
+	{"Fuji:FinePix S2980",			0x04cb, 0x027d, 0},
+	/* t.ludewig@gmail.com */
+	{"Fuji:FinePix XF1",			0x04cb, 0x0288, 0},
+	/* Steve Dahl <dahl@goshawk.com> */
+	{"Fuji:FinePix S4850",			0x04cb, 0x0298, 0},
+	/* Larry D. DeMaris" <demarisld@gmail.com> */
+	{"Fuji:FinePix SL1000",			0x04cb, 0x029c, 0},
+	/* t.ludewig@gmail.com */
+	{"Fuji:FinePix X20",			0x04cb, 0x02a6, 0},
+	/* https://sourceforge.net/p/libmtp/bugs/1040/ */
+	{"Fuji:Fujifilm X-E2",			0x04cb, 0x02b5, 0},
+
+	{"Ricoh:Caplio R5 (PTP mode)",          0x05ca, 0x0110, 0},
+	{"Ricoh:Caplio GX (PTP mode)",          0x05ca, 0x0325, 0},
+	{"Sea & Sea:5000G (PTP mode)",		0x05ca, 0x0327, 0},
+	/* Michael Steinhauser <mistr@online.de> */
+	{"Ricoh Caplio:R1v (PTP mode)",		0x05ca, 0x032b, 0},
+	{"Ricoh:Caplio R3 (PTP mode)",          0x05ca, 0x032f, 0},
+	/* Arthur Butler <arthurbutler@otters.ndo.co.uk> */
+	{"Ricoh:Caplio RR750 (PTP mode)",	0x05ca, 0x033d, 0},
+	/* Gerald Pfeifer at SUSE */
+	{"Sea & Sea:2G (PTP mode)",		0x05ca, 0x0353, 0},
+
+	/* Rollei dr5  */
+	{"Rollei:dr5 (PTP mode)",               0x05ca, 0x220f, 0},
+
+	/* Ricoh Caplio GX 8 */
+	{"Ricoh:Caplio GX 8 (PTP mode)",        0x05ca, 0x032d, 0},
+
+	/* Pentax cameras */
+	{"Pentax:Optio 43WR",                   0x0a17, 0x000d, 0},
+	/* Stephan Barth at SUSE */
+	{"Pentax:Optio W90",                    0x0a17, 0x00f7, 0},
+
+	/* gphoto:feature-requests 452. yes, weird vendor. */
+	{"Pentax:K3 (PTP Mode)",		0x25fb, 0x0165, 0},
+
+	{"Sanyo:VPC-C5 (PTP mode)",             0x0474, 0x0230, 0},
+
+	/* from Mike Meyer <mwm@mired.org>. Does not support MTP. */
+	{"Apple:iPhone (PTP mode)",		0x05ac, 0x1290, 0},
+	/* IRC reporter adjusted info */
+	{"Apple:iPod Touch (PTP mode)",		0x05ac, 0x1291, 0},
+	/* irc reporter. MTP based. */
+	{"Apple:iPhone 3G (PTP mode)",		0x05ac, 0x1292, 0},
+	/* Marco Michna at SUSE */
+	{"Apple:iPod Touch 2G (PTP mode)",	0x05ac, 0x1293, 0},
+	/* Mark Lehrer <mark@knm.org> */
+	{"Apple:iPhone 3GS (PTP mode)",		0x05ac, 0x1294, 0},
+
+	/* Rasmus P */
+	{"Apple:iPhone 4 (PTP mode)",		0x05ac, 0x1297, 0},
+
+	{"Apple:iPod Touch 3rd Gen (PTP mode)",	0x05ac, 0x1299, 0},
+	{"Apple:iPad (PTP mode)",		0x05ac, 0x129a, 0},
+
+	/* Don Cohen <don-sourceforge-xxzw@isis.cs3-inc.com> */
+	{"Apple:iPhone 4S (PTP mode)",		0x05ac, 0x12a0, 0},
+
+	/* grinchdee@gmail.com */
+	{"Apple:iPhone 5 (PTP mode)",		0x05ac, 0x12a8, 0},
+
+	/* chase.thunderstrike@gmail.com */
+	{"Apple:iPad Air",			0x05ac, 0x12ab, 0},
+
+	/* https://sourceforge.net/tracker/index.php?func=detail&aid=1869653&group_id=158745&atid=809061 */
+	{"Pioneer:DVR-LX60D",			0x08e4, 0x0142, 0},
+
+	/* https://sourceforge.net/tracker/index.php?func=detail&aid=1680029&group_id=8874&atid=108874 */
+	{"Nokia:N73",				0x0421, 0x0488, 0},
+
+	/* gbakos@astro.princeton.edu */
+	{"Samsung:NX1",				0x04e8,	0x140c, 0},
+	/* IRC reporter */
+	{"Samsung:S5620",			0x04e8,	0x684a, 0},
+
+	/* Israel Barrientos <jbarrien@gmail.com> */
+	{"Samsung:NX1000",			0x04e8,	0x1384, 0},
+
+	/* This is a camera ... reported by TAN JIAN QI <JQTAN1@e.ntu.edu.sg */
+	{"Samsung:EK-GC100",			0x04e8,	0x6866, 0},
+
+	/* Bernhard Wagner <me@bernhardwagner.net> */
+	{"Leica:M9",				0x1a98,	0x0002, PTP_CAP},
+
+	/* Tomas Zigo <tomas.zigo@slovanet.sk> */
+	{"GoPro:HERO3+",			0x2672,	0x0011, 0},
+};
+
+#include "device-flags.h"
+static struct {
+	const char *vendor;
+	unsigned short usb_vendor;
+	const char *model;
+	unsigned short usb_product;
+	unsigned long flags;
+} mtp_models[] = {
+#include "music-players.h"
+};
+
+static struct {
+	uint16_t	format_code;
+	uint16_t	vendor_code;
+	const char *txt;
+} object_formats[] = {
+	{PTP_OFC_Undefined,		0, "application/x-unknown"},
+	{PTP_OFC_Association,		0, "application/x-association"},
+	{PTP_OFC_Script,		0, "application/x-script"},
+	{PTP_OFC_Executable,		0, "application/octet-stream"},
+	{PTP_OFC_Text,			0, GP_MIME_TXT},
+	{PTP_OFC_HTML,			0, "text/html"},
+	{PTP_OFC_DPOF,			0, "text/plain"},
+	{PTP_OFC_AIFF,			0, "audio/x-aiff"},
+	{PTP_OFC_WAV,			0, GP_MIME_WAV},
+	{PTP_OFC_MP3,			0, "audio/mpeg"},
+	{PTP_OFC_AVI,			0, GP_MIME_AVI},
+	{PTP_OFC_MPEG,			0, "video/mpeg"},
+	{PTP_OFC_ASF,			0, "video/x-ms-asf"},
+	{PTP_OFC_QT,			0, "video/quicktime"},
+	{PTP_OFC_EXIF_JPEG,		0, GP_MIME_JPEG},
+	{PTP_OFC_TIFF_EP,		0, "image/x-tiffep"},
+	{PTP_OFC_FlashPix,		0, "image/x-flashpix"},
+	{PTP_OFC_BMP,			0, GP_MIME_BMP},
+	{PTP_OFC_CIFF,			0, "image/x-ciff"},
+	{PTP_OFC_Undefined_0x3806,	0, "application/x-unknown"},
+	{PTP_OFC_GIF,			0, "image/gif"},
+	{PTP_OFC_JFIF,			0, GP_MIME_JPEG},
+	{PTP_OFC_PCD,			0, "image/x-pcd"},
+	{PTP_OFC_PICT,			0, "image/x-pict"},
+	{PTP_OFC_PNG,			0, GP_MIME_PNG},
+	{PTP_OFC_Undefined_0x380C,	0, "application/x-unknown"},
+	{PTP_OFC_TIFF,			0, GP_MIME_TIFF},
+	{PTP_OFC_TIFF_IT,		0, "image/x-tiffit"},
+	{PTP_OFC_JP2,			0, "image/x-jpeg2000bff"},
+	{PTP_OFC_JPX,			0, "image/x-jpeg2000eff"},
+	{PTP_OFC_DNG,			0, "image/x-adobe-dng"},
+
+	{PTP_OFC_MTP_OGG,		PTP_VENDOR_MICROSOFT, "application/ogg"},
+	{PTP_OFC_MTP_FLAC,		PTP_VENDOR_MICROSOFT, "audio/x-flac"},
+	{PTP_OFC_MTP_MP2,		PTP_VENDOR_MICROSOFT, "video/mpeg"},
+	{PTP_OFC_MTP_M4A,		PTP_VENDOR_MICROSOFT, "audio/x-m4a"},
+	{PTP_OFC_MTP_MP4,		PTP_VENDOR_MICROSOFT, "video/mp4"},
+	{PTP_OFC_MTP_3GP,		PTP_VENDOR_MICROSOFT, "audio/3gpp"},
+	{PTP_OFC_MTP_WMV,		PTP_VENDOR_MICROSOFT, "video/x-wmv"},
+	{PTP_OFC_MTP_WMA,		PTP_VENDOR_MICROSOFT, "audio/x-wma"},
+	{PTP_OFC_MTP_WMV,		PTP_VENDOR_MICROSOFT, "video/x-ms-wmv"},
+	{PTP_OFC_MTP_WMA,		PTP_VENDOR_MICROSOFT, "audio/x-ms-wma"},
+	{PTP_OFC_MTP_AAC,		PTP_VENDOR_MICROSOFT, "audio/MP4A-LATM"},
+	{PTP_OFC_MTP_XMLDocument,	PTP_VENDOR_MICROSOFT, "text/xml"},
+	{PTP_OFC_MTP_MSWordDocument,	PTP_VENDOR_MICROSOFT, "application/msword"},
+	{PTP_OFC_MTP_MSExcelSpreadsheetXLS, PTP_VENDOR_MICROSOFT, "vnd.ms-excel"},
+	{PTP_OFC_MTP_MSPowerpointPresentationPPT, PTP_VENDOR_MICROSOFT, "vnd.ms-powerpoint"},
+	{PTP_OFC_MTP_vCard2,		PTP_VENDOR_MICROSOFT, "text/directory"},
+	{PTP_OFC_MTP_vCard3,		PTP_VENDOR_MICROSOFT, "text/directory"},
+	{PTP_OFC_MTP_vCalendar1,	PTP_VENDOR_MICROSOFT, "text/calendar"},
+	{PTP_OFC_MTP_vCalendar2,	PTP_VENDOR_MICROSOFT, "text/calendar"},
+	{PTP_OFC_CANON_CRW,		PTP_VENDOR_CANON, "image/x-canon-cr2"},
+	{PTP_OFC_CANON_CRW3,		PTP_VENDOR_CANON, "image/x-canon-cr2"},
+	{PTP_OFC_CANON_MOV,		PTP_VENDOR_CANON, "video/quicktime"},
+	{PTP_OFC_CANON_CHDK_CRW,	PTP_VENDOR_CANON, "image/x-canon-cr2"},
+	{PTP_OFC_SONY_RAW,		PTP_VENDOR_SONY, "image/x-sony-arw"},
+	{0,				0, NULL}
+};
+
+static int
+set_mimetype (CameraFile *file, uint16_t vendorcode, uint16_t ofc)
+{
+	int i;
+
+	for (i = 0; object_formats[i].format_code; i++) {
+		if (object_formats[i].vendor_code && /* 0 means generic */
+		    (object_formats[i].vendor_code != vendorcode))
+			continue;
+		if (object_formats[i].format_code != ofc)
+			continue;
+		return gp_file_set_mime_type (file, object_formats[i].txt);
+	}
+	GP_LOG_D ("Failed to find mime type for %04x", ofc);
+	return gp_file_set_mime_type (file, "application/x-unknown");
+}
+
+static void
+strcpy_mime(char * dest, uint16_t vendor_code, uint16_t ofc) {
+	int i;
+
+	for (i = 0; object_formats[i].format_code; i++) {
+		if (object_formats[i].vendor_code && /* 0 means generic */
+		    (object_formats[i].vendor_code != vendor_code))
+			continue;
+		if (object_formats[i].format_code == ofc) {
+			strcpy(dest, object_formats[i].txt);
+			return;
+		}
+	}
+	GP_LOG_D ("Failed to find mime type for %04x", ofc);
+	strcpy(dest, "application/x-unknown");
+}
+
+static uint32_t
+get_mimetype (Camera *camera, CameraFile *file, uint16_t vendor_code)
+{
+	int i;
+	const char *mimetype;
+
+	gp_file_get_mime_type (file, &mimetype);
+	for (i = 0; object_formats[i].format_code; i++) {
+		if (object_formats[i].vendor_code && /* 0 means generic */
+		    (object_formats[i].vendor_code != vendor_code))
+			continue;
+		if (!strcmp(mimetype,object_formats[i].txt))
+			return (object_formats[i].format_code);
+	}
+	GP_LOG_D ("Failed to find mime type for %s", mimetype);
+	return (PTP_OFC_Undefined);
+}
+
+static void
+#ifdef __GNUC__
+__attribute__((__format__(printf,2,0)))
+#endif
+ptp_debug_func (void *data, const char *format, va_list args)
+{
+	gp_logv (GP_LOG_DEBUG, "ptp", format, args);
+}
+
+static void
+#ifdef __GNUC__
+__attribute__((__format__(printf,2,0)))
+#endif
+ptp_error_func (void *data, const char *format, va_list args)
+{
+	PTPData *ptp_data = data;
+	char buf[2048];
+
+	vsnprintf (buf, sizeof (buf), format, args);
+	gp_context_error (ptp_data->context, "%s", buf);
+}
+
+static int
+is_mtp_capable(Camera *camera) {
+	PTPParams *params = &camera->pl->params;
+	if (params->deviceinfo.VendorExtensionID == PTP_VENDOR_MICROSOFT)
+		return 1;
+	/*
+	if (camera->pl->bugs & PTP_MTP)
+		return 1;
+	*/
+	return 0;
+}
+
+int
+camera_abilities (CameraAbilitiesList *list)
+{
+	unsigned int i;
+	CameraAbilities a;
+
+	for (i = 0; i < sizeof(models)/sizeof(models[0]); i++) {
+		memset(&a, 0, sizeof(a));
+		strcpy (a.model, models[i].model);
+		a.status		= GP_DRIVER_STATUS_PRODUCTION;
+		a.port			= GP_PORT_USB;
+		a.speed[0]		= 0;
+		a.usb_vendor		= models[i].usb_vendor;
+		a.usb_product		= models[i].usb_product;
+		a.device_type		= GP_DEVICE_STILL_CAMERA;
+		a.operations		= GP_OPERATION_NONE;
+
+		/* for now */
+		if (models[i].device_flags & PTP_OLYMPUS_XML)
+			a.status	= GP_DRIVER_STATUS_EXPERIMENTAL;
+
+		if (models[i].device_flags & PTP_CAP) {
+			a.operations |= GP_OPERATION_CAPTURE_IMAGE | GP_OPERATION_CONFIG;
+
+			/* Only Nikon *D* cameras for now -Marcus */
+			if (	(models[i].usb_vendor == 0x4b0) &&
+				strchr(models[i].model,'D')
+			)
+				a.operations |= GP_OPERATION_TRIGGER_CAPTURE;
+			/* Also enable trigger capture for EOS capture */
+			if (	(models[i].usb_vendor == 0x4a9) &&
+				(strstr(models[i].model,"EOS") || strstr(models[i].model,"Rebel"))
+			)
+				a.operations |= GP_OPERATION_TRIGGER_CAPTURE;
+#if 0
+			/* SX 100 IS ... works in sdram, not in card mode */
+			if (	(models[i].usb_vendor == 0x4a9) &&
+				(models[i].usb_product == 0x315e)
+			)
+				a.operations |= GP_OPERATION_TRIGGER_CAPTURE;
+#endif
+		}
+		if (models[i].device_flags & PTP_CAP_PREVIEW)
+			a.operations |= GP_OPERATION_CAPTURE_PREVIEW;
+		a.file_operations	= GP_FILE_OPERATION_PREVIEW |
+					GP_FILE_OPERATION_DELETE;
+		a.folder_operations	= GP_FOLDER_OPERATION_PUT_FILE |
+					GP_FOLDER_OPERATION_MAKE_DIR |
+					GP_FOLDER_OPERATION_REMOVE_DIR;
+		CR (gp_abilities_list_append (list, a));
+	}
+	for (i = 0; i < sizeof(mtp_models)/sizeof(mtp_models[0]); i++) {
+		memset(&a, 0, sizeof(a));
+		sprintf (a.model, "%s:%s", mtp_models[i].vendor, mtp_models[i].model);
+		a.status		= GP_DRIVER_STATUS_PRODUCTION;
+		a.port			= GP_PORT_USB;
+		a.speed[0]		= 0;
+		a.usb_vendor		= mtp_models[i].usb_vendor;
+		a.usb_product		= mtp_models[i].usb_product;
+		a.operations		= GP_OPERATION_NONE;
+		a.device_type		= GP_DEVICE_AUDIO_PLAYER;
+		a.file_operations	= GP_FILE_OPERATION_DELETE;
+		a.folder_operations	= GP_FOLDER_OPERATION_PUT_FILE |
+					GP_FOLDER_OPERATION_MAKE_DIR |
+					GP_FOLDER_OPERATION_REMOVE_DIR;
+		CR (gp_abilities_list_append (list, a));
+	}
+
+	memset(&a, 0, sizeof(a));
+	strcpy(a.model, "USB PTP Class Camera");
+	a.status = GP_DRIVER_STATUS_TESTING;
+	a.port   = GP_PORT_USB;
+	a.speed[0] = 0;
+	a.usb_class = 6;
+	a.usb_subclass = 1;
+	a.usb_protocol = 1;
+	a.operations =	GP_OPERATION_CAPTURE_IMAGE | /*GP_OPERATION_TRIGGER_CAPTURE |*/
+		        GP_OPERATION_CAPTURE_PREVIEW |
+			GP_OPERATION_CONFIG;
+	a.file_operations   = GP_FILE_OPERATION_PREVIEW|
+				GP_FILE_OPERATION_DELETE;
+	a.folder_operations = GP_FOLDER_OPERATION_PUT_FILE
+		| GP_FOLDER_OPERATION_MAKE_DIR |
+		GP_FOLDER_OPERATION_REMOVE_DIR;
+	a.device_type       = GP_DEVICE_STILL_CAMERA;
+	CR (gp_abilities_list_append (list, a));
+	memset(&a, 0, sizeof(a));
+	strcpy(a.model, "MTP Device");
+	a.status = GP_DRIVER_STATUS_TESTING;
+	a.port   = GP_PORT_USB;
+	a.speed[0] = 0;
+	a.usb_class = 666;
+	a.usb_subclass = -1;
+	a.usb_protocol = -1;
+	a.operations        = GP_OPERATION_NONE;
+	a.file_operations   = GP_FILE_OPERATION_DELETE;
+	a.folder_operations = GP_FOLDER_OPERATION_PUT_FILE
+		| GP_FOLDER_OPERATION_MAKE_DIR |
+		GP_FOLDER_OPERATION_REMOVE_DIR;
+	a.device_type       = GP_DEVICE_AUDIO_PLAYER;
+	CR (gp_abilities_list_append (list, a));
+
+	memset(&a, 0, sizeof(a));
+	strcpy(a.model, "PTP/IP Camera");
+	a.status = GP_DRIVER_STATUS_TESTING;
+	a.port   = GP_PORT_PTPIP;
+	a.operations        =	GP_CAPTURE_IMAGE		|
+				GP_OPERATION_CONFIG;
+	a.file_operations   =	GP_FILE_OPERATION_PREVIEW	|
+				GP_FILE_OPERATION_DELETE;
+	a.folder_operations =	GP_FOLDER_OPERATION_PUT_FILE	|
+				GP_FOLDER_OPERATION_MAKE_DIR	|
+				GP_FOLDER_OPERATION_REMOVE_DIR;
+	a.device_type       = GP_DEVICE_STILL_CAMERA;
+	CR (gp_abilities_list_append (list, a));
+
+	return (GP_OK);
+}
+
+int
+camera_id (CameraText *id)
+{
+	strcpy (id->text, "PTP");
+
+	return (GP_OK);
+}
+
+static int
+camera_exit (Camera *camera, GPContext *context)
+{
+	if (camera->pl!=NULL) {
+		PTPParams *params = &camera->pl->params;
+		PTPContainer event;
+		SET_CONTEXT_P(params, context);
+		/* Disable EOS capture now, also end viewfinder mode. */
+		if (params->eos_captureenabled) {
+			if (camera->pl->checkevents) {
+				PTPCanon_changes_entry entry;
+
+				ptp_check_eos_events (params);
+				while (ptp_get_one_eos_event (params, &entry)) {
+					GP_LOG_D ("missed EOS ptp type %d", entry.type);
+					if (entry.type == PTP_CANON_EOS_CHANGES_TYPE_UNKNOWN)
+						free (entry.u.info);
+				}
+				camera->pl->checkevents = 0;
+			}
+			if (params->inliveview)
+				ptp_canon_eos_end_viewfinder (params);
+			camera_unprepare_capture (camera, context);
+		}
+		/* get the Nikon out of control mode again */
+		if (params->controlmode && ptp_operation_issupported(params,PTP_OC_NIKON_SetControlMode)) {
+			ptp_nikon_setcontrolmode (params, 0);
+			params->controlmode = 0;
+		}
+
+		if (camera->pl->checkevents)
+			ptp_check_event (params);
+		while (ptp_get_one_event (params, &event))
+			GP_LOG_D ("missed ptp event 0x%x (param1=%x)", event.Code, event.Param1);
+		/* close ptp session */
+		ptp_closesession (params);
+		ptp_free_params(params);
+
+#if defined(HAVE_ICONV) && defined(HAVE_LANGINFO_H)
+		/* close iconv converters */
+		if (params->cd_ucs2_to_locale != (iconv_t)-1) iconv_close(params->cd_ucs2_to_locale);
+		if (params->cd_locale_to_ucs2 != (iconv_t)-1) iconv_close(params->cd_locale_to_ucs2);
+#endif
+
+		free (params->data);
+		free (camera->pl); /* also frees params */
+		params = NULL;
+		camera->pl = NULL;
+	}
+	/* This code hangs USB 3 devices after the first bulk image transmission.
+         * For some unknown reason. */
+	if (0 && (camera->port!=NULL) && (camera->port->type == GP_PORT_USB)) {
+		/* clear halt */
+		gp_port_usb_clear_halt
+				(camera->port, GP_PORT_USB_ENDPOINT_IN);
+		gp_port_usb_clear_halt
+				(camera->port, GP_PORT_USB_ENDPOINT_OUT);
+		gp_port_usb_clear_halt
+				(camera->port, GP_PORT_USB_ENDPOINT_INT);
+	}
+	return (GP_OK);
+}
+
+static int
+camera_about (Camera *camera, CameraText *text, GPContext *context)
+{
+	/* Note that we are not a so called 'Licensed Implementation' of MTP
+	 * ... (for a LI you need express approval from Microsoft etc.)
+	 */
+	snprintf (text->text, sizeof(text->text),
+	 _("PTP2 driver\n"
+	   "(c) 2001-2005 by Mariusz Woloszyn <emsi@ipartners.pl>.\n"
+	   "(c) 2003-%d by Marcus Meissner <marcus@jet.franken.de>.\n"
+	   "This driver supports cameras that support PTP or PictBridge(tm), and\n"
+	   "Media Players that support the Media Transfer Protocol (MTP).\n"
+	   "\n"
+	   "Enjoy!"), 2015);
+	return (GP_OK);
+}
+
+static void debug_objectinfo(PTPParams *params, uint32_t oid, PTPObjectInfo *oi);
+
+/* Add new object to internal driver structures. issued when creating
+ * folder, uploading objects, or captured images.
+ */
+static int
+add_object (Camera *camera, uint32_t handle, GPContext *context)
+{
+	PTPObject *ob;
+	PTPParams *params = &camera->pl->params;
+
+	C_PTP (ptp_object_want (params, handle, 0, &ob));
+	return GP_OK;
+}
+
+static int
+camera_capture_preview (Camera *camera, CameraFile *file, GPContext *context)
+{
+	unsigned char	*data = NULL, *jpgStartPtr = NULL, *jpgEndPtr = NULL;
+	uint32_t	size = 0;
+	uint16_t	ret;
+	PTPParams *params = &camera->pl->params;
+
+	camera->pl->checkevents = TRUE;
+	switch (params->deviceinfo.VendorExtensionID) {
+	case PTP_VENDOR_CANON:
+		/* Canon PowerShot / IXUS preview mode */
+		if (ptp_operation_issupported(params, PTP_OC_CANON_ViewfinderOn)) {
+			SET_CONTEXT_P(params, context);
+			/* check if we need to prepare capture */
+			if (!params->canon_event_mode)
+				CR (camera_prepare_capture (camera, context));
+			if (!params->canon_viewfinder_on) { /* enable on demand, but just once */
+				C_PTP_REP_MSG (ptp_canon_viewfinderon (params),
+					       _("Canon enable viewfinder failed"));
+				params->canon_viewfinder_on = 1;
+			}
+			C_PTP_REP_MSG (ptp_canon_getviewfinderimage (params, &data, &size),
+				       _("Canon get viewfinder image failed"));
+			gp_file_append ( file, (char*)data, size );
+			free (data);
+			gp_file_set_mime_type (file, GP_MIME_JPEG);     /* always */
+			/* Add an arbitrary file name so caller won't crash */
+			gp_file_set_name (file, "canon_preview.jpg");
+			gp_file_set_mtime (file, time(NULL));
+			SET_CONTEXT_P(params, NULL);
+			return GP_OK;
+		}
+		/* Canon EOS DSLR preview mode */
+		if (ptp_operation_issupported(params, PTP_OC_CANON_EOS_GetViewFinderData)) {
+			PTPPropertyValue	val;
+			/* FIXME: this might cause a focusing pass and take seconds. 20 was not
+			 * enough (would be 0.2 seconds, too short for the mirror up operation.). */
+			/* The EOS 100D takes 1.2 seconds */
+			int 			tries = 200;
+			PTPDevicePropDesc       dpd;
+
+			SET_CONTEXT_P(params, context);
+
+			if (!params->eos_captureenabled)
+				camera_prepare_capture (camera, context);
+			memset (&dpd,0,sizeof(dpd));
+
+			/* do not set it everytime, it will cause delays */
+			ret = ptp_canon_eos_getdevicepropdesc (params, PTP_DPC_CANON_EOS_EVFMode, &dpd);
+			if ((ret != PTP_RC_OK) || (dpd.CurrentValue.u16 != 1)) {
+				/* 0 means off, 1 means on */
+				val.u16 = 1;
+				C_PTP_MSG (ptp_canon_eos_setdevicepropvalue (params, PTP_DPC_CANON_EOS_EVFMode, &val, PTP_DTC_UINT16),
+					   "setval of evf enable to 1 failed (curval is %d)!", dpd.CurrentValue.u16);
+			}
+			ptp_free_devicepropdesc (&dpd);
+			/* do not set it everytime, it will cause delays */
+			ret = ptp_canon_eos_getdevicepropdesc (params, PTP_DPC_CANON_EOS_EVFOutputDevice, &dpd);
+			if ((ret != PTP_RC_OK) || (dpd.CurrentValue.u32 != 2)) {
+				/* 2 means PC, 1 means TFT */
+				val.u32 = 2;
+				C_PTP_MSG (ptp_canon_eos_setdevicepropvalue (params, PTP_DPC_CANON_EOS_EVFOutputDevice, &val, PTP_DTC_UINT32),
+					   "setval of evf outputmode to 2 failed (curval is %d)!", dpd.CurrentValue.u32);
+			}
+			ptp_free_devicepropdesc (&dpd);
+
+			/* Otherwise the camera will auto-shutdown */
+			C_PTP (ptp_canon_eos_keepdeviceon (params));
+
+			params->inliveview = 1;
+			while (tries--) {
+				unsigned char	*xdata;
+				/* Poll for camera events, but just call
+				 * it once and do not drain the queue now */
+				C_PTP (ptp_check_eos_events (params));
+
+				ret = ptp_canon_eos_get_viewfinder_image (params , &data, &size);
+				if ((ret == 0xa102) || (ret == PTP_RC_DeviceBusy)) { /* means "not there yet" ... so wait */
+					/* frames/second rate vs compute power drainage ... polling
+					 * makes the camera too busy to do other tasks and they take
+					 * longer. */
+					if (tries < 98)
+						usleep (2000);
+					else
+						usleep (1300);
+					continue;
+				}
+				C_PTP_MSG (ret, "get_viewfinder_image failed");
+
+				/* returns multiple blobs, they are usually structured as
+				 * uint32 len
+				 * uint32 type
+				 * ... data ...
+				 *
+				 * 1: JPEG preview
+				 */
+
+				xdata = data;
+				GP_LOG_D ("total size: len=%d", size);
+				while ((xdata-data) < size) {
+					uint32_t	len  = dtoh32a(xdata);
+					uint32_t	type = dtoh32a(xdata+4);
+
+					/* 4 byte len of jpeg data, 4 byte type */
+					/* JPEG blob */
+					/* stuff */
+					GP_LOG_D ("get_viewfinder_image header: len=%d type=%d", len, type);
+					switch (type) {
+					default:
+						if (len > (size-(xdata-data))) {
+							len = size;
+							GP_LOG_E ("len=%d larger than rest size %ld", len, (size-(xdata-data)));
+						}
+						GP_LOG_DATA ((char*)xdata, len, "get_viewfinder_image header:");
+						xdata = xdata+len;
+						continue;
+					case 9:
+					case 1:
+						if (len > (size-(xdata-data))) {
+							len = size;
+							GP_LOG_E ("len=%d larger than rest size %ld", len, (size-(xdata-data)));
+							break;
+						}
+						gp_file_append ( file, (char*)xdata+8, len-8 );
+						/* type 1 is JPEG (regular), type 9 is in movie mode */
+
+						gp_file_set_mime_type (file, (type==1) ? GP_MIME_JPEG : GP_MIME_RAW);
+
+						/* Add an arbitrary file name so caller won't crash */
+						gp_file_set_name (file, "preview.jpg");
+
+						/* dump the rest of the blobs */
+						xdata = xdata+len;
+						while ((xdata-data) < size) {
+							len  = dtoh32a(xdata);
+							type = dtoh32a(xdata+4);
+
+							if (len > (size-(xdata-data))) {
+								len = size;
+								GP_LOG_E ("len=%d larger than rest size %ld", len, (size-(xdata-data)));
+								break;
+							}
+							GP_LOG_DATA ((char*)xdata, len, "get_viewfinder_image header:");
+							xdata = xdata+len;
+						}
+						free (data);
+						SET_CONTEXT_P(params, NULL);
+						return GP_OK;
+					}
+				}
+				return GP_ERROR;
+			}
+			GP_LOG_E ("get_viewfinder_image failed after all tries with ret: 0x%x\n", ret);
+			SET_CONTEXT_P(params, NULL);
+			return translate_ptp_result (ret);
+		}
+		gp_context_error (context, _("Sorry, your Canon camera does not support Canon Viewfinder mode"));
+		return GP_ERROR_NOT_SUPPORTED;
+	case PTP_VENDOR_NIKON: {
+		PTPPropertyValue	value;
+		int 			tries, firstimage = 0;
+
+		if (!ptp_operation_issupported(params, PTP_OC_NIKON_StartLiveView)) {
+			gp_context_error (context,
+				_("Sorry, your Nikon camera does not support LiveView mode"));
+			return GP_ERROR_NOT_SUPPORTED;
+		}
+		SET_CONTEXT_P(params, context);
+
+		/* Nilon V and J seem to like that */
+		if (!params->controlmode && ptp_operation_issupported(params,PTP_OC_NIKON_SetControlMode)) {
+			ret = ptp_nikon_setcontrolmode (params, 1);
+			/* FIXME: PTP_RC_NIKON_ChangeCameraModeFailed does not seem to be problematic */
+			if (ret != PTP_RC_NIKON_ChangeCameraModeFailed)
+				C_PTP_REP (ret);
+			params->controlmode = 1;
+		}
+
+		ret = ptp_getdevicepropvalue (params, PTP_DPC_NIKON_LiveViewStatus, &value, PTP_DTC_UINT8);
+		if (ret != PTP_RC_OK)
+			value.u8 = 0;
+
+enable_liveview:
+		if (!value.u8) {
+			value.u8 = 1;
+			if (have_prop(camera, params->deviceinfo.VendorExtensionID, PTP_DPC_NIKON_RecordingMedia))
+				LOG_ON_PTP_E (ptp_setdevicepropvalue (params, PTP_DPC_NIKON_RecordingMedia, &value, PTP_DTC_UINT8));
+			C_PTP_REP_MSG (ptp_nikon_start_liveview (params),
+				       _("Nikon enable liveview failed"));
+			do {
+				ret = ptp_nikon_device_ready(params);
+				usleep(20*1000);
+			} while (ret == PTP_RC_DeviceBusy);
+
+			C_PTP_REP_MSG (ret, _("Nikon enable liveview failed"));
+			params->inliveview = 1;
+			firstimage = 1;
+		}
+		/* nikon 1 special */
+		if (value.u8 && !params->inliveview) {
+			C_PTP_REP_MSG (ptp_nikon_start_liveview (params),
+				       _("Nikon enable liveview failed"));
+			do {
+				ret = ptp_nikon_device_ready(params);
+				usleep(20*1000);
+			} while (ret == PTP_RC_DeviceBusy);
+
+			C_PTP_REP_MSG (ret, _("Nikon enable liveview failed"));
+			params->inliveview = 1;
+		}
+		tries = 20;
+		while (tries--) {
+			ret = ptp_nikon_get_liveview_image (params , &data, &size);
+			if (ret == PTP_RC_NIKON_NotLiveView) {
+				/* this happens on the D7000 after 14000 frames... reenable liveview */
+				params->inliveview = 0;
+				value.u8 = 0;
+				goto enable_liveview;
+			}
+			if (ret == PTP_RC_OK) {
+				if (firstimage) {
+					/* the first image on the S9700 is corrupted. so just skip the first image */
+					firstimage = 0;
+					free (data);
+					continue;
+				}
+				/* look for the JPEG SOI marker (0xFFD8) in data */
+				jpgStartPtr = (unsigned char*)memchr(data, 0xff, size);
+				while(jpgStartPtr && ((jpgStartPtr+1) < (data + size))) {
+					if(*(jpgStartPtr + 1) == 0xd8) { /* SOI found */
+						break;
+					} else { /* go on looking (starting at next byte) */
+						jpgStartPtr++;
+						jpgStartPtr = (unsigned char*)memchr(jpgStartPtr, 0xff, data + size - jpgStartPtr);
+					}
+				}
+				if(!jpgStartPtr) { /* no SOI -> no JPEG */
+					gp_context_error (context, _("Sorry, your Nikon camera does not seem to return a JPEG image in LiveView mode"));
+					return GP_ERROR;
+				}
+				/* if SOI found, start looking for EOI marker (0xFFD9) one byte after SOI
+				   (just to be sure we will not go beyond the end of the data array) */
+				jpgEndPtr = (unsigned char*)memchr(jpgStartPtr+1, 0xff, data+size-jpgStartPtr-1);
+				while(jpgEndPtr && ((jpgEndPtr+1) < (data + size))) {
+					if(*(jpgEndPtr + 1) == 0xd9) { /* EOI found */
+						jpgEndPtr += 2;
+						break;
+					} else { /* go on looking (starting at next byte) */
+						jpgEndPtr++;
+						jpgEndPtr = (unsigned char*)memchr(jpgEndPtr, 0xff, data + size - jpgEndPtr);
+					}
+				}
+				if(!jpgEndPtr) { /* no EOI -> no JPEG */
+					gp_context_error (context, _("Sorry, your Nikon camera does not seem to return a JPEG image in LiveView mode"));
+					return GP_ERROR;
+				}
+				gp_file_append (file, (char*)jpgStartPtr, jpgEndPtr-jpgStartPtr);
+				free (data); /* FIXME: perhaps handle the 128 byte header data too. */
+				gp_file_set_mime_type (file, GP_MIME_JPEG);     /* always */
+				/* Add an arbitrary file name so caller won't crash */
+				gp_file_set_name (file, "preview.jpg");
+				gp_file_set_mtime (file, time(NULL));
+				break;
+			}
+			if (ret == PTP_RC_DeviceBusy) {
+				GP_LOG_D ("busy, retrying after a bit of wait, try %d", tries);
+				usleep(10*1000);
+				continue;
+			}
+			SET_CONTEXT_P(params, NULL);
+			return translate_ptp_result (ret);
+		}
+#if 0
+		C_PTP_REP_MSG (ptp_nikon_end_liveview (params),
+			       _("Nikon disable liveview failed"));
+#endif
+		SET_CONTEXT_P(params, NULL);
+		return GP_OK;
+	}
+	default:
+		break;
+	}
+	return GP_ERROR_NOT_SUPPORTED;
+}
+
+static int
+get_folder_from_handle (Camera *camera, uint32_t storage, uint32_t handle, char *folder) {
+	PTPObject	*ob;
+	PTPParams 	*params = &camera->pl->params;
+
+	GP_LOG_D ("(%x,%x,%s)", storage, handle, folder);
+	if (handle == PTP_HANDLER_ROOT)
+		return GP_OK;
+
+	C_PTP (ptp_object_want (params, handle, PTPOBJECT_OBJECTINFO_LOADED, &ob));
+	CR (get_folder_from_handle (camera, storage, ob->oi.ParentObject, folder));
+	/* now ob could be invalid, since we might have reallocated params->objects */
+	ptp_object_want (params, handle, PTPOBJECT_OBJECTINFO_LOADED, &ob);
+	strcat (folder, ob->oi.Filename);
+	strcat (folder, "/");
+	return (GP_OK);
+}
+
+static int
+add_objectid_and_upload (Camera *camera, CameraFilePath *path, GPContext *context,
+	uint32_t newobject, PTPObjectInfo *oi) {
+	int			ret;
+	PTPParams		*params = &camera->pl->params;
+	CameraFile		*file = NULL;
+	unsigned char		*ximage = NULL;
+	CameraFileInfo		info;
+
+	ret = gp_file_new(&file);
+	if (ret!=GP_OK) return ret;
+	gp_file_set_mtime (file, time(NULL));
+	set_mimetype (file, params->deviceinfo.VendorExtensionID, oi->ObjectFormat);
+	C_PTP_REP (ptp_getobject(params, newobject, &ximage));
+
+	GP_LOG_D ("setting size");
+	ret = gp_file_set_data_and_size(file, (char*)ximage, oi->ObjectCompressedSize);
+	if (ret != GP_OK) {
+		gp_file_free (file);
+		return ret;
+	}
+	GP_LOG_D ("append to fs");
+	ret = gp_filesystem_append(camera->fs, path->folder, path->name, context);
+        if (ret != GP_OK) {
+		gp_file_free (file);
+		return ret;
+	}
+	GP_LOG_D ("adding filedata to fs");
+	ret = gp_filesystem_set_file_noop(camera->fs, path->folder, path->name, GP_FILE_TYPE_NORMAL, file, context);
+        if (ret != GP_OK) {
+		gp_file_free (file);
+		return ret;
+	}
+
+	/* We have now handed over the file, disclaim responsibility by unref. */
+	gp_file_unref (file);
+
+	/* we also get the fs info for free, so just set it */
+	info.file.fields = GP_FILE_INFO_TYPE |
+			GP_FILE_INFO_WIDTH | GP_FILE_INFO_HEIGHT |
+			GP_FILE_INFO_SIZE | GP_FILE_INFO_MTIME;
+	strcpy_mime (info.file.type, params->deviceinfo.VendorExtensionID, oi->ObjectFormat);
+	info.file.width		= oi->ImagePixWidth;
+	info.file.height	= oi->ImagePixHeight;
+	info.file.size		= oi->ObjectCompressedSize;
+	info.file.mtime		= time(NULL);
+
+	info.preview.fields = GP_FILE_INFO_TYPE |
+			GP_FILE_INFO_WIDTH | GP_FILE_INFO_HEIGHT |
+			GP_FILE_INFO_SIZE;
+	strcpy_mime (info.preview.type, params->deviceinfo.VendorExtensionID, oi->ThumbFormat);
+	info.preview.width	= oi->ThumbPixWidth;
+	info.preview.height	= oi->ThumbPixHeight;
+	info.preview.size	= oi->ThumbCompressedSize;
+	GP_LOG_D ("setting fileinfo in fs");
+	return gp_filesystem_set_info_noop(camera->fs, path->folder, path->name, info, context);
+}
+
+/**
+ * camera_nikon_capture:
+ * params:      Camera*			- camera object
+ *              CameraCaptureType type	- type of object to capture
+ *              CameraFilePath *path    - filled out with filename and folder on return
+ *              uint32_t af             - use autofocus or not.
+ *              uint32_t sdram          - capture to sdram or not
+ *              GPContext* context      - gphoto context for this operation
+ *
+ * This function captures an image using special Nikon capture to SDRAM.
+ * The object(s) do(es) not appear in the "objecthandles" array returned by GetObjectHandles,
+ * so we need to download them here immediately.
+ *
+ * Return values: A gphoto return code.
+ * Upon success CameraFilePath *path contains the folder and filename of the captured
+ * image.
+ */
+static int
+camera_nikon_capture (Camera *camera, CameraCaptureType type, CameraFilePath *path,
+		uint32_t af, int sdram, GPContext *context)
+{
+	static int capcnt = 0;
+	PTPObjectInfo		oi;
+	PTPParams		*params = &camera->pl->params;
+	PTPDevicePropDesc	propdesc;
+	PTPPropertyValue	propval;
+	int			i, ret, burstnumber = 1, done, tries;
+	uint32_t		newobject;
+
+	if (type != GP_CAPTURE_IMAGE)
+		return GP_ERROR_NOT_SUPPORTED;
+
+	if (params->deviceinfo.VendorExtensionID!=PTP_VENDOR_NIKON)
+		return GP_ERROR_NOT_SUPPORTED;
+
+	/* Nilon V and J seem to like that */
+	if (!params->controlmode && ptp_operation_issupported(params,PTP_OC_NIKON_SetControlMode)) {
+		ret = ptp_nikon_setcontrolmode (params, 1);
+		/* FIXME: PTP_RC_NIKON_ChangeCameraModeFailed does not seem to be problematic */
+		if (ret != PTP_RC_NIKON_ChangeCameraModeFailed)
+			C_PTP_REP (ret);
+		params->controlmode = 1;
+	}
+
+	if (	!ptp_operation_issupported(params,PTP_OC_NIKON_Capture) &&
+		!ptp_operation_issupported(params,PTP_OC_NIKON_AfCaptureSDRAM) &&
+		!ptp_operation_issupported(params,PTP_OC_NIKON_InitiateCaptureRecInMedia)
+	) {
+		gp_context_error(context,
+               	_("Sorry, your camera does not support Nikon capture"));
+		return GP_ERROR_NOT_SUPPORTED;
+	}
+	if (	ptp_property_issupported(params, PTP_DPC_StillCaptureMode)	&&
+		(PTP_RC_OK == ptp_getdevicepropdesc (params, PTP_DPC_StillCaptureMode, &propdesc))) {
+		PTPDevicePropDesc       burstdesc;
+
+		if ((propdesc.DataType == PTP_DTC_UINT16)			&&
+		    (propdesc.CurrentValue.u16 == 2) /* Burst Mode */		&&
+		    ptp_property_issupported(params, PTP_DPC_BurstNumber)	&&
+		    (PTP_RC_OK == ptp_getdevicepropdesc (params, PTP_DPC_BurstNumber, &burstdesc))) {
+			if (burstdesc.DataType == PTP_DTC_UINT16) {
+				burstnumber = burstdesc.CurrentValue.u16;
+				GP_LOG_D ("burstnumber %d", burstnumber);
+			}
+			ptp_free_devicepropdesc (&burstdesc);
+		    }
+		ptp_free_devicepropdesc (&propdesc);
+	}
+
+	/* if in liveview mode, we have to run non-af capture */
+	params->inliveview = 0;
+	if (ptp_property_issupported (params, PTP_DPC_NIKON_LiveViewStatus)) {
+		ret = ptp_getdevicepropvalue (params, PTP_DPC_NIKON_LiveViewStatus, &propval, PTP_DTC_UINT8);
+		if (ret == PTP_RC_OK)
+			params->inliveview = propval.u8;
+		if (params->inliveview) af = 0;
+	}
+
+	if (NIKON_1(params))
+		C_PTP_REP_MSG (ptp_nikon_start_liveview (params),
+			       _("Failed to enable liveview on a Nikon 1, but it is required for capture"));
+
+	if (ptp_operation_issupported(params, PTP_OC_NIKON_InitiateCaptureRecInMedia)) {
+		int loops = 100;
+		do {
+			ret = ptp_nikon_capture2(params,af,sdram);
+			if (ret == PTP_RC_DeviceBusy) usleep(2000);
+		} while ((ret == PTP_RC_DeviceBusy) && loops--);
+		goto capturetriggered;
+	}
+
+	if (!params->inliveview && ptp_operation_issupported(params,PTP_OC_NIKON_AfCaptureSDRAM)) {
+		int loops = 100;
+		do {
+			ret = ptp_nikon_capture_sdram(params);
+		} while ((ret == PTP_RC_DeviceBusy) && (loops--));
+	} else {
+		int loops = 100;
+		do {
+			ret = ptp_nikon_capture(params, 0xffffffff);
+		} while ((ret == PTP_RC_DeviceBusy) && (loops--));
+	}
+
+capturetriggered:
+	C_PTP_REP (ret);
+
+	CR (gp_port_set_timeout (camera->port, capture_timeout));
+
+	while ((ret = ptp_nikon_device_ready(params)) == PTP_RC_DeviceBusy) {
+		gp_context_idle (context);
+		/* do not drain all of the DSLRs compute time */
+		usleep(100*1000); /* 0.1 seconds */
+	}
+
+	C_PTP_REP (ret); /* e.g. out of focus gets reported here. */
+
+	newobject = 0xffff0001;
+	done = 0; tries = 100;
+	while (done != 3) {
+		PTPContainer	event;
+		int 		checkevt;
+
+		/* Just busy loop until the camera is ready again. */
+		/* and wait for the 0xc101 event */
+		C_PTP_REP (ptp_check_event (params));
+		checkevt = 0;
+		while (ptp_get_one_event(params, &event)) {
+			GP_LOG_D ("event.Code is %x / param %lx", event.Code, (unsigned long)event.Param1);
+			switch (event.Code) {
+			case PTP_EC_Nikon_ObjectAddedInSDRAM:
+				done |= 3;
+				newobject = event.Param1;
+				if (!newobject) newobject = 0xffff0001;
+				break;
+			case PTP_EC_ObjectAdded: {
+				PTPObject	*ob;
+
+				/* if we got one object already, put it into the queue */
+				/* e.g. for NEF+RAW capture */
+				if (newobject != 0xffff0001) {
+					ptp_add_event (params, &event);
+					checkevt = 1; /* avoid endless loop */
+					done = 3;
+					break;
+				}
+				/* we register the object in the internal storage, and we also need to
+				 * to find out if it is just a new directory (/DCIM/NEWENTRY/) created
+				 * during capture or the actual image. */
+				ret = ptp_object_want (params, event.Param1, PTPOBJECT_OBJECTINFO_LOADED, &ob);
+				if (ret != PTP_RC_OK)
+					break;
+				/* if a new directory was added, not a file ... just continue.
+				 * happens when the camera starts with an empty card. */
+				if (ob->oi.ObjectFormat == PTP_OFC_Association) {
+					/* libgphoto2 vfs does not notice otherwise */
+					gp_filesystem_reset (camera->fs);
+					break;
+				}
+				newobject = event.Param1;
+				done |= 2;
+				break;
+			}
+			case PTP_EC_Nikon_CaptureCompleteRecInSdram:
+			case PTP_EC_CaptureComplete:
+				if (params->inliveview) {
+					GP_LOG_D ("Capture complete ... restarting liveview");
+					ret = ptp_nikon_start_liveview (params);
+				}
+				done |= 1;
+				break;
+			default:
+				GP_LOG_D ("UNHANDLED event.Code is %x / param %lx, DEFER", event.Code, (unsigned long)event.Param1);
+				ptp_add_event (params, &event);
+				checkevt = 1; /* avoid endless loop */
+				break;
+			}
+			if (checkevt)
+				break;
+		}
+		/* we got both capturecomplete and objectadded ... leave */
+		if (done == 3)
+			break;
+		/* just got capturecomplete ... wait a bit for a objectadded (Nikon 1) */
+		if (done == 1) {
+			if (!tries--)
+				break;
+		}
+		gp_context_idle (context);
+		/* do not drain all of the DSLRs compute time */
+		usleep(50*1000);
+	}
+	if (!newobject) newobject = 0xffff0001;
+
+	/* This loop handles single and burst capture. 
+	 * It also handles SDRAM and also CARD capture.
+	 * In Burst/SDRAM we need to download everything at once
+	 * In all SDRAM modes we download and store it in the virtual fs.
+	 * in Burst/CARD we add just the 1st as object, but do not download it yet.
+	 */
+	for (i=0;i<burstnumber;i++) {
+		/* In Burst mode, the image is always 0xffff0001.
+		 * The firmware just gives us one after the other for the same ID
+		 * Not so for the D700 :/
+		 */
+		C_PTP (ptp_getobjectinfo (params, newobject, &oi));
+
+		debug_objectinfo(params, newobject, &oi);
+
+		if (oi.ParentObject == 0) { /* Capture to SDRAM */
+			GP_LOG_E ("Parentobject of newobject 0x%x is 0x%x now?", (unsigned int)newobject, (unsigned int)oi.ParentObject);
+			/* Happens on Nikon D70, we get Storage ID 0. So fake one. */
+			if (oi.StorageID == 0) {
+				strcpy (path->folder, "/");
+			} else {
+				sprintf (path->folder,"/"STORAGE_FOLDER_PREFIX"%08lx",(unsigned long)oi.StorageID);
+			}
+			if (oi.ObjectFormat != PTP_OFC_EXIF_JPEG) {
+				/* the Nikon Coolpix P2 says "TIFF" and gives us "JPG". weird. */
+				if (oi.Filename && strstr(oi.Filename,".JPG")) {
+					GP_LOG_D ("rewriting %04x to JPEG %04x for %s", oi.ObjectFormat,PTP_OFC_EXIF_JPEG,oi.Filename);
+					oi.ObjectFormat = PTP_OFC_EXIF_JPEG;
+				}
+			}
+
+			if (oi.ObjectFormat != PTP_OFC_EXIF_JPEG) {
+				GP_LOG_D ("raw? ofc is 0x%04x, name is %s", oi.ObjectFormat,oi.Filename);
+				sprintf (path->name, "capt%04d.nef", capcnt++);
+			} else {
+				sprintf (path->name, "capt%04d.jpg", capcnt++);
+			}
+			ret = add_objectid_and_upload (camera, path, context, newobject, &oi);
+			if (ret != GP_OK) {
+				GP_LOG_E ("failed to add object\n");
+				return ret;
+			}
+	/* this does result in 0x2009 (invalid object id) with the D90 ... curiuos
+			ret = ptp_nikon_delete_sdram_image (params, newobject);
+	 */
+			ret = ptp_deleteobject (params, newobject, 0);
+			if (ret != PTP_RC_OK) {
+				GP_LOG_E ("deleteobject(%x) failed: %x", newobject, ret);
+			}
+		} else { /* capture to card branch */
+			CR (add_object (camera, newobject, context));
+			strcpy  (path->name,  oi.Filename);
+			sprintf (path->folder,"/"STORAGE_FOLDER_PREFIX"%08lx/",(unsigned long)oi.StorageID);
+			get_folder_from_handle (camera, oi.StorageID, oi.ParentObject, path->folder);
+			/* delete last / or we get confused later. */
+			path->folder[ strlen(path->folder)-1 ] = '\0';
+
+			ptp_free_objectinfo(&oi);
+
+			/* not doing the rest of the burst loop ... */
+			return gp_filesystem_append (camera->fs, path->folder, path->name, context);
+		}
+	}
+	ptp_check_event (params);
+	return GP_OK;
+}
+
+/* 60 seconds timeout ... (for long cycles) */
+#define EOS_CAPTURE_TIMEOUT 60
+
+/* This is currently the capture method used by the EOS 400D
+ * ... in development.
+ */
+static int
+camera_canon_eos_capture (Camera *camera, CameraCaptureType type, CameraFilePath *path,
+		GPContext *context)
+{
+	int			ret;
+	PTPParams		*params = &camera->pl->params;
+	uint32_t		newobject = 0x0;
+	PTPCanon_changes_entry	entry;
+	CameraFile		*file = NULL;
+	unsigned char		*ximage = NULL;
+	static int		capcnt = 0;
+	PTPObjectInfo		oi;
+	int			sleepcnt = 1;
+	uint32_t		result;
+	time_t                  capture_start=time(NULL);
+
+	if (!ptp_operation_issupported(params, PTP_OC_CANON_EOS_RemoteRelease)) {
+		gp_context_error (context,
+		_("Sorry, your Canon camera does not support Canon EOS Capture"));
+		return GP_ERROR_NOT_SUPPORTED;
+	}
+	if (!params->eos_captureenabled)
+		camera_prepare_capture (camera, context);
+	else
+		CR( camera_canon_eos_update_capture_target(camera, context, -1));
+
+	/* Get the initial bulk set of event data, otherwise
+	 * capture might return busy. */
+	ptp_check_eos_events (params);
+	while (ptp_get_one_eos_event (params, &entry))
+		GP_LOG_D("discarding event type %d", entry.type);
+
+	if (ptp_operation_issupported(params, PTP_OC_CANON_EOS_RemoteReleaseOn)) {
+		int oneloop;
+
+		ret = GP_OK;
+		/* half press now - initiate focusing and wait for result */
+		C_PTP_REP_MSG (ptp_canon_eos_remotereleaseon (params, 1, 0), _("Canon EOS Half-Press failed"));
+
+		do {
+			int foundfocusinfo = 0;
+			C_PTP_REP_MSG (ptp_check_eos_events (params), _("Canon EOS Get Changes failed"));
+			oneloop = 0;
+			while (ptp_get_one_eos_event (params, &entry)) {
+				oneloop = 1;
+				GP_LOG_D("focusing - read event type %d", entry.type);
+				if (entry.type == PTP_CANON_EOS_CHANGES_TYPE_FOCUSINFO) {
+					GP_LOG_D("focusinfo content: %s", entry.u.info);
+					foundfocusinfo = 1;
+					if (strstr(entry.u.info,"0000200")) {
+						gp_context_error (context, _("Canon EOS Capture failed to release: Perhaps no focus?"));
+						ret = GP_ERROR;
+					}
+				}
+			}
+			if (foundfocusinfo)
+				break;
+		} while (oneloop);
+
+		if (ret != GP_OK) {
+			C_PTP_REP_MSG (ptp_canon_eos_remotereleaseoff (params, 1), _("Canon EOS Half-Release failed"));
+			return ret;
+		}
+		/* full press now */
+
+		C_PTP_REP_MSG (ptp_canon_eos_remotereleaseon (params, 2, 0), _("Canon EOS Full-Press failed"));
+		/* no event check between */
+		/* full release now */
+		C_PTP_REP_MSG (ptp_canon_eos_remotereleaseoff (params, 2), _("Canon EOS Full-Release failed"));
+		ptp_check_eos_events (params);
+
+		/* half release now */
+		C_PTP_REP_MSG (ptp_canon_eos_remotereleaseoff (params, 1), _("Canon EOS Half-Release failed"));
+	} else {
+		C_PTP_REP_MSG (ptp_canon_eos_capture (params, &result),
+			       _("Canon EOS Capture failed"));
+
+		if ((result & 0x7000) == 0x2000) { /* also happened */
+			gp_context_error (context, _("Canon EOS Capture failed: %x"), result);
+			return translate_ptp_result (result);
+		}
+		GP_LOG_D ("result is %d", result);
+		switch (result) {
+		case 0: /* OK */
+			break;
+		case 1: gp_context_error (context, _("Canon EOS Capture failed to release: Perhaps no focus?"));
+			return GP_ERROR;
+		case 3: gp_context_error (context, _("Canon EOS Capture failed to release: Perhaps mirror up?"));
+			return GP_ERROR;
+		case 7: gp_context_error (context, _("Canon EOS Capture failed to release: Perhaps no more memory on card?"));
+			return GP_ERROR_NO_MEMORY;
+		case 8: gp_context_error (context, _("Canon EOS Capture failed to release: Card read-only?"));
+			return GP_ERROR_NO_MEMORY;
+		default:gp_context_error (context, _("Canon EOS Capture failed to release: Unknown error %d, please report."), result);
+			return GP_ERROR;
+		}
+	}
+
+	newobject = 0;
+	memset (&oi, 0, sizeof(oi));
+	while ((time(NULL)-capture_start)<=EOS_CAPTURE_TIMEOUT) {
+		int i;
+
+		C_PTP_REP_MSG (ptp_check_eos_events (params),
+			       _("Canon EOS Get Changes failed"));
+		while (ptp_get_one_eos_event (params, &entry)) {
+			sleepcnt = 1;
+			if (entry.type == PTP_CANON_EOS_CHANGES_TYPE_UNKNOWN) {
+				GP_LOG_D ("entry unknown: %s", entry.u.info);
+				free (entry.u.info);
+				continue; /* in loop ... do not poll while draining the queue */
+			}
+			GP_LOG_D ("entry type %04x", entry.type);
+			if (entry.type == PTP_CANON_EOS_CHANGES_TYPE_OBJECTTRANSFER) {
+				GP_LOG_D ("Found new object! OID 0x%x, name %s", (unsigned int)entry.u.object.oid, entry.u.object.oi.Filename);
+				newobject = entry.u.object.oid;
+				memcpy (&oi, &entry.u.object.oi, sizeof(oi));
+				break;
+			}
+			if (entry.type == PTP_CANON_EOS_CHANGES_TYPE_OBJECTINFO) {
+				PTPObject	*ob;
+
+				/* just add it to the filesystem, and return in CameraPath */
+				GP_LOG_D ("Found new object! OID 0x%x, name %s", (unsigned int)entry.u.object.oid, entry.u.object.oi.Filename);
+				newobject = entry.u.object.oid;
+				memcpy (&oi, &entry.u.object.oi, sizeof(oi));
+				ret = ptp_object_want (params, newobject, 0, &ob);
+				if (ret != PTP_RC_OK)
+					continue;
+				strcpy  (path->name,  oi.Filename);
+				sprintf (path->folder,"/"STORAGE_FOLDER_PREFIX"%08lx/",(unsigned long)oi.StorageID);
+				get_folder_from_handle (camera, oi.StorageID, oi.ParentObject, path->folder);
+				/* delete last / or we get confused later. */
+				path->folder[ strlen(path->folder)-1 ] = '\0';
+				gp_filesystem_append (camera->fs, path->folder, path->name, context);
+				break;/* for RAW+JPG mode capture, we just return the first image for now, and
+				       * let wait_for_event get the rest. */
+			}
+			if (newobject)
+				break;
+		}
+		if (newobject)
+			break;
+		/* Nothing done ... do wait backoff ... if we poll too fast, the camera will spend
+		 * all time serving the polling. */
+		for (i=sleepcnt;i--;) {
+			gp_context_idle (context);
+			usleep(20*1000); /* 20 ms */
+		}
+		sleepcnt++; /* incremental back off */
+		if (sleepcnt>10) sleepcnt=10;
+
+		/* not really proven to help keep it on */
+		C_PTP_REP (ptp_canon_eos_keepdeviceon (params));
+	}
+	if (newobject == 0)
+		return GP_ERROR;
+	GP_LOG_D ("object has OFC 0x%x", oi.ObjectFormat);
+
+	if (oi.StorageID) /* all done above */
+		return GP_OK;
+
+	strcpy  (path->folder,"/");
+	sprintf (path->name, "capt%04d.", capcnt++);
+	CR (gp_file_new(&file));
+	if (oi.ObjectFormat == PTP_OFC_CANON_CRW || oi.ObjectFormat == PTP_OFC_CANON_CRW3) {
+		strcat(path->name, "cr2");
+		gp_file_set_mime_type (file, GP_MIME_CRW);
+	} else {
+		strcat(path->name, "jpg");
+		gp_file_set_mime_type (file, GP_MIME_JPEG);
+	}
+	gp_file_set_mtime (file, time(NULL));
+
+	GP_LOG_D ("trying to get object size=0x%lx", (unsigned long)oi.ObjectCompressedSize);
+	C_PTP_REP (ptp_canon_eos_getpartialobject (params, newobject, 0, oi.ObjectCompressedSize, &ximage));
+	C_PTP_REP (ptp_canon_eos_transfercomplete (params, newobject));
+	ret = gp_file_set_data_and_size(file, (char*)ximage, oi.ObjectCompressedSize);
+	if (ret != GP_OK) {
+		gp_file_free (file);
+		return ret;
+	}
+	ret = gp_filesystem_append(camera->fs, path->folder, path->name, context);
+	if (ret != GP_OK) {
+		gp_file_free (file);
+		return ret;
+	}
+	ret = gp_filesystem_set_file_noop(camera->fs, path->folder, path->name, GP_FILE_TYPE_NORMAL, file, context);
+	if (ret != GP_OK) {
+		gp_file_free (file);
+		return ret;
+	}
+	/* We have now handed over the file, disclaim responsibility by unref. */
+	gp_file_unref (file);
+	return GP_OK;
+}
+
+static int
+_timeout_passed(struct timeval *start, int timeout) {
+	struct timeval curtime;
+
+	gettimeofday (&curtime, NULL);
+	return ((curtime.tv_sec - start->tv_sec)*1000)+((curtime.tv_usec - start->tv_usec)/1000) >= timeout;
+}
+
+static int
+camera_olympus_xml_capture (Camera *camera, CameraCaptureType type, CameraFilePath *path,
+		GPContext *context)
+{
+	uint16_t	ret;
+	int		res;
+	PTPParams	*params = &camera->pl->params;
+
+	GP_LOG_D ("olympus capture");
+
+	/* C_PTP (ptp_olympus_capture (params, 3)); */
+	C_PTP (ptp_generic_no_data (params, PTP_OC_OLYMPUS_Capture, 1, 3));
+
+	while (1) {
+		PTPContainer event;
+
+		ret = ptp_check_event(params);
+		if (ret != PTP_RC_OK)
+			break;
+
+		event.Code = 0;
+		while (ptp_get_one_event (params, &event)) {
+			GP_LOG_D ("capture 1: got event 0x%x (param1=%x)", event.Code, event.Param1);
+			if (event.Code == PTP_EC_Olympus_CaptureComplete) break;
+		}
+		if (event.Code == PTP_EC_Olympus_CaptureComplete)
+			break;
+	}
+	/* C_PTP (ptp_olympus_capture (params, 0)); */
+	C_PTP (ptp_generic_no_data (params, PTP_OC_OLYMPUS_Capture, 1, 0));
+
+	/* 0x1a000002 object id */
+	while (1) {
+		PTPContainer event;
+		uint32_t	assochandle = 0;
+
+		ret = ptp_check_event(params);
+		if (ret != PTP_RC_OK)
+			break;
+
+		event.Code = 0;
+		while (ptp_get_one_event (params, &event)) {
+			GP_LOG_D ("capture 2: got event 0x%x (param1=%x)", event.Code, event.Param1);
+			if (event.Code == PTP_EC_RequestObjectTransfer) {
+				PTPObjectInfo oi;
+
+				C_PTP_MSG (ptp_getobjectinfo (params, event.Param1, &oi),
+					   "capture 2: no objectinfo for 0x%x", event.Param1);
+				debug_objectinfo(params, event.Param1, &oi);
+				/* We get usually
+				 * 0x1a000001 - folder
+				 * 0x1a000002 - image within that folder
+				 */
+
+				/* remember for later deletion */
+				if (oi.ObjectFormat == PTP_OFC_Association) {
+					assochandle = event.Param1;
+					continue;
+				}
+
+				if (oi.ObjectFormat == PTP_OFC_EXIF_JPEG) {
+					static int capcnt = 0;
+					sprintf (path->folder,"/");
+					sprintf (path->name, "capt%04d.jpg", capcnt++);
+					res = add_objectid_and_upload (camera, path, context, event.Param1, &oi);
+
+					ret = ptp_deleteobject (params, event.Param1, PTP_OFC_EXIF_JPEG);
+					if (ret != PTP_RC_OK)
+						GP_LOG_E ("capture 2: delete image %08x, ret 0x%04x", event.Param1, ret);
+					ret = ptp_deleteobject (params, assochandle, PTP_OFC_Association);
+					if (ret != PTP_RC_OK)
+						GP_LOG_E ("capture 2: delete folder %08x, ret 0x%04x", assochandle, ret);
+					return res;
+				}
+				GP_LOG_E ("capture 2: unknown OFC 0x%04x for 0x%x", oi.ObjectFormat, event.Param1);
+			}
+		}
+	}
+	return GP_ERROR;
+}
+
+/* To use:
+ *	gphoto2 --set-config capture=on --config --capture-image
+ *	gphoto2  -f /store_80000001 -p 1
+ *		will download a file called "VirtualObject"
+ */
+static int
+camera_canon_capture (Camera *camera, CameraCaptureType type, CameraFilePath *path,
+		GPContext *context)
+{
+	static int 		capcnt = 0;
+	PTPObjectInfo		oi;
+	int			found, ret, timeout, sawcapturecomplete = 0, viewfinderwason = 0;
+	PTPParams		*params = &camera->pl->params;
+	uint32_t		newobject = 0x0;
+	PTPPropertyValue	propval;
+	PTPContainer		event;
+	char 			buf[1024];
+	int			xmode = CANON_TRANSFER_CARD;
+	struct timeval		event_start;
+
+	if (!ptp_operation_issupported(params, PTP_OC_CANON_InitiateCaptureInMemory)) {
+		gp_context_error (context,
+		_("Sorry, your Canon camera does not support Canon Capture initiation"));
+		return GP_ERROR_NOT_SUPPORTED;
+	}
+
+	/* did not call --set-config capture=on, do it for user */
+	CR (camera_prepare_capture (camera, context));
+
+	if (!params->canon_event_mode) {
+		propval.u16 = 0;
+	        ret = ptp_getdevicepropvalue(params, PTP_DPC_CANON_EventEmulateMode, &propval, PTP_DTC_UINT16);
+		if (ret == PTP_RC_OK) params->canon_event_mode = propval.u16;
+	}
+
+	if (ptp_property_issupported(params, PTP_DPC_CANON_CaptureTransferMode)) {
+		if ((GP_OK == gp_setting_get("ptp2","capturetarget",buf)) && !strcmp(buf,"sdram"))
+			propval.u16 = xmode = CANON_TRANSFER_MEMORY;
+		else
+			propval.u16 = xmode = CANON_TRANSFER_CARD;
+
+		if (xmode == CANON_TRANSFER_CARD) {
+			PTPStorageIDs storageids;
+
+			ret = ptp_getstorageids(params, &storageids);
+			if (ret == PTP_RC_OK) {
+				unsigned int k, stgcnt = 0;
+				for (k=0;k<storageids.n;k++) {
+					if (!(storageids.Storage[k] & 0xffff)) continue;
+					if (storageids.Storage[k] == 0x80000001) continue;
+					stgcnt++;
+				}
+				if (!stgcnt) {
+					GP_LOG_D ("Assuming no CF card present - switching to MEMORY Transfer.");
+					propval.u16 = xmode = CANON_TRANSFER_MEMORY;
+				}
+				free (storageids.Storage);
+			}
+		}
+		LOG_ON_PTP_E (ptp_setdevicepropvalue(params, PTP_DPC_CANON_CaptureTransferMode, &propval, PTP_DTC_UINT16));
+	}
+
+	if (params->canon_viewfinder_on) { /* disable during capture ... reenable later on. */
+		C_PTP_REP_MSG (ptp_canon_viewfinderoff (params),
+			       _("Canon disable viewfinder failed"));
+		viewfinderwason = 1;
+		params->canon_viewfinder_on = 0;
+	}
+	C_PTP_REP_MSG (ptp_check_event (params),
+		       _("Canon Capture failed"));
+
+#if 0
+	/* FIXME: For now, to avoid flash during debug */
+	propval.u8 = 0;
+	ret = ptp_setdevicepropvalue(params, PTP_DPC_CANON_FlashMode, &propval, PTP_DTC_UINT8);
+#endif
+	C_PTP_REP_MSG (ptp_canon_initiatecaptureinmemory (params),
+		       _("Canon Capture failed"));
+	sawcapturecomplete = 0;
+	/* Checking events in stack. */
+	gettimeofday (&event_start, NULL);
+	found = FALSE;
+
+	gp_port_get_timeout (camera->port, &timeout);
+	CR (gp_port_set_timeout (camera->port, capture_timeout));
+	while (!_timeout_passed(&event_start, capture_timeout)) {
+		gp_context_idle (context);
+		/* Make sure we do not poll USB interrupts after the capture complete event.
+		 * MacOS libusb 1 has non-timing out interrupts so we must avoid event reads that will not
+		 * result in anything.
+		 */
+		ret = ptp_check_event (params);
+		if (ret != PTP_RC_OK)
+			break;
+
+		if (!ptp_get_one_event (params, &event)) {
+			/* FIXME: wait a bit? */
+			usleep(20*1000);
+			continue;
+		}
+		GP_LOG_D ("Event: nparams=0x%X, code=0x%X, trans_id=0x%X, p1=0x%X, p2=0x%X, p3=0x%X", event.Nparam,event.Code,event.Transaction_ID, event.Param1, event.Param2, event.Param3);
+		switch (event.Code) {
+		case PTP_EC_ObjectAdded: {
+			/* add newly created object to internal structures. this hopefully just is a new folder */
+			PTPObject	*ob;
+
+			GP_LOG_D ("Event ObjectAdded, object handle=0x%X.", newobject);
+
+			ret = ptp_object_want (params, event.Param1, PTPOBJECT_OBJECTINFO_LOADED, &ob);
+			if (ret != PTP_RC_OK)
+				break;
+			/* this might be just the folder add, ignore that. */
+			if (ob->oi.ObjectFormat == PTP_OFC_Association) {
+				/* new directory ... mark fs as to be refreshed */
+				gp_filesystem_reset (camera->fs); /* FIXME: implement more lightweight folder add */
+				break;
+			} else {
+				/* new file */
+				newobject = event.Param1;
+				/* FALLTHROUGH */
+			}
+			/* FALLTHROUGH */
+		}
+		case PTP_EC_CANON_RequestObjectTransfer: {
+			int j;
+
+			newobject = event.Param1;
+			GP_LOG_D ("Event PTP_EC_CANON_RequestObjectTransfer, object handle=0x%X.", newobject);
+			/* drain the event queue further */
+			for (j=0;j<2;j++) {
+				ret = ptp_check_event (params);
+				while (ptp_get_one_event (params, &event) && !sawcapturecomplete) {
+					GP_LOG_D ("evdata: L=0x%X, C=0x%X, trans_id=0x%X, p1=0x%X, p2=0x%X, p3=0x%X", event.Nparam,event.Code,event.Transaction_ID, event.Param1, event.Param2, event.Param3);
+					if (event.Code == PTP_EC_CaptureComplete)
+						sawcapturecomplete = 1;
+				}
+				if (sawcapturecomplete)
+					break;
+				usleep(20*1000);
+			}
+			/* Marcus: Not sure if we really needs this. This refocuses the camera.
+			   ret = ptp_canon_reset_aeafawb(params,7);
+			 */
+			found = TRUE;
+			break;
+		}
+		case PTP_EC_CaptureComplete:
+			GP_LOG_D ("Event: Capture complete.");
+			sawcapturecomplete = 1;
+			break;
+		default:
+			GP_LOG_D ("Event unhandled: nparams=0x%X, code=0x%X, trans_id=0x%X, p1=0x%X, p2=0x%X, p3=0x%X",
+				event.Nparam, event.Code, event.Transaction_ID, event.Param1, event.Param2, event.Param3
+			);
+			break;
+		}
+		if (found == TRUE)
+			break;
+	}
+	CR (gp_port_set_timeout (camera->port, timeout));
+	/* Catch event, attempt 2 */
+	while (!sawcapturecomplete) {
+		ret = ptp_check_event (params);
+		if (ret != PTP_RC_OK)
+			break;
+		while (ptp_get_one_event (params, &event)) {
+			if (event.Code==PTP_EC_CaptureComplete) {
+				GP_LOG_D ("Event: capture complete(2).");
+				sawcapturecomplete = 1;
+				break;
+			}
+		}
+		/* FIXME: wait backoff */
+		GP_LOG_D ("Event: 0x%X (2)", event.Code);
+	}
+	if (!found) {
+	    GP_LOG_D ("ERROR: Capture timed out!");
+	    return GP_ERROR_TIMEOUT;
+	}
+	if (viewfinderwason) { /* disable during capture ... reenable later on. */
+		viewfinderwason = 0;
+		C_PTP_REP_MSG (ptp_canon_viewfinderon (params),
+			       _("Canon enable viewfinder failed"));
+		params->canon_viewfinder_on = 1;
+	}
+
+	/* FIXME: handle multiple images (as in BurstMode) */
+	C_PTP (ptp_getobjectinfo (params, newobject, &oi));
+
+	if (oi.ParentObject != 0) {
+		if (xmode != CANON_TRANSFER_CARD) {
+			fprintf (stderr,"parentobject is 0x%x, but not in card mode?\n", oi.ParentObject);
+		}
+		CR (add_object (camera, newobject, context));
+		strcpy  (path->name,  oi.Filename);
+		sprintf (path->folder,"/"STORAGE_FOLDER_PREFIX"%08lx/",(unsigned long)oi.StorageID);
+		get_folder_from_handle (camera, oi.StorageID, oi.ParentObject, path->folder);
+		/* delete last / or we get confused later. */
+		path->folder[ strlen(path->folder)-1 ] = '\0';
+		return gp_filesystem_append (camera->fs, path->folder, path->name, context);
+	} else {
+		if (xmode == CANON_TRANSFER_CARD) {
+			fprintf (stderr,"parentobject is 0, but not in memory mode?\n");
+		}
+		sprintf (path->folder,"/"STORAGE_FOLDER_PREFIX"%08lx",(unsigned long)oi.StorageID);
+		sprintf (path->name, "capt%04d.jpg", capcnt++);
+		return add_objectid_and_upload (camera, path, context, newobject, &oi);
+	}
+}
+
+
+static int
+camera_sony_capture (Camera *camera, CameraCaptureType type, CameraFilePath *path, GPContext *context)
+{
+	PTPParams	*params = &camera->pl->params;
+	PTPPropertyValue propval;
+	PTPContainer	event;
+	PTPObjectInfo	oi;
+	uint32_t	newobject = 0;
+	static int	capcnt = 0;
+	int		dual = 0;
+	PTPDevicePropDesc	dpd;
+	struct timeval	event_start;
+	int 		resttime;
+
+	propval.u16 = 1;
+	C_PTP (ptp_sony_setdevicecontrolvalueb (params, 0xD2C1, &propval, PTP_DTC_UINT16));
+
+	C_PTP (ptp_generic_getdevicepropdesc (params, PTP_DPC_CompressionSetting, &dpd));
+
+	GP_LOG_D ("dpd.CurrentValue.u8 = %x", dpd.CurrentValue.u8);
+	GP_LOG_D ("dpd.FactoryDefaultValue.u8 = %x", dpd.FactoryDefaultValue.u8);
+
+	if (dpd.CurrentValue.u8 == 0)
+		dpd.CurrentValue.u8 = dpd.FactoryDefaultValue.u8;
+	if (dpd.CurrentValue.u8 == 0x13) {
+		GP_LOG_D ("expecting raw+jpeg capture");
+		dual = 1;
+	}
+
+	propval.u16 = 2;
+	C_PTP (ptp_sony_setdevicecontrolvalueb (params, PTP_DPC_SONY_StillImage, &propval, PTP_DTC_UINT16));
+
+	gettimeofday (&event_start, NULL);
+	do {
+		struct timeval curtime;
+
+		C_PTP (ptp_check_event (params));
+		if (ptp_get_one_event(params, &event)) {
+			GP_LOG_D ("during event.code=%04x Param1=%08x", event.Code, event.Param1);
+			if (event.Code == PTP_EC_Sony_ObjectAdded) {
+				newobject = event.Param1;
+				if (dual)
+					ptp_add_event (params, &event);
+				break;
+			}
+		}
+		gettimeofday (&curtime, NULL);
+		resttime = ((curtime.tv_sec - event_start.tv_sec)*1000)+((curtime.tv_usec - event_start.tv_usec)/1000);
+		/* 30 seconds are maximum capture time currently, so use 30 seconds + 5 seconds image saving at most. */
+	} while (resttime < 35000);
+
+	propval.u16 = 1;
+	C_PTP (ptp_sony_setdevicecontrolvalueb (params, 0xD2C2, &propval, PTP_DTC_UINT16));
+
+	propval.u16 = 1;
+	C_PTP (ptp_sony_setdevicecontrolvalueb (params, 0xD2C1, &propval, PTP_DTC_UINT16));
+
+	if (!newobject) {
+		GP_LOG_E("no object found during event polling. try the 0xffffc001 object id");
+		newobject = 0xffffc001;
+	}
+	/* FIXME: handle multiple images (as in BurstMode) */
+	C_PTP (ptp_getobjectinfo (params, newobject, &oi));
+
+	sprintf (path->folder,"/");
+	if (oi.ObjectFormat == PTP_OFC_SONY_RAW)
+		sprintf (path->name, "capt%04d.arw", capcnt++);
+	else
+		sprintf (path->name, "capt%04d.jpg", capcnt++);
+	return add_objectid_and_upload (camera, path, context, newobject, &oi);
+}
+
+static int
+camera_capture (Camera *camera, CameraCaptureType type, CameraFilePath *path,
+		GPContext *context)
+{
+	PTPContainer event;
+	PTPParams *params = &camera->pl->params;
+	uint32_t newobject = 0x0;
+	int done,tries;
+	PTPObjectHandles	beforehandles;
+
+	/* adjust if we ever do sound or movie capture */
+	if (type != GP_CAPTURE_IMAGE)
+		return GP_ERROR_NOT_SUPPORTED;
+
+	SET_CONTEXT_P(params, context);
+	camera->pl->checkevents = TRUE;
+
+	/* first, draing existing events if the caller did not do it. */
+	while (ptp_get_one_event(params, &event)) {
+		GP_LOG_D ("draining unhandled event Code %04x, Param 1 %08x", event.Code, event.Param1);
+	}
+
+	/* 3rd gen style nikon capture, can do both sdram and card */
+	if (	(params->deviceinfo.VendorExtensionID == PTP_VENDOR_NIKON) &&
+		 ptp_operation_issupported(params, PTP_OC_NIKON_InitiateCaptureRecInMedia)
+	) {
+		char buf[1024];
+		int sdram = 0;
+
+		if ((GP_OK != gp_setting_get("ptp2","capturetarget",buf)) || !strcmp(buf,"sdram"))
+			sdram = 1;
+
+		return camera_nikon_capture (camera, type, path, 1, sdram, context);
+	}
+
+	/* 1st gen, 2nd gen nikon capture only go to SDRAM */
+	if (	(params->deviceinfo.VendorExtensionID == PTP_VENDOR_NIKON) &&
+		(ptp_operation_issupported(params, PTP_OC_NIKON_Capture) ||
+		 ptp_operation_issupported(params, PTP_OC_NIKON_AfCaptureSDRAM)
+	)) {
+		int ret = GP_ERROR_NOT_SUPPORTED;
+		char buf[1024];
+
+		if ((GP_OK != gp_setting_get("ptp2","capturetarget",buf)) || !strcmp(buf,"sdram"))
+			ret = camera_nikon_capture (camera, type, path, 1, 1, context);
+		if (ret != GP_ERROR_NOT_SUPPORTED)
+			 return ret;
+		/* for CARD capture and unsupported combinations, fall through */
+	}
+
+	if (params->device_flags & DEVICE_FLAG_OLYMPUS_XML_WRAPPED)
+		return camera_olympus_xml_capture (camera, type, path, context);
+
+	if (	(params->deviceinfo.VendorExtensionID == PTP_VENDOR_CANON) &&
+		ptp_operation_issupported(params, PTP_OC_CANON_InitiateCaptureInMemory)
+	) {
+		return camera_canon_capture (camera, type, path, context);
+	}
+
+	if (	(params->deviceinfo.VendorExtensionID == PTP_VENDOR_CANON) &&
+		ptp_operation_issupported(params, PTP_OC_CANON_EOS_RemoteRelease)
+	) {
+		return camera_canon_eos_capture (camera, type, path, context);
+	}
+
+	if (	(params->deviceinfo.VendorExtensionID == PTP_VENDOR_SONY) &&
+		ptp_operation_issupported(params, PTP_OC_SONY_SetControlDeviceB)
+	) {
+		return camera_sony_capture (camera, type, path, context);
+	}
+
+	if (!ptp_operation_issupported(params,PTP_OC_InitiateCapture)) {
+		gp_context_error(context,
+               	_("Sorry, your camera does not support generic capture"));
+		return GP_ERROR_NOT_SUPPORTED;
+	}
+
+	/* broken capture ... we detect what was captured using added objects
+	 * via the getobjecthandles array. here get the before state */
+	if ((params->deviceinfo.VendorExtensionID==PTP_VENDOR_NIKON) && NIKON_BROKEN_CAP(params))
+		C_PTP (ptp_getobjecthandles (params, PTP_HANDLER_SPECIAL, 0x000000, 0x000000, &beforehandles));
+
+	/* A capture may take longer than the standard 8 seconds.
+	 * The G5 for instance does, or in dark rooms ...
+	 * Even 16 seconds might not be enough. (Marcus)
+	 */
+	/* ptp_initiatecapture() returns immediately, only the event
+	 * indicating that the capure has been completed may occur after
+	 * few seconds. moving down the code. (kil3r)
+	 */
+	C_PTP_REP (ptp_initiatecapture(params, 0x00000000, 0x00000000));
+	CR (gp_port_set_timeout (camera->port, capture_timeout));
+	/* A word of comments is worth here.
+	 * After InitiateCapture camera should report with ObjectAdded event
+	 * all newly created objects. However there might be more than one
+	 * newly created object. There a two scenarios here, which may occur
+	 * both at the time.
+	 * 1) InitiateCapture trigers capture of more than one object if the
+	 * camera is in burst mode for example.
+	 * 2) InitiateCapture creates a number of objects, but not all
+	 * objects represents images. This happens when the camera creates a
+	 * folder for newly captured image(s). This may happen with the
+	 * fresh, formatted flashcard or in burs mode if the camera is
+	 * configured to create a dedicated folder for a burst of pictures.
+	 * The newly created folder (an association object) is reported
+	 * before the images that are stored after its creation.
+	 * Thus we set CameraFilePath to the path to last object reported by
+	 * the camera.
+	 */
+
+	/* The Nikon way: Does not send AddObject event ... so try to detect it by checking what objects
+	 * were added. */
+	if ((params->deviceinfo.VendorExtensionID==PTP_VENDOR_NIKON) && NIKON_BROKEN_CAP(params)) {
+		PTPObjectHandles	handles;
+
+		tries = 5;
+            	GP_LOG_D ("PTPBUG_NIKON_BROKEN_CAPTURE bug workaround");
+		while (tries--) {
+			unsigned int i;
+			uint16_t ret = ptp_getobjecthandles (params, PTP_HANDLER_SPECIAL, 0x000000, 0x000000, &handles);
+			if (ret != PTP_RC_OK)
+				break;
+
+			/* if (handles.n == params->handles.n)
+			 *	continue;
+			 * While this is a potential optimization, lets skip it for now.
+			 */
+			newobject = 0;
+			for (i=0;i<handles.n;i++) {
+				unsigned int 	j;
+				PTPObject	*ob;
+
+				/* look if we saw the objecthandle before capture */
+				for (j=0;j<beforehandles.n;j++)
+					if (beforehandles.Handler[j] == handles.Handler[i])
+						break;
+				if (j != beforehandles.n)
+					continue;
+
+				ret = ptp_object_want (params, handles.Handler[i], PTPOBJECT_OBJECTINFO_LOADED, &ob);
+				if (ret != PTP_RC_OK) {
+					GP_LOG_E ("object added, but not found?");
+					continue;
+				}
+				/* A directory was added, like initial DCIM/100NIKON or so. */
+				if (ob->oi.ObjectFormat == PTP_OFC_Association)
+					continue;
+				newobject = handles.Handler[i];
+				/* we found a new file */
+				break;
+			}
+			free (handles.Handler);
+			if (newobject)
+				break;
+			C_PTP_REP (ptp_check_event (params));
+			sleep(1);
+		}
+		free (beforehandles.Handler);
+		if (!newobject)
+            		GP_LOG_D ("PTPBUG_NIKON_BROKEN_CAPTURE no new file found after 5 seconds?!?");
+		goto out;
+	}
+
+	CR (gp_port_set_timeout (camera->port, normal_timeout));
+
+	/* The standard defined way ... wait for some capture related events. */
+	/* The Nikon 1 series emits ObjectAdded occasionaly after
+	 * the CaptureComplete event, while others do it the other way
+	 * round. Handle that case with some bitmask. */
+	done = 0; tries = 20;
+	while (done != 3) {
+		uint16_t ret;
+
+		C_PTP_REP (ptp_wait_event (params));
+
+		if (!ptp_get_one_event(params, &event)) {
+			usleep(1000);
+			if (done & 1) /* only wait 20 rounds for objectadded */
+				if (!tries--)
+					break;
+			continue;
+		}
+		GP_LOG_D ("event.Code is %04x / param %08x", event.Code, event.Param1);
+
+		switch (event.Code) {
+		case PTP_EC_ObjectRemoved:
+			/* Perhaps from previous Canon based capture + delete. Ignore. */
+			break;
+		case PTP_EC_ObjectAdded: {
+			PTPObject	*ob;
+
+			/* add newly created object to internal structures */
+			ret = ptp_object_want (params, event.Param1, PTPOBJECT_OBJECTINFO_LOADED, &ob);
+			if (ret != PTP_RC_OK)
+				break;
+
+			/* this might be just the folder add, ignore that. */
+			if (ob->oi.ObjectFormat == PTP_OFC_Association) {
+				/* new directory ... mark fs as to be refreshed */
+				gp_filesystem_reset (camera->fs);
+			} else {
+				newobject = event.Param1;
+				done |= 2;
+				if (NO_CAPTURE_COMPLETE(params))
+					done|=1;
+			}
+			break;
+		}
+		case PTP_EC_CaptureComplete:
+			done |= 1;
+			break;
+		default:
+			GP_LOG_D ("Received event 0x%04x, ignoring (please report).",event.Code);
+			/* done = 1; */
+			break;
+		}
+	}
+out:
+	/* clear path, so we get defined results even without object info */
+	path->name[0]='\0';
+	path->folder[0]='\0';
+
+	if (newobject != 0) {
+		PTPObject	*ob;
+
+		C_PTP_REP (ptp_object_want (params, newobject, PTPOBJECT_OBJECTINFO_LOADED, &ob));
+		strcpy  (path->name,  ob->oi.Filename);
+		sprintf (path->folder,"/"STORAGE_FOLDER_PREFIX"%08lx/",(unsigned long)ob->oi.StorageID);
+		get_folder_from_handle (camera, ob->oi.StorageID, ob->oi.ParentObject, path->folder);
+		/* delete last / or we get confused later. */
+		path->folder[ strlen(path->folder)-1 ] = '\0';
+		return gp_filesystem_append (camera->fs, path->folder, path->name, context);
+	}
+	return GP_ERROR;
+}
+
+static int
+camera_trigger_capture (Camera *camera, GPContext *context)
+{
+	PTPParams *params = &camera->pl->params;
+	uint16_t	ret;
+	char buf[1024];
+	int sdram = 0;
+
+
+	SET_CONTEXT_P(params, context);
+
+	/* If there is no capturetarget set yet, the default is "sdram" */
+	if (GP_OK != gp_setting_get("ptp2","capturetarget",buf))
+		strcpy (buf, "sdram");
+
+	if (!strcmp(buf,"sdram"))
+		sdram = 1;
+
+	GP_LOG_D ("Triggering capture to %s", buf);
+
+	/* Nilon V and J seem to like that */
+	if (	(params->deviceinfo.VendorExtensionID == PTP_VENDOR_NIKON) &&
+		!params->controlmode &&
+		ptp_operation_issupported(params,PTP_OC_NIKON_SetControlMode)
+	) {
+		ret = ptp_nikon_setcontrolmode (params, 1);
+		/* FIXME: PTP_RC_NIKON_ChangeCameraModeFailed does not seem to be problematic */
+		if (ret != PTP_RC_NIKON_ChangeCameraModeFailed)
+			C_PTP_REP (ret);
+		params->controlmode = 1;
+	}
+
+	/* On Nikon 1 series, the liveview must be enabled before capture works */
+	if (NIKON_1(params))
+		C_PTP_REP_MSG (ptp_nikon_start_liveview (params),
+			       _("Failed to enable liveview on a Nikon 1, but it is required for capture"));
+
+
+	/* Nikon 2 */
+	if (	(params->deviceinfo.VendorExtensionID == PTP_VENDOR_NIKON) &&
+		ptp_operation_issupported(params, PTP_OC_NIKON_InitiateCaptureRecInMedia)
+	) {
+		/* If in liveview mode, we have to run non-af capture */
+		int inliveview = 0;
+		PTPPropertyValue propval;
+
+		C_PTP_REP (ptp_check_event (params));
+		while (PTP_RC_DeviceBusy == ptp_nikon_device_ready (params));
+		C_PTP_REP (ptp_check_event (params));
+
+		if (ptp_property_issupported (params, PTP_DPC_NIKON_LiveViewStatus)) {
+			ret = ptp_getdevicepropvalue (params, PTP_DPC_NIKON_LiveViewStatus, &propval, PTP_DTC_UINT8);
+			if (ret == PTP_RC_OK)
+				inliveview = propval.u8;
+		}
+
+		do {
+			ret = ptp_nikon_capture2 (params, !inliveview, sdram);
+			if ((ret != PTP_RC_OK) && (ret != PTP_RC_DeviceBusy))
+				return translate_ptp_result (ret);
+			if (ret == PTP_RC_DeviceBusy) usleep(2000);
+			/* sleep a bit perhaps ? or check events? */
+		} while (ret == PTP_RC_DeviceBusy);
+
+		while (PTP_RC_DeviceBusy == ptp_nikon_device_ready (params)) {
+			gp_context_idle (context);
+			/* do not drain all of the DSLRs compute time */
+			usleep(100*1000); /* 0.1 seconds */
+		}
+		return GP_OK;
+	}
+
+	/* Nikon */
+	if (	(params->deviceinfo.VendorExtensionID == PTP_VENDOR_NIKON) &&
+		(ptp_operation_issupported(params, PTP_OC_NIKON_Capture) ||
+		 ptp_operation_issupported(params, PTP_OC_NIKON_AfCaptureSDRAM) 
+		)
+		&& sdram
+	) {
+		/* If in liveview mode, we have to run non-af capture */
+		int inliveview = 0;
+		PTPPropertyValue propval;
+
+		C_PTP_REP (ptp_check_event (params));
+		C_PTP_REP (nikon_wait_busy (params, 20, 1000));
+		C_PTP_REP (ptp_check_event (params));
+
+		if (ptp_property_issupported (params, PTP_DPC_NIKON_LiveViewStatus)) {
+			ret = ptp_getdevicepropvalue (params, PTP_DPC_NIKON_LiveViewStatus, &propval, PTP_DTC_UINT8);
+			if (ret == PTP_RC_OK)
+				inliveview = propval.u8;
+		}
+
+		do {
+			if (!inliveview && ptp_operation_issupported (params,PTP_OC_NIKON_AfCaptureSDRAM))
+				ret = ptp_nikon_capture_sdram (params);
+			else
+				ret = ptp_nikon_capture (params, 0xffffffff);
+			if ((ret != PTP_RC_OK) && (ret != PTP_RC_DeviceBusy))
+				return translate_ptp_result (ret);
+		} while (ret == PTP_RC_DeviceBusy);
+
+		while (PTP_RC_DeviceBusy == ptp_nikon_device_ready (params)) {
+			gp_context_idle (context);
+			/* do not drain all of the DSLRs compute time */
+			usleep(100*1000); /* 0.1 seconds */
+		}
+
+		return GP_OK;
+	}
+
+	/* Canon EOS */
+	/* Newer EOS starting with 100D, 1200D, 600D, 5d MarkII+, 60D, 70D, 6D ... and newer */
+	if ((params->deviceinfo.VendorExtensionID == PTP_VENDOR_CANON) &&
+	     ptp_operation_issupported(params, PTP_OC_CANON_EOS_RemoteReleaseOn)) {
+		int 		oneloop;
+
+		if (!params->eos_captureenabled)
+			camera_prepare_capture (camera, context);
+		else
+			CR( camera_canon_eos_update_capture_target(camera, context, -1));
+
+		/* Get the initial bulk set of event data, otherwise
+		 * capture might return busy. */
+		C_PTP (ptp_check_eos_events (params));
+
+		if (params->eos_camerastatus == 1)
+			return GP_ERROR_CAMERA_BUSY;
+
+		ret = GP_OK;
+		/* half press now - initiate focusing and wait for result */
+		C_PTP_REP_MSG (ptp_canon_eos_remotereleaseon (params, 1, 0), _("Canon EOS Half-Press failed"));
+
+		do {
+			PTPCanon_changes_entry	entry;
+			int foundfocusinfo = 0;
+
+			C_PTP_REP_MSG (ptp_check_eos_events (params),
+			       _("Canon EOS Get Changes failed"));
+			oneloop = 0;
+			while (ptp_get_one_eos_event (params, &entry)) {
+				oneloop = 1;
+				GP_LOG_D("focusing - read event type %d", entry.type);
+				if (entry.type == PTP_CANON_EOS_CHANGES_TYPE_FOCUSINFO) {
+					GP_LOG_D("focusinfo content: %s", entry.u.info);
+					foundfocusinfo = 1;
+					if (strstr(entry.u.info,"0000200")) {
+						gp_context_error (context, _("Canon EOS Capture failed to release: Perhaps no focus?"));
+						ret = GP_ERROR;
+					}
+				}
+			}
+			if (foundfocusinfo)
+				break;
+		} while (oneloop);
+
+		if (ret != GP_OK) {
+			C_PTP_REP_MSG (ptp_canon_eos_remotereleaseoff (params, 1), _("Canon EOS Half-Release failed"));
+			return ret;
+		}
+		/* full press now */
+
+		C_PTP_REP_MSG (ptp_canon_eos_remotereleaseon (params, 2, 0), _("Canon EOS Full-Press failed"));
+		/* no event check between */
+		/* full release now */
+		C_PTP_REP_MSG (ptp_canon_eos_remotereleaseoff (params, 2), _("Canon EOS Full-Release failed"));
+		ptp_check_eos_events (params);
+
+		/* half release now */
+		C_PTP_REP_MSG (ptp_canon_eos_remotereleaseoff (params, 1), _("Canon EOS Half-Release failed"));
+
+		return GP_OK;
+	}
+	/* Slightly older EOS, EOS 400D */
+	if ((params->deviceinfo.VendorExtensionID == PTP_VENDOR_CANON) &&
+	     ptp_operation_issupported(params, PTP_OC_CANON_EOS_RemoteRelease)) {
+		uint32_t	result;
+		int tries = 10;
+
+		if (!params->eos_captureenabled)
+			camera_prepare_capture (camera, context);
+		else
+			CR( camera_canon_eos_update_capture_target(camera, context, -1));
+
+		/* Get the initial bulk set of event data, otherwise
+		 * capture might return busy. */
+		C_PTP (ptp_check_eos_events (params));
+
+		if (params->eos_camerastatus == 1)
+			return GP_ERROR_CAMERA_BUSY;
+
+		C_PTP_REP_MSG (ptp_canon_eos_capture (params, &result),
+			       _("Canon EOS Trigger Capture failed: 0x%x"), result);
+
+		if ((result & 0x7000) == 0x2000) { /* also happened */
+			gp_context_error (context, _("Canon EOS Trigger Capture failed: 0x%x"), result);
+			return translate_ptp_result (result);
+		}
+		GP_LOG_D ("result is %d", result);
+		switch (result) {
+		case 0: /* OK */
+			break;
+		case 1: gp_context_error (context, _("Canon EOS Capture failed to release: Perhaps no focus?"));
+			return GP_ERROR;
+		case 3: gp_context_error (context, _("Canon EOS Capture failed to release: Perhaps mirror up?"));
+			return GP_ERROR;
+		case 7: gp_context_error (context, _("Canon EOS Capture failed to release: Perhaps no more memory on card?"));
+			return GP_ERROR_NO_MEMORY;
+		case 8: gp_context_error (context, _("Canon EOS Capture failed to release: Card read-only?"));
+			return GP_ERROR_NO_MEMORY;
+		default:gp_context_error (context, _("Canon EOS Capture failed to release: Unknown error %d, please report."), result);
+			return GP_ERROR;
+		}
+
+		/* wait until camera reports busy ... */
+		do {
+			ret = ptp_check_eos_events (params);
+			if (ret != PTP_RC_OK)
+				break;
+			usleep(2000);
+			GP_LOG_D ("eos_camerastatus is %d", params->eos_camerastatus);
+		} while (tries-- && (params->eos_camerastatus != 1));
+
+		return GP_OK;
+	}
+	if (	(params->deviceinfo.VendorExtensionID == PTP_VENDOR_CANON) &&
+		ptp_operation_issupported(params, PTP_OC_CANON_InitiateCaptureInMemory)
+	) {
+		uint16_t xmode;
+		/*int viewfinderwason = 0;*/
+		PTPPropertyValue propval;
+
+		if (!ptp_property_issupported(params, PTP_DPC_CANON_FlashMode)) {
+			/* did not call --set-config capture=on, do it for user */
+			CR (camera_prepare_capture (camera, context));
+			if (!ptp_property_issupported(params, PTP_DPC_CANON_FlashMode)) {
+				gp_context_error (context,
+				_("Sorry, initializing your camera did not work. Please report this."));
+				return GP_ERROR_NOT_SUPPORTED;
+			}
+		}
+
+		if (ptp_property_issupported(params, PTP_DPC_CANON_CaptureTransferMode)) {
+			if (sdram)
+				propval.u16 = xmode = CANON_TRANSFER_MEMORY;
+			else
+				propval.u16 = xmode = CANON_TRANSFER_CARD;
+
+			if (xmode == CANON_TRANSFER_CARD) {
+				PTPStorageIDs storageids;
+
+				ret = ptp_getstorageids(params, &storageids);
+				if (ret == PTP_RC_OK) {
+					unsigned int k, stgcnt = 0;
+
+					for (k=0;k<storageids.n;k++) {
+						if (!(storageids.Storage[k] & 0xffff)) continue;
+						if (storageids.Storage[k] == 0x80000001) continue;
+						stgcnt++;
+					}
+					if (!stgcnt) {
+						GP_LOG_D ("Assuming no CF card present - switching to MEMORY Transfer.");
+						propval.u16 = xmode = CANON_TRANSFER_MEMORY;
+					}
+					free (storageids.Storage);
+				}
+			}
+			LOG_ON_PTP_E (ptp_setdevicepropvalue(params, PTP_DPC_CANON_CaptureTransferMode, &propval, PTP_DTC_UINT16));
+		}
+
+		if (params->canon_viewfinder_on) { /* disable during capture ... reenable later on. */
+			C_PTP_REP_MSG (ptp_canon_viewfinderoff (params),
+				       _("Canon disable viewfinder failed"));
+			/*viewfinderwason = 1;*/
+			params->canon_viewfinder_on = 0;
+		}
+
+	#if 0
+		/* FIXME: For now, to avoid flash during debug */
+		propval.u8 = 0;
+		ret = ptp_setdevicepropvalue(params, PTP_DPC_CANON_FlashMode, &propval, PTP_DTC_UINT8);
+	#endif
+		while (1) {
+			ret = ptp_canon_initiatecaptureinmemory (params);
+			if (ret == PTP_RC_OK)
+				break;
+			if (ret == PTP_RC_DeviceBusy) {
+				GP_LOG_D ("Canon Powershot busy ... retrying...");
+				gp_context_idle (context);
+				ptp_check_event (params);
+				usleep(10000); /* 10 ms  ... fixme: perhaps experimental backoff? */
+				continue;
+			}
+			C_PTP_REP_MSG (ret, _("Canon Capture failed"));
+		}
+		GP_LOG_D ("Canon Powershot capture triggered...");
+		return GP_OK;
+	}
+	
+
+#if 0
+	if (	(params->deviceinfo.VendorExtensionID == PTP_VENDOR_CANON) &&
+		ptp_operation_issupported(params, PTP_OC_CANON_EOS_RemoteRelease)
+	) {
+		return camera_canon_eos_capture (camera, type, path, context);
+	}
+#endif
+	if (!ptp_operation_issupported(params,PTP_OC_InitiateCapture)) {
+		gp_context_error(context,
+               	_("Sorry, your camera does not support generic capture"));
+		return GP_ERROR_NOT_SUPPORTED;
+	}
+	C_PTP_REP (ptp_initiatecapture(params, 0x00000000, 0x00000000));
+	return GP_OK;
+}
+
+static int
+camera_wait_for_event (Camera *camera, int timeout,
+		       CameraEventType *eventtype, void **eventdata,
+		       GPContext *context) {
+	PTPContainer	event;
+	PTPParams	*params = &camera->pl->params;
+	uint32_t	newobject = 0x0;
+	CameraFilePath	*path;
+	static int 	capcnt = 0;
+	uint16_t	ret;
+	struct timeval	event_start;
+	CameraFile	*file;
+	char		*ximage;
+	int		sleepcnt = 1;
+
+	SET_CONTEXT(camera, context);
+	GP_LOG_D ("waiting for events timeout %d ms", timeout);
+	memset (&event, 0, sizeof(event));
+	*eventtype = GP_EVENT_TIMEOUT;
+	*eventdata = NULL;
+
+	if (params->device_flags & DEVICE_FLAG_OLYMPUS_XML_WRAPPED) {
+		GP_LOG_D ("olympus setcameracontrolmode 2\n");
+		ptp_olympus_setcameracontrolmode (params, 2);
+	}
+
+	gettimeofday (&event_start,NULL);
+	if (	(params->deviceinfo.VendorExtensionID == PTP_VENDOR_CANON) &&
+		ptp_operation_issupported(params, PTP_OC_CANON_EOS_RemoteRelease)
+	) {
+		if (!params->eos_captureenabled)
+			camera_prepare_capture (camera, context);
+		while (1) {
+			int i;
+			PTPCanon_changes_entry	entry;
+
+			/* keep device alive */
+			C_PTP (ptp_canon_eos_keepdeviceon (params));
+
+			C_PTP_REP_MSG (ptp_check_eos_events (params),
+				       _("Canon EOS Get Changes failed"));
+			while (ptp_get_one_eos_event (params, &entry)) {
+				sleepcnt = 1;
+				GP_LOG_D ("entry type %04x", entry.type);
+				switch (entry.type) {
+				case PTP_CANON_EOS_CHANGES_TYPE_OBJECTTRANSFER:
+					GP_LOG_D ("Found new object! OID 0x%x, name %s", (unsigned int)entry.u.object.oid, entry.u.object.oi.Filename);
+					free (entry.u.object.oi.Filename);
+
+					newobject = entry.u.object.oid;
+
+					C_MEM (path = malloc(sizeof(CameraFilePath)));
+					path->name[0]='\0';
+					strcpy (path->folder,"/");
+					ret = gp_file_new(&file);
+					if (ret!=GP_OK) return ret;
+					sprintf (path->name, "capt%04d.", capcnt++);
+					if ((entry.u.object.oi.ObjectFormat == PTP_OFC_CANON_CRW) || (entry.u.object.oi.ObjectFormat == PTP_OFC_CANON_CRW3)) {
+						strcat(path->name, "cr2");
+						gp_file_set_mime_type (file, GP_MIME_CRW);
+					} else {
+						strcat(path->name, "jpg");
+						gp_file_set_mime_type (file, GP_MIME_JPEG);
+					}
+					gp_file_set_mtime (file, time(NULL));
+
+					GP_LOG_D ("trying to get object size=0x%lx", (unsigned long)entry.u.object.oi.ObjectCompressedSize);
+					C_PTP_REP (ptp_canon_eos_getpartialobject (params, newobject, 0, entry.u.object.oi.ObjectCompressedSize, (unsigned char**)&ximage));
+					C_PTP_REP (ptp_canon_eos_transfercomplete (params, newobject));
+					ret = gp_file_set_data_and_size(file, (char*)ximage, entry.u.object.oi.ObjectCompressedSize);
+					if (ret != GP_OK) {
+						gp_file_free (file);
+						return ret;
+					}
+					ret = gp_filesystem_append(camera->fs, path->folder, path->name, context);
+					if (ret != GP_OK) {
+						gp_file_free (file);
+						return ret;
+					}
+					ret = gp_filesystem_set_file_noop(camera->fs, path->folder, path->name, GP_FILE_TYPE_NORMAL, file, context);
+					if (ret != GP_OK) {
+						gp_file_free (file);
+						return ret;
+					}
+					*eventtype = GP_EVENT_FILE_ADDED;
+					*eventdata = path;
+					/* We have now handed over the file, disclaim responsibility by unref. */
+					gp_file_unref (file);
+					return GP_OK;
+				case PTP_CANON_EOS_CHANGES_TYPE_OBJECTINFO:
+					/* just add it to the filesystem, and return in CameraPath */
+					GP_LOG_D ("Found new objectinfo! OID 0x%x, name %s", (unsigned int)entry.u.object.oid, entry.u.object.oi.Filename);
+					newobject = entry.u.object.oid;
+					add_object (camera, newobject, context);
+					C_MEM (path = malloc(sizeof(CameraFilePath)));
+					strcpy  (path->name,  entry.u.object.oi.Filename);
+					free (entry.u.object.oi.Filename);
+					sprintf (path->folder,"/"STORAGE_FOLDER_PREFIX"%08lx/",(unsigned long)entry.u.object.oi.StorageID);
+					get_folder_from_handle (camera, entry.u.object.oi.StorageID, entry.u.object.oi.ParentObject, path->folder);
+					/* delete last / or we get confused later. */
+					path->folder[ strlen(path->folder)-1 ] = '\0';
+					gp_filesystem_append (camera->fs, path->folder, path->name, context);
+					*eventtype = GP_EVENT_FILE_ADDED;
+					*eventdata = path;
+					return GP_OK;
+				case PTP_CANON_EOS_CHANGES_TYPE_PROPERTY:
+					*eventtype = GP_EVENT_UNKNOWN;
+					C_MEM (*eventdata = malloc(strlen("PTP Property 0123 changed")+1));
+					sprintf (*eventdata, "PTP Property %04x changed", entry.u.propid);
+					return GP_OK;
+				case PTP_CANON_EOS_CHANGES_TYPE_CAMERASTATUS:
+					/* if we do capture stuff, camerastatus will turn to 0 when done */
+					*eventtype = GP_EVENT_UNKNOWN;
+					C_MEM (*eventdata = malloc(strlen("Camera Status 123456789012345")+1));
+					sprintf (*eventdata, "Camera Status %d", entry.u.status);
+					return GP_OK;
+				case PTP_CANON_EOS_CHANGES_TYPE_FOCUSINFO:
+					*eventtype = GP_EVENT_UNKNOWN;
+					C_MEM (*eventdata = malloc(strlen("Focus Info 12345678901234567890123456789")+1));
+					sprintf (*eventdata, "Focus Info %s", entry.u.info);
+					break;
+				case PTP_CANON_EOS_CHANGES_TYPE_FOCUSMASK:
+					*eventtype = GP_EVENT_UNKNOWN;
+					C_MEM (*eventdata = malloc(strlen("Focus Mask 12345678901234567890123456789")+1));
+					sprintf (*eventdata, "Focus Mask %s", entry.u.info);
+					break;
+				case PTP_CANON_EOS_CHANGES_TYPE_UNKNOWN:
+					/* only return if interesting stuff happened */
+					if (entry.u.info) {
+						*eventtype = GP_EVENT_UNKNOWN;
+						*eventdata = entry.u.info; /* take over the allocated string allocation ownership */
+						return GP_OK;
+					}
+					/* continue otherwise */
+					break;
+				default:
+					GP_LOG_D ("Unhandled EOS event 0x%04x", entry.type);
+					break;
+				}
+			}
+			if (_timeout_passed (&event_start, timeout))
+				break;
+			/* incremental backoff of polling ... but only if we do not pass the wait time */
+			for (i=sleepcnt;i--;) {
+				int resttime;
+				struct timeval curtime;
+
+				gp_context_idle (context);
+				gettimeofday (&curtime, 0);
+				resttime = ((curtime.tv_sec - event_start.tv_sec)*1000)+((curtime.tv_usec - event_start.tv_usec)/1000);
+				resttime = timeout - resttime;
+				if (resttime <= 0)
+					break;
+				/* Try not to sleep for more than 20ms at a time */
+				if (resttime > 50)
+				  	resttime = 50;
+				usleep(resttime*1000);
+			}
+			sleepcnt++; /* incremental back off */
+			if (sleepcnt>4) sleepcnt=4;
+		}
+		*eventtype = GP_EVENT_TIMEOUT;
+		return GP_OK;
+	}
+
+	if (	(params->deviceinfo.VendorExtensionID == PTP_VENDOR_CANON) &&
+		ptp_operation_issupported(params, PTP_OC_CANON_CheckEvent)
+	) {
+		while (1) {
+			C_PTP_REP (ptp_check_event (params));
+			if (ptp_get_one_event(params, &event)) {
+				GP_LOG_D ("canon event: nparam=0x%X, C=0x%X, trans_id=0x%X, p1=0x%X, p2=0x%X, p3=0x%X", event.Nparam,event.Code,event.Transaction_ID, event.Param1, event.Param2, event.Param3);
+				switch (event.Code) {
+				case PTP_EC_CANON_RequestObjectTransfer: {
+					PTPObjectInfo	oi;
+
+					newobject = event.Param1;
+					GP_LOG_D ("PTP_EC_CANON_RequestObjectTransfer, object handle=0x%X.",newobject);
+					/* FIXME: handle multiple images (as in BurstMode) */
+					C_PTP (ptp_getobjectinfo (params, newobject, &oi));
+
+					if (oi.ParentObject != 0) {
+						CR (add_object (camera, newobject, context));
+						C_MEM (path = malloc (sizeof(CameraFilePath)));
+						strcpy  (path->name,  oi.Filename);
+						sprintf (path->folder,"/"STORAGE_FOLDER_PREFIX"%08lx/",(unsigned long)oi.StorageID);
+						get_folder_from_handle (camera, oi.StorageID, oi.ParentObject, path->folder);
+						/* delete last / or we get confused later. */
+						path->folder[ strlen(path->folder)-1 ] = '\0';
+						gp_filesystem_append (camera->fs, path->folder, path->name, context);
+
+					} else {
+						C_MEM (path = malloc (sizeof(CameraFilePath)));
+						sprintf (path->folder,"/"STORAGE_FOLDER_PREFIX"%08lx",(unsigned long)oi.StorageID);
+						sprintf (path->name, "capt%04d.jpg", capcnt++);
+						add_objectid_and_upload (camera, path, context, newobject, &oi);
+					}
+					*eventdata = path;
+					*eventtype = GP_EVENT_FILE_ADDED;
+					return GP_OK;
+				}
+				case PTP_EC_CANON_ShutterButtonPressed0:
+				case PTP_EC_CANON_ShutterButtonPressed1:
+				{
+					C_MEM (path = malloc(sizeof(CameraFilePath)));
+					ret = camera_canon_capture (camera, GP_CAPTURE_IMAGE, path, context);
+					if (ret != GP_OK) {
+						free (path);
+						break;
+					}
+					*eventdata = path;
+					*eventtype = GP_EVENT_FILE_ADDED;
+					return GP_OK;
+				}
+				default:
+					break;
+				}
+				goto handleregular;
+			}
+			if (_timeout_passed (&event_start, timeout))
+				break;
+			gp_context_idle (context);
+		}
+		*eventtype = GP_EVENT_TIMEOUT;
+		return GP_OK;
+	}
+
+	if (	(params->deviceinfo.VendorExtensionID == PTP_VENDOR_NIKON) &&
+		ptp_operation_issupported(params, PTP_OC_NIKON_CheckEvent)
+	) {
+		do {
+			C_PTP_REP (ptp_check_event (params));
+			if (!ptp_get_one_event (params, &event)) {
+				int i;
+
+				if (_timeout_passed (&event_start, timeout))
+					break;
+				/* incremental backoff wait ... including this wait loop, will go up to 200ms. */
+				for (i=sleepcnt;i--;) {
+					int resttime;
+					struct timeval curtime;
+
+					gp_context_idle (context);
+					gettimeofday (&curtime, 0);
+					resttime = ((curtime.tv_sec - event_start.tv_sec)*1000)+((curtime.tv_usec - event_start.tv_usec)/1000);
+					if (resttime <= 0)
+						break;
+					if (resttime > 50)
+						resttime = 50;
+					usleep(resttime*1000); /* at most 50 ms */
+				}
+				sleepcnt++; /* incremental back off */
+				if (sleepcnt>4) sleepcnt = 4;
+				continue;
+			}
+			sleepcnt = 1;
+
+			GP_LOG_D ("event.Code is %x / param %lx", event.Code, (unsigned long)event.Param1);
+			switch (event.Code) {
+			case PTP_EC_ObjectAdded: {
+				PTPObject	*ob;
+				uint16_t	ofc;
+
+				if (!event.Param1 || (event.Param1 == 0xffff0001))
+					goto downloadnow;
+
+#if 0
+				/* if we have the object already loaded, no need to add it here */
+				/* but in dual mode capture at empty startup we can
+				 * encounter that the second image is not loaded */
+				if (PTP_RC_OK == ptp_object_find(params, event.Param1, &ob))
+					continue;
+#endif
+
+				ret = ptp_object_want (params, event.Param1, PTPOBJECT_OBJECTINFO_LOADED, &ob);
+				if (ret != PTP_RC_OK) {
+					*eventtype = GP_EVENT_UNKNOWN;
+					C_MEM (*eventdata = strdup ("object added not found (already deleted)"));
+					break;
+				}
+				debug_objectinfo(params, event.Param1, &ob->oi);
+
+				C_MEM (path = malloc(sizeof(CameraFilePath)));
+				path->name[0]='\0';
+				path->folder[0]='\0';
+
+				ofc = ob->oi.ObjectFormat;
+				/* ob might be invalidated by get_folder_from_handle */
+
+				if (ob->oi.StorageID == 0) {
+					/* We would always get the same filename,
+					 * which will confuse the frontends */
+					if (strstr(ob->oi.Filename,".NEF"))
+						sprintf (path->name, "capt%04d.nef", capcnt++);
+					else
+						sprintf (path->name, "capt%04d.jpg", capcnt++);
+					free (ob->oi.Filename);
+					C_MEM (ob->oi.Filename = strdup (path->name));
+					strcpy (path->folder,"/");
+					goto downloadnow;
+				} else {
+					strcpy  (path->name,  ob->oi.Filename);
+					sprintf (path->folder,"/"STORAGE_FOLDER_PREFIX"%08lx/",(unsigned long)ob->oi.StorageID);
+					get_folder_from_handle (camera, ob->oi.StorageID, ob->oi.ParentObject, path->folder);
+					path->folder[ strlen(path->folder)-1 ] = '\0';
+				}
+				/* ob pointer can be invalid now! */
+				/* delete last / or we get confused later. */
+				if (ofc == PTP_OFC_Association) { /* new folder! */
+					*eventtype = GP_EVENT_FOLDER_ADDED;
+					*eventdata = path;
+					gp_filesystem_reset (camera->fs); /* FIXME: implement more lightweight folder add */
+					/* if this was the last current event ... stop and return the folder add */
+					return GP_OK;
+				} else {
+					CR (gp_filesystem_append (camera->fs, path->folder,
+								  path->name, context));
+					*eventtype = GP_EVENT_FILE_ADDED;
+					*eventdata = path;
+					return GP_OK;
+				}
+				break;
+			}
+			case PTP_EC_Nikon_ObjectAddedInSDRAM: {
+				PTPObjectInfo	oi;
+downloadnow:
+				newobject = event.Param1;
+				if (!newobject) newobject = 0xffff0001;
+				ret = ptp_getobjectinfo (params, newobject, &oi);
+				if (ret != PTP_RC_OK)
+					continue;
+				debug_objectinfo(params, newobject, &oi);
+				C_MEM (path = malloc(sizeof(CameraFilePath)));
+				path->name[0]='\0';
+				strcpy (path->folder,"/");
+				ret = gp_file_new(&file);
+				if (ret!=GP_OK) return ret;
+				if (oi.ObjectFormat != PTP_OFC_EXIF_JPEG) {
+					GP_LOG_D ("raw? ofc is 0x%04x, name is %s", oi.ObjectFormat,oi.Filename);
+					sprintf (path->name, "capt%04d.nef", capcnt++);
+					gp_file_set_mime_type (file, "image/x-nikon-nef"); /* FIXME */
+				} else {
+					sprintf (path->name, "capt%04d.jpg", capcnt++);
+					gp_file_set_mime_type (file, GP_MIME_JPEG);
+				}
+				gp_file_set_mtime (file, time(NULL));
+
+				GP_LOG_D ("trying to get object size=0x%lx", (unsigned long)oi.ObjectCompressedSize);
+				C_PTP_REP (ptp_getobject (params, newobject, (unsigned char**)&ximage));
+				ret = gp_file_set_data_and_size(file, (char*)ximage, oi.ObjectCompressedSize);
+				if (ret != GP_OK) {
+					gp_file_free (file);
+					return ret;
+				}
+				ret = gp_filesystem_append(camera->fs, path->folder, path->name, context);
+				if (ret != GP_OK) {
+					gp_file_free (file);
+					return ret;
+				}
+				ret = gp_filesystem_set_file_noop(camera->fs, path->folder, path->name, GP_FILE_TYPE_NORMAL, file, context);
+				if (ret != GP_OK) {
+					gp_file_free (file);
+					return ret;
+				}
+				*eventtype = GP_EVENT_FILE_ADDED;
+				*eventdata = path;
+				/* We have now handed over the file, disclaim responsibility by unref. */
+				gp_file_unref (file);
+				return GP_OK;
+			}
+			case PTP_EC_Nikon_CaptureCompleteRecInSdram:
+			case PTP_EC_CaptureComplete:
+				if (params->inliveview) {
+					GP_LOG_D ("Capture complete ... restarting liveview");
+					ret = ptp_nikon_start_liveview (params);
+				}
+				*eventtype = GP_EVENT_CAPTURE_COMPLETE;
+				*eventdata = NULL;
+				return GP_OK;
+			case PTP_EC_DevicePropChanged:
+				*eventtype = GP_EVENT_UNKNOWN;
+				C_MEM (*eventdata = malloc(strlen("PTP Property 0123 changed")+1));
+				sprintf (*eventdata, "PTP Property %04x changed", event.Param1);
+				return GP_OK;
+			/* as we can read multiple events we should retrieve a good one if possible
+			 * and not a random one.*/
+			default:
+				*eventtype = GP_EVENT_UNKNOWN;
+				C_MEM (*eventdata = malloc(strlen("PTP Event 0123, Param1 01234567")+1));
+				sprintf (*eventdata, "PTP Event %04x, Param1 %08x", event.Code, event.Param1);
+				return GP_OK;
+			}
+			if (_timeout_passed (&event_start, timeout))
+				break;
+		} while (1);
+		*eventtype = GP_EVENT_TIMEOUT;
+		return GP_OK;
+	}
+	C_PTP_REP (ptp_check_event(params));
+	if (!ptp_get_one_event (params, &event)) {
+		/* FIXME: Might be another error, but usually is a timeout */
+		GP_LOG_D ("no events received.");
+		*eventtype = GP_EVENT_TIMEOUT;
+		return GP_OK;
+	}
+	GP_LOG_D ("code=0x%04x, param1 0x%08x",
+		event.Code, event.Param1
+	);
+handleregular:
+	if (params->deviceinfo.VendorExtensionID == PTP_VENDOR_SONY) {
+		switch (event.Code) {
+		case PTP_EC_Sony_ObjectAdded: {
+			PTPObjectInfo	oi;
+
+			C_MEM (path = malloc(sizeof(CameraFilePath)));
+			C_PTP (ptp_getobjectinfo (params, event.Param1, &oi));
+
+			sprintf (path->folder,"/");
+			if (oi.ObjectFormat == PTP_OFC_SONY_RAW)
+				sprintf (path->name, "capt%04d.arw", capcnt++);
+			else
+				sprintf (path->name, "capt%04d.jpg", capcnt++);
+
+			CR (add_objectid_and_upload (camera, path, context, event.Param1, &oi));
+			*eventtype = GP_EVENT_FILE_ADDED;
+			*eventdata = path;
+			return GP_OK;
+		}
+		case PTP_EC_Sony_PropertyChanged: /* same as DevicePropChanged, just go there */
+			event.Code = PTP_EC_DevicePropChanged;
+			break;
+		}
+		/*fallthrough*/
+	}
+	switch (event.Code) {
+	case PTP_EC_CaptureComplete:
+		*eventtype = GP_EVENT_CAPTURE_COMPLETE;
+		*eventdata = NULL;
+		break;
+	case PTP_EC_ObjectAdded: {
+		PTPObject	*ob;
+		uint16_t	ofc;
+
+		C_MEM (path = malloc(sizeof(CameraFilePath)));
+		path->name[0]='\0';
+		path->folder[0]='\0';
+
+		C_PTP_REP (ptp_object_want (params, event.Param1, PTPOBJECT_OBJECTINFO_LOADED, &ob));
+		strcpy  (path->name,  ob->oi.Filename);
+		sprintf (path->folder,"/"STORAGE_FOLDER_PREFIX"%08lx/",(unsigned long)ob->oi.StorageID);
+		ofc = ob->oi.ObjectFormat;
+		get_folder_from_handle (camera, ob->oi.StorageID, ob->oi.ParentObject, path->folder);
+		/* ob could be invalid now, reload it or dont use it... */
+		/* delete last / or we get confused later. */
+		path->folder[ strlen(path->folder)-1 ] = '\0';
+		if (ofc == PTP_OFC_Association) { /* new folder! */
+			*eventtype = GP_EVENT_FOLDER_ADDED;
+			*eventdata = path;
+			gp_filesystem_reset (camera->fs); /* FIXME: implement more lightweight folder add */
+		} else {
+			CR (gp_filesystem_append (camera->fs, path->folder,
+						  path->name, context));
+			*eventtype = GP_EVENT_FILE_ADDED;
+			*eventdata = path;
+		}
+		break;
+	}
+	case PTP_EC_DevicePropChanged:
+		*eventtype = GP_EVENT_UNKNOWN;
+		C_MEM (*eventdata = malloc(strlen("PTP Property 0123 changed")+1));
+		sprintf (*eventdata, "PTP Property %04x changed", event.Param1);
+		break;
+	default:
+		*eventtype = GP_EVENT_UNKNOWN;
+		C_MEM (*eventdata = malloc(strlen("PTP Event 0123, Param1 01234567")+1));
+		sprintf (*eventdata, "PTP Event %04x, Param1 %08x", event.Code, event.Param1);
+		break;
+	}
+	return GP_OK;
+}
+
+static int
+_value_to_str(PTPPropertyValue *data, uint16_t dt, char *txt, int spaceleft) {
+	int	n;
+	char	*origtxt = txt;
+
+	if (dt == PTP_DTC_STR)
+		return snprintf (txt, spaceleft, "'%s'", data->str);
+	if (dt & PTP_DTC_ARRAY_MASK) {
+		unsigned int i;
+
+		n = snprintf (txt, spaceleft, "a[%d] ", data->a.count);
+		if (n >= spaceleft) return 0; spaceleft -= n; txt += n;
+		for ( i=0; i<data->a.count; i++) {
+			n = _value_to_str(&data->a.v[i], dt & ~PTP_DTC_ARRAY_MASK, txt, spaceleft);
+			if (n >= spaceleft) return 0; spaceleft -= n; txt += n;
+			if (i!=data->a.count-1) {
+				n = snprintf (txt, spaceleft, ",");
+				if (n >= spaceleft) return 0; spaceleft -= n; txt += n;
+			}
+		}
+		return txt - origtxt;
+	} else {
+		switch (dt) {
+		case PTP_DTC_UNDEF:
+			return snprintf (txt, spaceleft, "Undefined");
+		case PTP_DTC_INT8:
+			return snprintf (txt, spaceleft, "%d", data->i8);
+		case PTP_DTC_UINT8:
+			return snprintf (txt, spaceleft, "%u", data->u8);
+		case PTP_DTC_INT16:
+			return snprintf (txt, spaceleft, "%d", data->i16);
+		case PTP_DTC_UINT16:
+			return snprintf (txt, spaceleft, "%u", data->u16);
+		case PTP_DTC_INT32:
+			return snprintf (txt, spaceleft, "%d", data->i32);
+		case PTP_DTC_UINT32:
+			return snprintf (txt, spaceleft, "%u", data->u32);
+	/*
+		PTP_DTC_INT64
+		PTP_DTC_UINT64
+		PTP_DTC_INT128
+		PTP_DTC_UINT128
+	*/
+		default:
+			return snprintf (txt, spaceleft, "Unknown %x", dt);
+		}
+	}
+	return 0;
+}
+
+static const char *
+_get_getset(uint8_t gs) {
+	switch (gs) {
+	case PTP_DPGS_Get: return N_("read only");
+	case PTP_DPGS_GetSet: return N_("readwrite");
+	default: return N_("Unknown");
+	}
+	return N_("Unknown");
+}
+
+#if 0 /* leave out ... is confusing -P downloads */
+#pragma pack(1)
+struct canon_theme_entry {
+	uint16_t	unknown1;
+	uint32_t	offset;
+	uint32_t	length;
+	uint8_t		name[8];
+	char		unknown2[8];
+};
+
+static int
+canon_theme_get (CameraFilesystem *fs, const char *folder, const char *filename,
+		 CameraFileType type, CameraFile *file, void *data,
+		 GPContext *context)
+{
+	Camera		*camera = (Camera*)data;
+	PTPParams	*params = &camera->pl->params;
+	unsigned char	*xdata;
+	unsigned int	size;
+	int i;
+	struct canon_theme_entry	*ent;
+
+	SET_CONTEXT(camera, context);
+
+	C_PTP_REP (ptp_canon_get_customize_data (params, 1, &xdata, &size));
+
+	C_PARAMS (size >= 42+sizeof(struct canon_theme_entry)*5);
+
+	ent = (struct canon_theme_entry*)(xdata+42);
+	for (i=0;i<5;i++) {
+		fprintf(stderr,"entry %d: unknown1 = %x\n", i, ent[i].unknown1);
+		fprintf(stderr,"entry %d: off = %d\n", i, ent[i].offset);
+		fprintf(stderr,"entry %d: len = %d\n", i, ent[i].length);
+		fprintf(stderr,"entry %d: name = %s\n", i, ent[i].name);
+	}
+	CR (gp_file_set_data_and_size (file, (char*)xdata, size));
+	return (GP_OK);
+}
+
+static int
+canon_theme_put (CameraFilesystem *fs, const char *folder, CameraFile *file,
+		void *data, GPContext *context)
+{
+	/* not yet */
+	return (GP_OK);
+}
+#endif
+
+static int
+nikon_curve_get (CameraFilesystem *fs, const char *folder, const char *filename,
+	         CameraFileType type, CameraFile *file, void *data,
+		 GPContext *context)
+{
+	Camera		*camera = (Camera*)data;
+	PTPParams	*params = &camera->pl->params;
+	unsigned char	*xdata;
+	unsigned int	size;
+	int		n;
+	PTPNIKONCurveData	*tonecurve;
+	char		*ntcfile;
+	char		*charptr;
+	double		*doubleptr;
+	((PTPData *) camera->pl->params.data)->context = context;
+	SET_CONTEXT(camera, context);
+
+	C_PTP_REP (ptp_nikon_curve_download (params, &xdata, &size));
+
+	tonecurve = (PTPNIKONCurveData *) xdata;
+	C_MEM (ntcfile = malloc(2000));
+	memcpy(ntcfile,"\x9d\xdc\x7d\x00\x65\xd4\x11\xd1\x91\x94\x44\x45\x53\x54\x00\x00\xff\x05\xbb\x02\x00\x00\x01\x04\x00\x00\x00\x00\x00\x00\x00\x00\x00\x9d\xdc\x7d\x03\x65\xd4\x11\xd1\x91\x94\x44\x45\x53\x54\x00\x00\x00\x00\x00\x00\xff\x03\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\x00\x00\x00\xff\x00\x00\x00\xff\x00\x00\x00", 92);
+	doubleptr=(double *) &ntcfile[92];
+	*doubleptr++ = (double) tonecurve->XAxisStartPoint/255;
+	*doubleptr++ = (double) tonecurve->XAxisEndPoint/255;
+	*doubleptr++ = (double) tonecurve->MidPointIntegerPart
+			+ tonecurve->MidPointDecimalPart/100;
+	*doubleptr++ = (double) tonecurve->YAxisStartPoint/255;
+	*doubleptr++ = (double) tonecurve->YAxisEndPoint/255;
+	charptr=(char*) doubleptr;
+	*charptr++ = (char) tonecurve->NCoordinates;
+	memcpy(charptr, "\x00\x00\x00", 3);
+	charptr +=3;
+	doubleptr = (double *) charptr;
+	for(n=0;n<tonecurve->NCoordinates;n++) {
+		*doubleptr = (double) tonecurve->CurveCoordinates[n].X/255;
+		doubleptr = &doubleptr[1];
+		*doubleptr = (double) tonecurve->CurveCoordinates[n].Y/255;
+		doubleptr = &doubleptr[1];
+	}
+	*doubleptr++ = (double) 0;
+	charptr = (char*) doubleptr;
+	memcpy(charptr,"\x9d\xdc\x7d\x03\x65\xd4\x11\xd1\x91\x94\x44\x45\x53\x54\x00\x00\x01\x00\x00\x00\xff\x03\x00\xff\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xf0\x3f\x00\x00\x00\x00\x00\x00\xf0\x3f\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xf0\x3f\x02\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xf0\x3f\x00\x00\x00\x00\x00\x00\xf0\x3f\x00\x00\x00\x00\x00\x00\x00\x00\x9d\xdc\x7d\x03\x65\xd4\x11\xd1\x91\x94\x44\x45\x53\x54\x00\x00\x02\x00\x00\x00\xff\x03\x00\x00\x00\x00\x00\xff\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xf0\x3f\x00\x00\x00\x00\x00\x00\xf0\x3f\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xf0\x3f\x02\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xf0\x3f\x00\x00\x00\x00\x00\x00\xf0\x3f\x00\x00\x00\x00\x00\x00\x00\x00\x9d\xdc\x7d\x03\x65\xd4\x11\xd1\x91\x94\x44\x45\x53\x54\x00\x00\x03\x00\x00\x00\xff\x03\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xf0\x3f\x00\x00\x00\x00\x00\x00\xf0\x3f\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xf0\x3f\x02\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xf0\x3f\x00\x00\x00\x00\x00\x00\xf0\x3f\x00\x00\x00\x00\x00\x00\x00\x00",429);
+	charptr += 429;
+	CR (gp_file_set_data_and_size (file, ntcfile, (long)charptr - (long)ntcfile));
+	/* do not free ntcfile, it is managed by filesys now */
+	free (xdata);
+	return (GP_OK);
+}
+
+static int
+nikon_curve_put (CameraFilesystem *fs, const char *folder, CameraFile *file,
+		void *data, GPContext *context)
+{
+	/* not yet */
+	return (GP_OK);
+}
+
+static int
+camera_summary (Camera* camera, CameraText* summary, GPContext *context)
+{
+	unsigned int i, j;
+	int n;
+	uint16_t ret;
+	int spaceleft;
+	char *txt;
+	PTPParams *params = &(camera->pl->params);
+	PTPDeviceInfo pdi;
+	PTPStorageIDs storageids;
+
+	SET_CONTEXT(camera, context);
+
+	spaceleft = sizeof(summary->text);
+	txt = summary->text;
+
+	n = snprintf (txt, spaceleft,_("Manufacturer: %s\n"),params->deviceinfo.Manufacturer);
+	if (n >= spaceleft) return GP_OK; spaceleft -= n; txt += n;
+	n = snprintf (txt, spaceleft,_("Model: %s\n"),params->deviceinfo.Model);
+	if (n >= spaceleft) return GP_OK; spaceleft -= n; txt += n;
+	n = snprintf (txt, spaceleft,_("  Version: %s\n"),params->deviceinfo.DeviceVersion);
+	if (n >= spaceleft) return GP_OK; spaceleft -= n; txt += n;
+	if (params->deviceinfo.SerialNumber) {
+		n = snprintf (txt, spaceleft,_("  Serial Number: %s\n"),params->deviceinfo.SerialNumber);
+		if (n >= spaceleft) return GP_OK; spaceleft -= n; txt += n;
+	}
+	if (params->deviceinfo.VendorExtensionID) {
+		n = snprintf (txt, spaceleft,_("Vendor Extension ID: 0x%x (%d.%d)\n"),
+			params->deviceinfo.VendorExtensionID,
+			params->deviceinfo.VendorExtensionVersion/100,
+			params->deviceinfo.VendorExtensionVersion%100
+		);
+		if (n >= spaceleft) return GP_OK; spaceleft -= n; txt += n;
+		if (params->deviceinfo.VendorExtensionDesc) {
+			n = snprintf (txt, spaceleft,_("Vendor Extension Description: %s\n"),params->deviceinfo.VendorExtensionDesc);
+			if (n >= spaceleft) return GP_OK; spaceleft -= n; txt += n;
+		}
+	}
+	if (params->deviceinfo.StandardVersion != 100) {
+		n = snprintf (txt, spaceleft,_("PTP Standard Version: %d.%d\n"),
+			params->deviceinfo.StandardVersion/100,
+			params->deviceinfo.StandardVersion%100
+		);
+		if (n >= spaceleft) return GP_OK; spaceleft -= n; txt += n;
+	}
+	if (params->deviceinfo.FunctionalMode) {
+		n = snprintf (txt, spaceleft,_("Functional Mode: 0x%04x\n"),params->deviceinfo.FunctionalMode);
+		if (n >= spaceleft) return GP_OK; spaceleft -= n; txt += n;
+	}
+
+/* Dump Formats */
+	n = snprintf (txt, spaceleft,_("\nCapture Formats: "));
+	if (n >= spaceleft) return GP_OK; spaceleft -= n; txt += n;
+
+	for (i=0;i<params->deviceinfo.CaptureFormats_len;i++) {
+		n = ptp_render_ofc (params, params->deviceinfo.CaptureFormats[i], spaceleft, txt);
+		if (n >= spaceleft) return GP_OK; spaceleft -= n; txt += n;
+		if (i<params->deviceinfo.CaptureFormats_len-1) {
+			n = snprintf (txt, spaceleft," ");
+			if (n >= spaceleft) return GP_OK; spaceleft -= n; txt += n;
+		}
+	}
+	n = snprintf (txt, spaceleft,"\n");
+	if (n >= spaceleft) return GP_OK; spaceleft -= n; txt += n;
+
+	n = snprintf (txt, spaceleft,_("Display Formats: "));
+	if (n >= spaceleft) return GP_OK; spaceleft -= n; txt += n;
+	for (i=0;i<params->deviceinfo.ImageFormats_len;i++) {
+		n = ptp_render_ofc (params, params->deviceinfo.ImageFormats[i], spaceleft, txt);
+		if (n >= spaceleft) return GP_OK; spaceleft -= n; txt += n;
+		if (i<params->deviceinfo.ImageFormats_len-1) {
+			n = snprintf (txt, spaceleft,", ");
+			if (n >= spaceleft) return GP_OK; spaceleft -= n; txt += n;
+		}
+	}
+	n = snprintf (txt, spaceleft,"\n");
+	if (n >= spaceleft) return GP_OK; spaceleft -= n; txt += n;
+
+	if (is_mtp_capable (camera) &&
+	    ptp_operation_issupported(params,PTP_OC_MTP_GetObjectPropsSupported)
+	) {
+		n = snprintf (txt, spaceleft,_("Supported MTP Object Properties:\n"));
+		if (n >= spaceleft) return GP_OK; spaceleft -= n; txt += n;
+		for (i=0;i<params->deviceinfo.ImageFormats_len;i++) {
+			uint16_t *props = NULL;
+			uint32_t propcnt = 0;
+
+			n = snprintf (txt, spaceleft,"\t");
+			if (n >= spaceleft) return GP_OK; spaceleft -= n; txt += n;
+			n = ptp_render_ofc (params, params->deviceinfo.ImageFormats[i], spaceleft, txt);
+			if (n >= spaceleft) return GP_OK; spaceleft -= n; txt += n;
+			n = snprintf (txt, spaceleft,"/%04x:", params->deviceinfo.ImageFormats[i]);
+			if (n >= spaceleft) return GP_OK; spaceleft -= n; txt += n;
+
+			ret = ptp_mtp_getobjectpropssupported (params, params->deviceinfo.ImageFormats[i], &propcnt, &props);
+			if (ret != PTP_RC_OK) {
+				n = snprintf (txt, spaceleft,_(" PTP error %04x on query"), ret);
+				if (n >= spaceleft) return GP_OK; spaceleft -= n; txt += n;
+			} else {
+				for (j=0;j<propcnt;j++) {
+					n = snprintf (txt, spaceleft," %04x/",props[j]);
+					if (n >= spaceleft) { free (props); return GP_OK;}  spaceleft -= n; txt += n;
+					n = ptp_render_mtp_propname(props[j],spaceleft,txt);
+					if (n >= spaceleft) { free (props); return GP_OK;} spaceleft -= n; txt += n;
+				}
+				free(props);
+			}
+			n = snprintf (txt, spaceleft,"\n");
+			if (n >= spaceleft) return GP_OK; spaceleft -= n; txt += n;
+		}
+	}
+
+/* Dump out dynamic capabilities */
+	n = snprintf (txt, spaceleft,_("\nDevice Capabilities:\n"));
+	if (n >= spaceleft) return GP_OK; spaceleft -= n; txt += n;
+
+	/* First line for file operations */
+		n = snprintf (txt, spaceleft,_("\tFile Download, "));
+		if (n >= spaceleft) return GP_OK; spaceleft -= n; txt += n;
+		if (ptp_operation_issupported(params,PTP_OC_DeleteObject))
+			n = snprintf (txt, spaceleft,_("File Deletion, "));
+		else
+			n = snprintf (txt, spaceleft,_("No File Deletion, "));
+		if (n >= spaceleft) return GP_OK; spaceleft -= n; txt += n;
+
+		if (ptp_operation_issupported(params,PTP_OC_SendObject))
+			n = snprintf (txt, spaceleft,_("File Upload\n"));
+		else
+			n = snprintf (txt, spaceleft,_("No File Upload\n"));
+		if (n >= spaceleft) return GP_OK; spaceleft -= n; txt += n;
+
+	/* Second line for capture */
+		if (ptp_operation_issupported(params,PTP_OC_InitiateCapture))
+			n = snprintf (txt, spaceleft,_("\tGeneric Image Capture, "));
+		else
+			n = snprintf (txt, spaceleft,_("\tNo Image Capture, "));
+		if (n >= spaceleft) return GP_OK; spaceleft -= n; txt += n;
+		if (ptp_operation_issupported(params,PTP_OC_InitiateOpenCapture))
+			n = snprintf (txt, spaceleft,_("Open Capture, "));
+		else
+			n = snprintf (txt, spaceleft,_("No Open Capture, "));
+		if (n >= spaceleft) return GP_OK; spaceleft -= n; txt += n;
+
+		n = 0;
+		switch (params->deviceinfo.VendorExtensionID) {
+		case PTP_VENDOR_CANON:
+			if (ptp_operation_issupported(params, PTP_OC_CANON_ViewfinderOn)) {
+				n = snprintf (txt, spaceleft,_("Canon Capture"));
+				if (n >= spaceleft) return GP_OK; spaceleft -= n; txt += n;
+			}
+			if (ptp_operation_issupported(params, PTP_OC_CANON_EOS_RemoteRelease)) {
+				n = snprintf (txt, spaceleft,_("Canon EOS Capture"));
+				if (n >= spaceleft) return GP_OK; spaceleft -= n; txt += n;
+			}
+			if (ptp_operation_issupported(params, PTP_OC_CANON_EOS_RemoteReleaseOn)) {
+				n = snprintf (txt, spaceleft,_("%sCanon EOS Shutter Button"),n?", ":"");
+				if (n >= spaceleft) return GP_OK; spaceleft -= n; txt += n;
+			}
+			if (n) {
+				n = snprintf (txt, spaceleft,"\n");
+				if (n >= spaceleft) return GP_OK; spaceleft -= n; txt += n;
+			}
+			break;
+		case PTP_VENDOR_NIKON:
+			if (ptp_operation_issupported(params, PTP_OC_NIKON_Capture)) {
+				n = snprintf (txt, spaceleft,_("Nikon Capture 1"));
+				if (n >= spaceleft) return GP_OK; spaceleft -= n; txt += n;
+			}
+			if (ptp_operation_issupported(params, PTP_OC_NIKON_AfCaptureSDRAM)) {
+				n = snprintf (txt, spaceleft,_("%sNikon Capture 2"),n?", ":"");
+				if (n >= spaceleft) return GP_OK; spaceleft -= n; txt += n;
+			}
+			if (ptp_operation_issupported(params, PTP_OC_NIKON_InitiateCaptureRecInMedia)) {
+				n = snprintf (txt, spaceleft,_("%sNikon Capture 3 "),n?", ":"");
+				if (n >= spaceleft) return GP_OK; spaceleft -= n; txt += n;
+			}
+			if (n) {
+				n = snprintf (txt, spaceleft,"\n");
+				if (n >= spaceleft) return GP_OK; spaceleft -= n; txt += n;
+			}
+			break;
+		case PTP_VENDOR_SONY:
+			if (ptp_operation_issupported(params, PTP_OC_SONY_SetControlDeviceB)) {
+				n = snprintf (txt, spaceleft,_("Sony Capture"));
+				if (n >= spaceleft) return GP_OK; spaceleft -= n; txt += n;
+			}
+			break;
+		default:
+			/* does not belong to good vendor ... needs another detection */
+			if (params->device_flags & DEVICE_FLAG_OLYMPUS_XML_WRAPPED) {
+				n = snprintf (txt, spaceleft,_("Olympus E XML Capture\n"));
+				if (n >= spaceleft) return GP_OK; spaceleft -= n; txt += n;
+			}
+			break;
+		}
+		if (!n) {
+			n = snprintf (txt, spaceleft,_("No vendor specific capture\n"));
+			if (n >= spaceleft) return GP_OK; spaceleft -= n; txt += n;
+		}
+
+	/* Third line for Wifi support, but just leave it out if not there. */
+		if ((params->deviceinfo.VendorExtensionID == PTP_VENDOR_NIKON) &&
+		     ptp_operation_issupported(params, PTP_OC_NIKON_GetProfileAllData)) {
+			n = snprintf (txt, spaceleft,_("\tNikon Wifi support\n"));
+			if (n >= spaceleft) return GP_OK; spaceleft -= n; txt += n;
+		}
+
+		if ((params->deviceinfo.VendorExtensionID == PTP_VENDOR_CANON) &&
+		     ptp_operation_issupported(params, PTP_OC_CANON_GetMACAddress)) {
+			n = snprintf (txt, spaceleft,_("\tCanon Wifi support\n"));
+			if (n >= spaceleft) return GP_OK; spaceleft -= n; txt += n;
+		}
+
+/* Dump storage information */
+
+	if (ptp_operation_issupported(params,PTP_OC_GetStorageIDs) &&
+	    ptp_operation_issupported(params,PTP_OC_GetStorageInfo)
+	) {
+		C_PTP_REP (ptp_getstorageids(params,
+			&storageids));
+		n = snprintf (txt, spaceleft,_("\nStorage Devices Summary:\n"));
+		if (n >= spaceleft) return GP_OK; spaceleft -= n; txt += n;
+
+		for (i=0; i<storageids.n; i++) {
+			char tmpname[20], *s;
+
+			PTPStorageInfo storageinfo;
+			/* invalid storage, storageinfo might fail on it (Nikon D300s e.g.) */
+			if ((storageids.Storage[i]&0x0000ffff)==0)
+				continue;
+
+			n = snprintf (txt, spaceleft,"store_%08x:\n",(unsigned int)storageids.Storage[i]);
+			if (n>=spaceleft) return GP_OK;spaceleft-=n;txt+=n;
+
+			C_PTP_REP (ptp_getstorageinfo(params,
+				storageids.Storage[i], &storageinfo));
+			n = snprintf (txt, spaceleft,_("\tStorageDescription: %s\n"),
+				storageinfo.StorageDescription?storageinfo.StorageDescription:_("None")
+			);
+			if (n>=spaceleft) return GP_OK;spaceleft-=n;txt+=n;
+			n = snprintf (txt, spaceleft,_("\tVolumeLabel: %s\n"),
+				storageinfo.VolumeLabel?storageinfo.VolumeLabel:_("None")
+			);
+			if (n>=spaceleft) return GP_OK;spaceleft-=n;txt+=n;
+
+			switch (storageinfo.StorageType) {
+			case PTP_ST_Undefined: s = _("Undefined"); break;
+			case PTP_ST_FixedROM: s = _("Builtin ROM"); break;
+			case PTP_ST_RemovableROM: s = _("Removable ROM"); break;
+			case PTP_ST_FixedRAM: s = _("Builtin RAM"); break;
+			case PTP_ST_RemovableRAM: s = _("Removable RAM (memory card)"); break;
+			default:
+				snprintf(tmpname, sizeof(tmpname), _("Unknown: 0x%04x\n"), storageinfo.StorageType);
+				s = tmpname;
+				break;
+			}
+			n = snprintf (txt, spaceleft,_("\tStorage Type: %s\n"), s);
+			if (n>=spaceleft) return GP_OK;spaceleft-=n;txt+=n;
+
+			switch (storageinfo.FilesystemType) {
+			case PTP_FST_Undefined: s = _("Undefined"); break;
+			case PTP_FST_GenericFlat: s = _("Generic Flat"); break;
+			case PTP_FST_GenericHierarchical: s = _("Generic Hierarchical"); break;
+			case PTP_FST_DCF: s = _("Digital Camera Layout (DCIM)"); break;
+			default:
+				snprintf(tmpname, sizeof(tmpname), _("Unknown: 0x%04x\n"), storageinfo.FilesystemType);
+				s = tmpname;
+				break;
+			}
+			n = snprintf (txt, spaceleft,_("\tFilesystemtype: %s\n"), s);
+			if (n>=spaceleft) return GP_OK;spaceleft-=n;txt+=n;
+
+			switch (storageinfo.AccessCapability) {
+			case PTP_AC_ReadWrite: s = _("Read-Write"); break;
+			case PTP_AC_ReadOnly: s = _("Read-Only"); break;
+			case PTP_AC_ReadOnly_with_Object_Deletion: s = _("Read Only with Object deletion"); break;
+			default:
+				snprintf(tmpname, sizeof(tmpname), _("Unknown: 0x%04x\n"), storageinfo.AccessCapability);
+				s = tmpname;
+				break;
+			}
+			n = snprintf (txt, spaceleft,_("\tAccess Capability: %s\n"), s);
+			if (n>=spaceleft) return GP_OK;spaceleft-=n;txt+=n;
+			n = snprintf (txt, spaceleft,_("\tMaximum Capability: %llu (%lu MB)\n"),
+				(unsigned long long)storageinfo.MaxCapability,
+				(unsigned long)(storageinfo.MaxCapability/1024/1024)
+			);
+			if (n>=spaceleft) return GP_OK;spaceleft-=n;txt+=n;
+			n = snprintf (txt, spaceleft,_("\tFree Space (Bytes): %llu (%lu MB)\n"),
+				(unsigned long long)storageinfo.FreeSpaceInBytes,
+				(unsigned long)(storageinfo.FreeSpaceInBytes/1024/1024)
+			);
+			if (n>=spaceleft) return GP_OK;spaceleft-=n;txt+=n;
+			n = snprintf (txt, spaceleft,_("\tFree Space (Images): %d\n"), (unsigned int)storageinfo.FreeSpaceInImages);
+			if (n>=spaceleft) return GP_OK;spaceleft-=n;txt+=n;
+			free (storageinfo.StorageDescription);
+			free (storageinfo.VolumeLabel);
+		}
+		free (storageids.Storage);
+	}
+
+	n = snprintf (txt, spaceleft,_("\nDevice Property Summary:\n"));
+	if (n>=spaceleft) return GP_OK;spaceleft-=n;txt+=n;
+	/* The information is cached. However, the canon firmware changes
+	 * the available properties in capture mode.
+	 */
+	C_PTP_REP (ptp_getdeviceinfo (params, &pdi));
+	CR (fixup_cached_deviceinfo (camera, &pdi));
+        for (i=0;i<pdi.DevicePropertiesSupported_len;i++) {
+		PTPDevicePropDesc dpd;
+		unsigned int dpc = pdi.DevicePropertiesSupported[i];
+		const char *propname = ptp_get_property_description (params, dpc);
+
+		if (propname) {
+			/* string registered for i18n in ptp.c. */
+			n = snprintf(txt, spaceleft, "%s(0x%04x):", _(propname), dpc);
+		} else {
+			n = snprintf(txt, spaceleft, "Property 0x%04x:", dpc);
+		}
+		if (n>=spaceleft) return GP_OK;spaceleft-=n;txt+=n;
+
+
+		/* Do not read the 0xd201 property (found on Creative Zen series).
+		 * It seems to cause hangs.
+		 */
+		if (params->deviceinfo.VendorExtensionID==PTP_VENDOR_MICROSOFT) {
+			if (dpc == 0xd201) {
+				n = snprintf(txt, spaceleft, _(" not read out.\n"));
+				if (n>=spaceleft) return GP_OK;spaceleft-=n;txt+=n;
+				continue;
+			}
+		}
+#if 0 /* check is handled by the generic getter now */
+		if (!ptp_operation_issupported(params, PTP_OC_GetDevicePropDesc)) {
+			n = snprintf(txt, spaceleft, _("cannot be queried.\n"));
+			if (n>=spaceleft) return GP_OK;spaceleft-=n;txt+=n;
+			continue;
+		}
+#endif
+
+		memset (&dpd, 0, sizeof (dpd));
+		ret = ptp_generic_getdevicepropdesc (params, dpc, &dpd);
+		if (ret == PTP_RC_OK) {
+			n = snprintf (txt, spaceleft, "(%s) ",_get_getset(dpd.GetSet));
+			if (n>=spaceleft) return GP_OK;spaceleft-=n;txt+=n;
+			n = snprintf (txt, spaceleft, "(type=0x%x) ",dpd.DataType);
+			if (n>=spaceleft) return GP_OK;spaceleft-=n;txt+=n;
+			switch (dpd.FormFlag) {
+			case PTP_DPFF_None:	break;
+			case PTP_DPFF_Range: {
+				n = snprintf (txt, spaceleft, "Range [");
+				if (n>=spaceleft) return GP_OK;spaceleft-=n;txt+=n;
+				n = _value_to_str (&dpd.FORM.Range.MinimumValue, dpd.DataType, txt, spaceleft);
+				if (n>=spaceleft) return GP_OK;spaceleft-=n;txt+=n;
+				n = snprintf (txt, spaceleft, " - ");
+				if (n>=spaceleft) return GP_OK;spaceleft-=n;txt+=n;
+				n= _value_to_str (&dpd.FORM.Range.MaximumValue, dpd.DataType, txt, spaceleft);
+				if (n>=spaceleft) return GP_OK;spaceleft-=n;txt+=n;
+				n = snprintf (txt, spaceleft, ", step ");
+				if (n>=spaceleft) return GP_OK;spaceleft-=n;txt+=n;
+				n= _value_to_str (&dpd.FORM.Range.StepSize, dpd.DataType, txt, spaceleft);
+				if (n>=spaceleft) return GP_OK;spaceleft-=n;txt+=n;
+				n = snprintf (txt, spaceleft, "] value: ");
+				if (n>=spaceleft) return GP_OK;spaceleft-=n;txt+=n;
+				break;
+			}
+			case PTP_DPFF_Enumeration:
+				n = snprintf (txt, spaceleft, "Enumeration [");
+				if (n>=spaceleft) return GP_OK;spaceleft-=n;txt+=n;
+				if ((dpd.DataType & PTP_DTC_ARRAY_MASK) == PTP_DTC_ARRAY_MASK)  {
+					n = snprintf (txt, spaceleft, "\n\t");
+					if (n>=spaceleft) return GP_OK;spaceleft-=n;txt+=n;
+				}
+				for (j = 0; j<dpd.FORM.Enum.NumberOfValues; j++) {
+					n = _value_to_str(dpd.FORM.Enum.SupportedValue+j,dpd.DataType,txt, spaceleft);
+					if (n>=spaceleft) return GP_OK;spaceleft-=n;txt+=n;
+					if (j != dpd.FORM.Enum.NumberOfValues-1) {
+						n = snprintf (txt, spaceleft, ",");
+						if (n>=spaceleft) return GP_OK;spaceleft-=n;txt+=n;
+						if ((dpd.DataType & PTP_DTC_ARRAY_MASK) == PTP_DTC_ARRAY_MASK)  {
+							n = snprintf (txt, spaceleft, "\n\t");
+							if (n>=spaceleft) return GP_OK;spaceleft-=n;txt+=n;
+						}
+					}
+				}
+				if ((dpd.DataType & PTP_DTC_ARRAY_MASK) == PTP_DTC_ARRAY_MASK)  {
+					n = snprintf (txt, spaceleft, "\n\t");
+					if (n>=spaceleft) return GP_OK;spaceleft-=n;txt+=n;
+				}
+				n = snprintf (txt, spaceleft, "] value: ");
+				if (n>=spaceleft) return GP_OK;spaceleft-=n;txt+=n;
+				break;
+			}
+			n = ptp_render_property_value(params, dpc, &dpd, sizeof(summary->text) - strlen(summary->text) - 1, txt);
+			if (n>=spaceleft) return GP_OK;spaceleft-=n;txt+=n;
+			if (n) {
+				n = snprintf(txt, spaceleft, " (");
+				if (n>=spaceleft) return GP_OK;spaceleft-=n;txt+=n;
+				n = _value_to_str (&dpd.CurrentValue, dpd.DataType, txt, spaceleft);
+				if (n>=spaceleft) return GP_OK;spaceleft-=n;txt+=n;
+				n = snprintf(txt, spaceleft, ")");
+				if (n>=spaceleft) return GP_OK;spaceleft-=n;txt+=n;
+			} else {
+				n = _value_to_str (&dpd.CurrentValue, dpd.DataType, txt, spaceleft);
+				if (n>=spaceleft) return GP_OK;spaceleft-=n;txt+=n;
+			}
+		} else {
+			n = snprintf (txt, spaceleft, _(" error %x on query."), ret);
+			if (n>=spaceleft) return GP_OK;spaceleft-=n;txt+=n;
+		}
+		n = snprintf(txt, spaceleft, "\n");
+		if (n>=spaceleft) return GP_OK;spaceleft-=n;txt+=n;
+		ptp_free_devicepropdesc (&dpd);
+        }
+	ptp_free_DI (&pdi);
+	return (GP_OK);
+}
+
+static uint32_t
+find_child (PTPParams *params,const char *file,uint32_t storage,uint32_t handle,PTPObject **retob)
+{
+	unsigned int	i;
+	uint16_t	ret;
+
+	ret = ptp_list_folder (params, storage, handle);
+	if (ret != PTP_RC_OK)
+		return PTP_HANDLER_SPECIAL;
+
+	for (i = 0; i < params->nrofobjects; i++) {
+		PTPObject	*ob = &params->objects[i];
+
+		ret = PTP_RC_OK;
+		if ((ob->flags & (PTPOBJECT_PARENTOBJECT_LOADED|PTPOBJECT_STORAGEID_LOADED)) != (PTPOBJECT_PARENTOBJECT_LOADED|PTPOBJECT_STORAGEID_LOADED))
+			ret = ptp_object_want (params, params->objects[i].oid, PTPOBJECT_PARENTOBJECT_LOADED|PTPOBJECT_STORAGEID_LOADED, &ob);
+		if (ret != PTP_RC_OK)
+			return PTP_HANDLER_SPECIAL;
+		if ((ob->oi.StorageID==storage) && (ob->oi.ParentObject==handle)) {
+			ret = ptp_object_want (params, ob->oid, PTPOBJECT_OBJECTINFO_LOADED, &ob);
+			if (ret != PTP_RC_OK)
+				return PTP_HANDLER_SPECIAL;
+			if (!strcmp (ob->oi.Filename,file)) {
+				if (retob) *retob = ob;
+				return ob->oid;
+			}
+		}
+	}
+	/* else not found */
+	return PTP_HANDLER_SPECIAL;
+}
+
+static uint32_t
+folder_to_handle(PTPParams *params, const char *folder, uint32_t storage, uint32_t parent, PTPObject **retob)
+{
+	char 		*c;
+
+	if (retob) *retob = NULL;
+	if (!strlen(folder)) {
+		/* was initially read, no need to reread */
+		/* ptp_list_folder (params, storage, 0); */
+		return PTP_HANDLER_ROOT;
+	}
+	if (!strcmp(folder,"/")) {
+		/* was initially read, no need to reread */
+		/* ptp_list_folder (params, storage, 0); */
+		return PTP_HANDLER_ROOT;
+	}
+
+	c = strchr(folder,'/');
+	if (c != NULL) {
+		*c = 0;
+		parent = find_child (params, folder, storage, parent, retob);
+		if (parent == PTP_HANDLER_SPECIAL) 
+			GP_LOG_D("not found???");
+		return folder_to_handle(params, c+1, storage, parent, retob);
+	} else  {
+		return find_child (params, folder, storage, parent, retob);
+	}
+}
+
+static int
+file_list_func (CameraFilesystem *fs, const char *folder, CameraList *list,
+		void *data, GPContext *context)
+{
+    Camera *camera = (Camera *)data;
+    PTPParams *params = &camera->pl->params;
+    uint32_t parent, storage=0x0000000;
+    unsigned int i, hasgetstorageids;
+    SET_CONTEXT_P(params, context);
+    int	lastnrofobjects = params->nrofobjects, redoneonce = 0;
+
+    GP_LOG_D ("file_list_func(%s)", folder);
+
+    /* There should be NO files in root folder */
+    if (!strcmp(folder, "/"))
+        return (GP_OK);
+
+    if (!strcmp(folder, "/special")) {
+	for (i=0; i<nrofspecial_files; i++)
+		CR (gp_list_append (list, special_files[i].name, NULL));
+	return (GP_OK);
+    }
+
+    /* compute storage ID value from folder patch */
+    folder_to_storage(folder,storage);
+
+    /* Get (parent) folder handle omiting storage pseudofolder */
+    find_folder_handle(params,folder,storage,parent);
+
+    C_PTP_REP (ptp_list_folder (params, storage, parent));
+    GP_LOG_D ("after list folder");
+
+    hasgetstorageids = ptp_operation_issupported(params,PTP_OC_GetStorageIDs);
+
+retry:
+    for (i = 0; i < params->nrofobjects; i++) {
+	PTPObject	*ob;
+	uint16_t	ret;
+
+	/* not our parent -> next */
+	C_PTP_REP (ptp_object_want (params, params->objects[i].oid, PTPOBJECT_PARENTOBJECT_LOADED|PTPOBJECT_STORAGEID_LOADED, &ob));
+
+	/* DANGER DANGER: i is now invalid as objects might have been inserted in the list! */
+
+	if (ob->oi.ParentObject!=parent)
+		continue;
+
+	/* not on our storage devices -> next */
+	if ((hasgetstorageids && (ob->oi.StorageID != storage)))
+		continue;
+
+	ret = ptp_object_want (params, ob->oid, PTPOBJECT_OBJECTINFO_LOADED, &ob);
+	if (ret != PTP_RC_OK) {
+		/* we might raced another delete or ongoing addition, seen on a D810 */
+		if (ret == PTP_RC_InvalidObjectHandle) {
+			GP_LOG_D ("Handle %08x was in list, but not/no longer found via getobjectinfo.\n", ob->oid);
+			/* remove it for now, we will readd it later if we see it again. */
+			ptp_remove_object_from_cache(params, ob->oid);
+			continue;
+		}
+		C_PTP_REP (ret);
+	}
+	/* Is a directory -> next */
+	if (ob->oi.ObjectFormat == PTP_OFC_Association)
+		continue;
+
+	debug_objectinfo(params, ob->oid, &ob->oi);
+
+	if (!ob->oi.Filename)
+	    continue;
+
+	if (1) {
+	    /* HP Photosmart 850, the camera tends to duplicate filename in the list.
+             * Original patch by clement.rezvoy@gmail.com */
+	    /* search backwards, likely gets hits faster. */
+	    /* FIXME Marcus: This is also O(n^2) ... bad for large directories. */
+	    if (GP_OK == gp_list_find_by_name(list, NULL, ob->oi.Filename)) {
+		GP_LOG_E (
+			"Duplicate filename '%s' in folder '%s'. Ignoring nth entry.\n",
+			ob->oi.Filename, folder);
+		continue;
+	    }
+	}
+	CR(gp_list_append (list, ob->oi.Filename, NULL));
+    }
+
+    /* Did we change the object tree list during our traversal? if yes, redo the scan. */
+    if (params->nrofobjects != lastnrofobjects) {
+	if (redoneonce++) {
+		GP_LOG_E("list changed again on second pass, returning anyway");
+		return GP_OK;
+	}
+	lastnrofobjects = params->nrofobjects;
+	gp_list_reset(list);
+	goto retry;
+    }
+    return GP_OK;
+}
+
+static int
+folder_list_func (CameraFilesystem *fs, const char *folder, CameraList *list,
+		void *data, GPContext *context)
+{
+	PTPParams *params = &((Camera *)data)->pl->params;
+	unsigned int i, hasgetstorageids;
+	uint32_t handler,storage;
+	int redoneonce = 0, lastnrofobjects = params->nrofobjects;
+
+	SET_CONTEXT_P(params, context);
+	GP_LOG_D ("folder_list_func(%s)", folder);
+	/* add storage pseudofolders in root folder */
+	if (!strcmp(folder, "/")) {
+		if (ptp_operation_issupported(params,PTP_OC_GetStorageIDs)) {
+			PTPStorageIDs storageids;
+			char fname[PTP_MAXSTRLEN];
+
+			C_PTP_REP (ptp_getstorageids(params, &storageids));
+			if (!storageids.n) {
+				snprintf(fname, sizeof(fname), STORAGE_FOLDER_PREFIX"%08x",0x00010001);
+				CR (gp_list_append (list, fname, NULL));
+			}
+			for (i=0; i<storageids.n; i++) {
+
+				/* invalid storage, storageinfo might fail on it (Nikon D300s e.g.) */
+				if ((storageids.Storage[i]&0x0000ffff)==0) continue;
+				snprintf(fname, sizeof(fname),
+					STORAGE_FOLDER_PREFIX"%08x",
+					storageids.Storage[i]);
+				CR (gp_list_append (list, fname, NULL));
+			}
+			free (storageids.Storage);
+		} else {
+			char fname[PTP_MAXSTRLEN];
+			snprintf(fname, sizeof(fname),
+					STORAGE_FOLDER_PREFIX"%08x",
+					0xdeadbeef
+			);
+			gp_list_append (list, fname, NULL);
+		}
+		if (nrofspecial_files)
+			CR (gp_list_append (list, "special", NULL));
+		return (GP_OK);
+	}
+
+	if (!strcmp(folder, "/special")) {
+		/* no folders in here */
+		return (GP_OK);
+	}
+
+	/* compute storage ID value from folder path */
+	folder_to_storage (folder,storage);
+
+	/* Get folder handle omiting storage pseudofolder */
+	find_folder_handle (params,folder,storage,handler);
+
+	/* list this directory */
+	C_PTP_REP (ptp_list_folder (params, storage, handler));
+
+        GP_LOG_D ("after list folder");
+
+	/* Look for objects we can present as directories.
+	 * Currently we specify *any* PTP association as directory.
+	 */
+	hasgetstorageids = ptp_operation_issupported(params,PTP_OC_GetStorageIDs);
+retry:
+	for (i = 0; i < params->nrofobjects; i++) {
+		PTPObject	*ob;
+		uint16_t	ret;
+		uint32_t	handle;
+
+		C_PTP_REP (ptp_object_want (params, params->objects[i].oid, PTPOBJECT_STORAGEID_LOADED|PTPOBJECT_PARENTOBJECT_LOADED, &ob));
+
+		if (ob->oi.ParentObject != handler)
+			continue;
+		if (hasgetstorageids && (ob->oi.StorageID != storage))
+			continue;
+
+		handle = ob->oid;
+		ret = ptp_object_want (params, handle, PTPOBJECT_OBJECTINFO_LOADED, &ob);
+		if (ret != PTP_RC_OK) {
+			/* we might raced another delete or ongoing addition, seen on a D810 */
+			if (ret == PTP_RC_InvalidObjectHandle) {
+				GP_LOG_D ("Handle %08x was in list, but not/no longer found via getobjectinfo.\n", handle);
+				/* remove it for now, we will readd it later if we see it again. */
+				ptp_remove_object_from_cache(params, handle);
+				continue;
+			}
+			C_PTP_REP (ret);
+		}
+		if (ob->oi.ObjectFormat!=PTP_OFC_Association)
+			continue;
+        	GP_LOG_D ("adding 0x%x to folder", ob->oid);
+		if (GP_OK == gp_list_find_by_name(list, NULL, ob->oi.Filename)) {
+			char	*buf;
+			GP_LOG_E (
+				"Duplicate foldername '%s' in folder '%s'. Ignoring nth entry.\n",
+				ob->oi.Filename, folder);
+			C_MEM (buf = malloc(strlen(ob->oi.Filename)+strlen("_012345678")+1));
+			sprintf (buf, "%s_%08x", ob->oi.Filename, ob->oid);
+			free (ob->oi.Filename);
+			ob->oi.Filename = buf;
+		}
+		CR (gp_list_append (list, ob->oi.Filename, NULL));
+	}
+	if (lastnrofobjects != params->nrofobjects) {
+		if (redoneonce++) {
+			GP_LOG_E("list changed again on second pass, returning anyway");
+			return GP_OK;
+		}
+		lastnrofobjects = params->nrofobjects;
+		gp_list_reset (list);
+		goto retry;
+	}
+	return GP_OK;
+}
+
+/* To avoid roundtrips for querying prop desc
+ * that are uninteresting for us we list all
+ * that are exposed by PTP anyway (and are r/o).
+ */
+static unsigned short uninteresting_props [] = {
+	PTP_OPC_StorageID,
+	PTP_OPC_ObjectFormat,
+	PTP_OPC_ProtectionStatus,
+	PTP_OPC_ObjectSize,
+	PTP_OPC_AssociationType,
+	PTP_OPC_AssociationDesc,
+	PTP_OPC_ParentObject
+};
+
+static int
+ptp_mtp_render_metadata (
+	PTPParams *params, uint32_t object_id, uint16_t ofc, CameraFile *file
+) {
+	uint16_t ret, *props = NULL;
+	uint32_t propcnt = 0;
+	unsigned int j;
+	MTPProperties	*mprops;
+	PTPObject	*ob;
+
+	C_PTP (ptp_object_want (params, object_id, PTPOBJECT_MTPPROPLIST_LOADED, &ob));
+
+	/* ... use little helper call to see if we missed anything in the global
+	 * retrieval. */
+	C_PTP (ptp_mtp_getobjectpropssupported (params, ofc, &propcnt, &props));
+
+	mprops = ob->mtpprops;
+	if (mprops) { /* use the fast method, without device access since cached.*/
+		char		propname[256];
+		char		text[256];
+		unsigned int	i, n;
+
+		for (j=0;j<ob->nrofmtpprops;j++) {
+			MTPProperties		*xpl = &mprops[j];
+
+			for (i=0;i<sizeof(uninteresting_props)/sizeof(uninteresting_props[0]);i++)
+				if (uninteresting_props[i] == xpl->property)
+					break;
+			/* Is uninteresting. */
+			if (i == sizeof(uninteresting_props)/sizeof(uninteresting_props[0]))
+				continue;
+			for(i=0;i<propcnt;i++) {
+				/* Mark handled property as 0 */
+				if (props[i] == xpl->property) {
+					props[i]=0;
+					break;
+				}
+			}
+
+			n = ptp_render_mtp_propname(xpl->property, sizeof(propname), propname);
+			gp_file_append (file, "<", 1);
+			gp_file_append (file, propname, n);
+			gp_file_append (file, ">", 1);
+
+			switch (xpl->datatype) {
+			default:sprintf (text, "Unknown type %d", xpl->datatype);
+				break;
+			case PTP_DTC_STR:
+				snprintf (text, sizeof(text), "%s", xpl->propval.str?xpl->propval.str:"");
+				break;
+			case PTP_DTC_INT32:
+				sprintf (text, "%d", xpl->propval.i32);
+				break;
+			case PTP_DTC_INT16:
+				sprintf (text, "%d", xpl->propval.i16);
+				break;
+			case PTP_DTC_INT8:
+				sprintf (text, "%d", xpl->propval.i8);
+				break;
+			case PTP_DTC_UINT32:
+				sprintf (text, "%u", xpl->propval.u32);
+				break;
+			case PTP_DTC_UINT16:
+				sprintf (text, "%u", xpl->propval.u16);
+				break;
+			case PTP_DTC_UINT8:
+				sprintf (text, "%u", xpl->propval.u8);
+				break;
+			}
+			gp_file_append (file, text, strlen(text));
+			gp_file_append (file, "</", 2);
+			gp_file_append (file, propname, n);
+			gp_file_append (file, ">\n", 2);
+		}
+		/* fallthrough */
+	}
+
+	for (j=0;j<propcnt;j++) {
+		char			propname[256];
+		char			text[256];
+		PTPObjectPropDesc	opd;
+		int 			i, n;
+
+		if (!props[j]) continue; /* handle above */
+
+		for (i=sizeof(uninteresting_props)/sizeof(uninteresting_props[0]);i--;)
+			if (uninteresting_props[i] == props[j])
+				break;
+		if (i != -1) /* Is uninteresting. */
+			continue;
+
+		n = ptp_render_mtp_propname(props[j], sizeof(propname), propname);
+		gp_file_append (file, "<", 1);
+		gp_file_append (file, propname, n);
+		gp_file_append (file, ">", 1);
+
+		ret = LOG_ON_PTP_E (ptp_mtp_getobjectpropdesc (params, props[j], ofc, &opd));
+		if (ret == PTP_RC_OK) {
+			PTPPropertyValue	pv;
+			ret = ptp_mtp_getobjectpropvalue (params, object_id, props[j], &pv, opd.DataType);
+			if (ret != PTP_RC_OK) {
+				sprintf (text, "failure to retrieve %x of oid %x, ret %x", props[j], object_id, ret);
+			} else {
+				switch (opd.DataType) {
+				default:sprintf (text, "Unknown type %d", opd.DataType);
+					break;
+				case PTP_DTC_STR:
+					snprintf (text, sizeof(text), "%s", pv.str?pv.str:"");
+					break;
+				case PTP_DTC_INT32:
+					sprintf (text, "%d", pv.i32);
+					break;
+				case PTP_DTC_INT16:
+					sprintf (text, "%d", pv.i16);
+					break;
+				case PTP_DTC_INT8:
+					sprintf (text, "%d", pv.i8);
+					break;
+				case PTP_DTC_UINT32:
+					sprintf (text, "%u", pv.u32);
+					break;
+				case PTP_DTC_UINT16:
+					sprintf (text, "%u", pv.u16);
+					break;
+				case PTP_DTC_UINT8:
+					sprintf (text, "%u", pv.u8);
+					break;
+				}
+			}
+			gp_file_append (file, text, strlen(text));
+		}
+		gp_file_append (file, "</", 2);
+		gp_file_append (file, propname, n);
+		gp_file_append (file, ">\n", 2);
+
+	}
+	free(props);
+	return (GP_OK);
+}
+
+/* To avoid roundtrips for querying prop desc if it is R/O
+ * we list all that are by standard means R/O.
+ */
+static unsigned short readonly_props [] = {
+	PTP_OPC_StorageID,
+	PTP_OPC_ObjectFormat,
+	PTP_OPC_ProtectionStatus,
+	PTP_OPC_ObjectSize,
+	PTP_OPC_AssociationType,
+	PTP_OPC_AssociationDesc,
+	PTP_OPC_ParentObject,
+	PTP_OPC_PersistantUniqueObjectIdentifier,
+	PTP_OPC_DateAdded,
+	PTP_OPC_CorruptOrUnplayable,
+	PTP_OPC_RepresentativeSampleFormat,
+	PTP_OPC_RepresentativeSampleSize,
+	PTP_OPC_RepresentativeSampleHeight,
+	PTP_OPC_RepresentativeSampleWidth,
+	PTP_OPC_RepresentativeSampleDuration
+};
+
+static int
+ptp_mtp_parse_metadata (
+	PTPParams *params, uint32_t object_id, uint16_t ofc, CameraFile *file
+) {
+	uint16_t ret, *props = NULL;
+	uint32_t propcnt = 0;
+	char	*filedata = NULL;
+	unsigned long	filesize = 0;
+	unsigned int j;
+
+	if (gp_file_get_data_and_size (file, (const char**)&filedata, &filesize) < GP_OK)
+		return (GP_ERROR);
+
+	C_PTP (ptp_mtp_getobjectpropssupported (params, ofc, &propcnt, &props));
+
+	for (j=0;j<propcnt;j++) {
+		char			propname[256],propname2[256];
+		char			*begin, *end, *content;
+		PTPObjectPropDesc	opd;
+		int 			i;
+		PTPPropertyValue	pv;
+
+		for (i=sizeof(readonly_props)/sizeof(readonly_props[0]);i--;)
+			if (readonly_props[i] == props[j])
+				break;
+		if (i != -1) /* Is read/only */
+			continue;
+		ptp_render_mtp_propname(props[j], sizeof(propname), propname);
+		sprintf (propname2, "<%s>", propname);
+		begin= strstr (filedata, propname2);
+		if (!begin) continue;
+		begin += strlen(propname2);
+		sprintf (propname2, "</%s>", propname);
+		end = strstr (begin, propname2);
+		if (!end) continue;
+		*end = '\0';
+		content = strdup(begin);
+		if (!content) {
+			free (props);
+			C_MEM (content);
+		}
+		*end = '<';
+		GP_LOG_D ("found tag %s, content %s", propname, content);
+		ret = LOG_ON_PTP_E (ptp_mtp_getobjectpropdesc (params, props[j], ofc, &opd));
+		if (ret != PTP_RC_OK) {
+			free (content); content = NULL;
+			continue;
+		}
+		if (opd.GetSet == 0) {
+			GP_LOG_D ("Tag %s is read only, sorry.", propname);
+			free (content); content = NULL;
+			continue;
+		}	
+		switch (opd.DataType) {
+		default:GP_LOG_E ("mtp parser: Unknown datatype %d, content %s", opd.DataType, content);
+			free (content); content = NULL;
+			continue;
+			break;
+		case PTP_DTC_STR:
+			pv.str = content;
+			break;
+		case PTP_DTC_INT32:
+			sscanf (content, "%d", &pv.i32);
+			break;
+		case PTP_DTC_INT16:
+			sscanf (content, "%hd", &pv.i16);
+			break;
+		case PTP_DTC_INT8:
+			sscanf (content, "%hhd", &pv.i8);
+			break;
+		case PTP_DTC_UINT32:
+			sscanf (content, "%u", &pv.u32);
+			break;
+		case PTP_DTC_UINT16:
+			sscanf (content, "%hu", &pv.u16);
+			break;
+		case PTP_DTC_UINT8:
+			sscanf (content, "%hhu", &pv.u8);
+			break;
+		}
+		ret = ptp_mtp_setobjectpropvalue (params, object_id, props[j], &pv, opd.DataType);
+		free (content); content = NULL;
+	}
+	free(props);
+	return (GP_OK);
+}
+
+static int
+mtp_get_playlist_string(
+	Camera *camera, uint32_t object_id, char **xcontent, int *xcontentlen
+) {
+	PTPParams *params = &camera->pl->params;
+	uint32_t	numobjects = 0, *objects = NULL;
+	unsigned int	i, contentlen = 0;
+	char		*content = NULL;
+
+	C_PTP (ptp_mtp_getobjectreferences (params, object_id, &objects, &numobjects));
+	
+	for (i=0;i<numobjects;i++) {
+		char		buf[4096];
+		int		len;
+		PTPObject 	*ob;
+
+		memset(buf, 0, sizeof(buf));
+		len = 0;
+		object_id = objects[i];
+		do {
+			C_PTP (ptp_object_want (params, object_id, PTPOBJECT_OBJECTINFO_LOADED, &ob));
+			/* make space for new filename */
+			memmove (buf+strlen(ob->oi.Filename)+1, buf, len);
+			memcpy (buf+1, ob->oi.Filename, strlen (ob->oi.Filename));
+			buf[0] = '/';
+			object_id = ob->oi.ParentObject;
+			len = strlen(buf);
+		} while (object_id != 0);
+		memmove (buf+strlen("/store_00010001"), buf, len);
+		sprintf (buf,"/store_%08x",(unsigned int)ob->oi.StorageID);
+		buf[strlen(buf)]='/';
+		len = strlen(buf);
+
+		C_MEM (content = realloc (content, contentlen+len+1+1));
+		strcpy (content+contentlen, buf);
+		strcpy (content+contentlen+len, "\n");
+		contentlen += len+1;
+	}
+	if (!content)
+		C_MEM (content = malloc(1));
+	if (xcontent)
+		*xcontent = content;
+	else
+		free (content);
+	*xcontentlen = contentlen;
+	free (objects);
+	return (GP_OK);
+}
+
+static int
+mtp_put_playlist(
+	Camera *camera, char *content, int contentlen, PTPObjectInfo *oi, GPContext *context
+) {
+	char 		*s = content;
+	unsigned char	data[1];
+	uint32_t	storage = 0, objectid, playlistid;
+	uint32_t	*oids = NULL;
+	int		nrofoids = 0;
+	PTPParams 	*params = &camera->pl->params;
+
+	while (*s) {
+		char *t = strchr(s,'\n');
+		char *fn, *filename;
+		if (t) {
+			C_MEM (fn = malloc (t-s+1));
+			memcpy (fn, s, t-s);
+			fn[t-s]='\0';
+		} else {
+			C_MEM (fn = strdup(s));
+		}
+		filename = strrchr (fn,'/');
+		if (!filename) {
+			free (fn);
+			if (!t) break;
+			s = t+1;
+			continue;
+		}
+		*filename = '\0';filename++;
+
+		/* compute storage ID value from folder patch */
+		folder_to_storage(fn,storage);
+		/* Get file number omiting storage pseudofolder */
+		find_folder_handle(params, fn, storage, objectid);
+		objectid = find_child(params, filename, storage, objectid, NULL);
+		if (objectid != PTP_HANDLER_SPECIAL) {
+			C_MEM (oids = realloc(oids, sizeof(oids[0])*(nrofoids+1)));
+			oids[nrofoids] = objectid;
+			nrofoids++;
+		} else {
+			/*fprintf (stderr,"%s/%s NOT FOUND!\n", fn, filename);*/
+			GP_LOG_E ("Object %s/%s not found on device.", fn, filename);
+		}
+		free (fn);
+		if (!t) break;
+		s = t+1;
+	}
+	oi->ObjectCompressedSize = 1;
+	oi->ObjectFormat = PTP_OFC_MTP_AbstractAudioVideoPlaylist;
+	C_PTP_MSG (ptp_sendobjectinfo(&camera->pl->params, &storage, &oi->ParentObject, &playlistid, oi),
+		   "failed sendobjectinfo of playlist.");
+	C_PTP_MSG (ptp_sendobject(&camera->pl->params, (unsigned char*)data, 1),
+		   "failed dummy sendobject of playlist.");
+	C_PTP (ptp_mtp_setobjectreferences (&camera->pl->params, playlistid, oids, nrofoids));
+	/* update internal structures */
+	return add_object(camera, playlistid, context);
+}
+
+static int
+mtp_get_playlist(
+	Camera *camera, CameraFile *file, uint32_t object_id, GPContext *context
+) {
+	char	*content;
+	int	contentlen;
+
+	CR (mtp_get_playlist_string( camera, object_id, &content, &contentlen));
+	/* takes ownership of content */
+	return gp_file_set_data_and_size (file, content, contentlen);
+}
+
+typedef struct {
+	CameraFile	*file;
+} PTPCFHandlerPrivate;
+
+static uint16_t
+gpfile_getfunc (PTPParams *params, void *xpriv,
+	unsigned long wantlen, unsigned char *bytes,
+	unsigned long *gotlen
+) {
+	PTPCFHandlerPrivate* priv = (PTPCFHandlerPrivate*)xpriv;
+	int ret;
+	size_t	gotlensize;
+
+	ret = gp_file_slurp (priv->file, (char*)bytes, wantlen, &gotlensize);
+	*gotlen = gotlensize;
+	if (ret != GP_OK)
+		return PTP_ERROR_IO;
+	return PTP_RC_OK;
+}
+
+static uint16_t
+gpfile_putfunc (PTPParams *params, void *xpriv,
+	unsigned long sendlen, unsigned char *bytes
+) {
+	PTPCFHandlerPrivate* priv= (PTPCFHandlerPrivate*)xpriv;
+	int ret;
+	
+	ret = gp_file_append (priv->file, (char*)bytes, sendlen);
+	if (ret != GP_OK)
+		return PTP_ERROR_IO;
+	return PTP_RC_OK;
+}
+
+uint16_t
+ptp_init_camerafile_handler (PTPDataHandler *handler, CameraFile *file) {
+	PTPCFHandlerPrivate* priv = malloc (sizeof(PTPCFHandlerPrivate));
+	if (!priv) return PTP_RC_GeneralError;
+	handler->priv = priv;
+	handler->getfunc = gpfile_getfunc;
+	handler->putfunc = gpfile_putfunc;
+	priv->file = file;
+	return PTP_RC_OK;
+}
+
+uint16_t
+ptp_exit_camerafile_handler (PTPDataHandler *handler) {
+	free (handler->priv);
+	return PTP_RC_OK;
+}
+
+
+static int
+read_file_func (CameraFilesystem *fs, const char *folder, const char *filename,
+	        CameraFileType type,
+		uint64_t offset64, char *buf, uint64_t *size64,
+		void *data, GPContext *context)
+{
+	Camera *camera = data;
+	PTPParams *params = &camera->pl->params;
+	/* Note that "image" points to unsigned chars whereas all the other
+	 * functions which set image return pointers to chars.
+	 * However, we calculate a number of unsigned values in this function,
+	 * so we cannot make it signed either.
+	 * Therefore, sometimes a "ximage" char* helper, since wild casts of pointers
+	 * confuse the compilers aliasing mechanisms.
+	 * If you do not like that, feel free to clean up the datatypes.
+	 * (TODO for Marcus and 2.2 ;)
+	 */
+	uint32_t oid;
+	uint32_t storage;
+	uint32_t xsize;
+	uint32_t offset = offset64, size = *size64;
+	PTPObject *ob;
+
+	SET_CONTEXT_P(params, context);
+	C_PARAMS_MSG (offset64 + *size64 <= 0xffffffff, "offset + size exceeds 32bit");
+	C_PARAMS_MSG (strcmp (folder, "/special"), "file not found");
+
+	if (!ptp_operation_issupported(params, PTP_OC_GetPartialObject))
+		return (GP_ERROR_NOT_SUPPORTED);
+
+	/* compute storage ID value from folder patch */
+	folder_to_storage(folder,storage);
+	/* Get file number omiting storage pseudofolder */
+	find_folder_handle(params, folder, storage, oid);
+	oid = find_child(params, filename, storage, oid, &ob);
+	if (oid == PTP_HANDLER_SPECIAL) {
+		gp_context_error (context, _("File '%s/%s' does not exist."), folder, filename);
+		return GP_ERROR_BAD_PARAMETERS;
+	}
+	GP_LOG_D ("Reading %u bytes from file '%s' at offset %u.", size, filename, offset);
+	switch (type) {
+	default:
+		return (GP_ERROR_NOT_SUPPORTED);
+	case GP_FILE_TYPE_NORMAL: {
+		uint16_t	ret;
+		unsigned char	*xdata;
+
+		/* We do not allow downloading unknown type files as in most
+		cases they are special file (like firmware or control) which
+		sometimes _cannot_ be downloaded. doing so we avoid errors.*/
+		/* however this avoids the possibility to download files on
+		 * Androids ... doh. Let reenable it again. */
+		if (ob->oi.ObjectFormat == PTP_OFC_Association
+	/*
+			|| (ob->oi.ObjectFormat == PTP_OFC_Undefined &&
+				((ob->oi.ThumbFormat == PTP_OFC_Undefined) ||
+				 (ob->oi.ThumbFormat == 0)
+			)
+			) */
+		)
+			return (GP_ERROR_NOT_SUPPORTED);
+
+		if (is_mtp_capable (camera) &&
+		    (ob->oi.ObjectFormat == PTP_OFC_MTP_AbstractAudioVideoPlaylist))
+			return (GP_ERROR_NOT_SUPPORTED);
+
+		xsize=ob->oi.ObjectCompressedSize;
+		if (!xsize)
+			return (GP_ERROR_NOT_SUPPORTED);
+
+		if (size+offset > xsize)
+			size = xsize - offset;
+		ret = ptp_getpartialobject(params, oid, offset, size, &xdata, &size);
+		if (ret == PTP_ERROR_CANCEL)
+			return GP_ERROR_CANCEL;
+		C_PTP_REP (ret);
+		*size64 = size;
+		memcpy (buf, xdata, size);
+		free (xdata);
+		/* clear the "new" flag on Canons */
+		if (	(params->deviceinfo.VendorExtensionID == PTP_VENDOR_CANON) &&
+			(ob->canon_flags & 0x20) &&
+			ptp_operation_issupported(params,PTP_OC_CANON_SetObjectArchive)
+		) {
+			/* seems just a byte (0x20 - new) */
+			C_PTP_REP (ptp_canon_setobjectarchive (params, oid, ob->canon_flags & ~0x20));
+			ob->canon_flags &= ~0x20;
+		}
+		}
+		break;
+	}
+	return GP_OK;
+}
+
+static int
+get_file_func (CameraFilesystem *fs, const char *folder, const char *filename,
+	       CameraFileType type, CameraFile *file, void *data,
+	       GPContext *context)
+{
+	Camera *camera = data;
+	/* Note that "image" points to unsigned chars whereas all the other
+	 * functions which set image return pointers to chars.
+	 * However, we calculate a number of unsigned values in this function,
+	 * so we cannot make it signed either.
+	 * Therefore, sometimes a "ximage" char* helper, since wild casts of pointers
+	 * confuse the compilers aliasing mechanisms.
+	 * If you do not like that, feel free to clean up the datatypes.
+	 * (TODO for Marcus and 2.2 ;)
+	 */
+	uint32_t oid;
+	uint32_t size;
+	uint32_t storage;
+	PTPObject *ob;
+	PTPParams *params = &camera->pl->params;
+
+	SET_CONTEXT_P(params, context);
+
+#if 0
+	/* The new Canons like to switch themselves off in the middle. */
+	if (params->deviceinfo.VendorExtensionID == PTP_VENDOR_CANON) {
+		if (ptp_operation_issupported(params, PTP_OC_CANON_KeepDeviceOn))
+			ptp_canon_keepdeviceon (params);
+	}
+#endif
+
+	if (!strcmp (folder, "/special")) {
+		unsigned int i;
+
+		for (i=0;i<nrofspecial_files;i++)
+			if (!strcmp (special_files[i].name, filename))
+				return special_files[i].getfunc (fs, folder, filename, type, file, data, context);
+		return (GP_ERROR_BAD_PARAMETERS); /* file not found */
+	}
+
+	/* compute storage ID value from folder patch */
+	folder_to_storage(folder,storage);
+	/* Get file number omiting storage pseudofolder */
+	find_folder_handle(params, folder, storage, oid);
+	oid = find_child(params, filename, storage, oid, &ob);
+	if (oid == PTP_HANDLER_SPECIAL) {
+		gp_context_error (context, _("File '%s/%s' does not exist."), folder, filename);
+		return GP_ERROR_BAD_PARAMETERS;
+	}
+	if (ob->oi.ModificationDate != 0)
+		gp_file_set_mtime (file, ob->oi.ModificationDate);
+	else
+		gp_file_set_mtime (file, ob->oi.CaptureDate);
+
+	GP_LOG_D ("Getting file '%s'.", filename);
+	switch (type) {
+	case	GP_FILE_TYPE_EXIF: {
+		uint32_t offset, xlen, maxbytes;
+		unsigned char 	*ximage = NULL;
+
+		/* Check if we have partial downloads. Otherwise we can just hope
+		 * upstream downloads the whole image to get EXIF data. */
+		if (!ptp_operation_issupported(params, PTP_OC_GetPartialObject))
+			return (GP_ERROR_NOT_SUPPORTED);
+		/* Device may hang is a partial read is attempted beyond the file */
+		if (ob->oi.ObjectCompressedSize < 10)
+			return (GP_ERROR_NOT_SUPPORTED);
+
+		/* We only support JPEG / EXIF format ... others might hang. */
+		if (ob->oi.ObjectFormat != PTP_OFC_EXIF_JPEG)
+			return (GP_ERROR_NOT_SUPPORTED);
+
+		/* Note: Could also use Canon partial downloads */
+		C_PTP_REP (ptp_getpartialobject (params,
+			oid, 0, 10, &ximage, &xlen));
+
+		if (!((ximage[0] == 0xff) && (ximage[1] == 0xd8))) {	/* SOI */
+			free (ximage);
+			return (GP_ERROR_NOT_SUPPORTED);
+		}
+		if (!((ximage[2] == 0xff) && (ximage[3] == 0xe1))) {	/* App0 */
+			free (ximage);
+			return (GP_ERROR_NOT_SUPPORTED);
+		}
+		if (0 != memcmp(ximage+6, "Exif", 4)) {
+			free (ximage);
+			return (GP_ERROR_NOT_SUPPORTED);
+		}
+		offset = 2;
+		maxbytes = (ximage[4] << 8 ) + ximage[5];
+		free (ximage);
+		ximage = NULL;
+		C_PTP_REP (ptp_getpartialobject (params,
+			oid, offset, maxbytes, &ximage, &xlen));
+		CR (gp_file_set_data_and_size (file, (char*)ximage, xlen));
+		break;
+	}
+	case	GP_FILE_TYPE_PREVIEW: {
+		unsigned char *ximage = NULL;
+		unsigned int xlen;
+
+		/* If thumb size is 0, and the ofc is not an image type (0x38xx or 0xb8xx)
+		 * then there is no thumbnail at all... */
+		size=ob->oi.ThumbCompressedSize;
+		if((size==0) && (
+			((ob->oi.ObjectFormat & 0x7800) != 0x3800) &&
+			((ob->oi.ObjectFormat != PTP_OFC_CANON_CRW)) &&
+			((ob->oi.ObjectFormat != PTP_OFC_CANON_MOV)) &&
+			((ob->oi.ObjectFormat != PTP_OFC_CANON_MOV2)) &&
+			((ob->oi.ObjectFormat != PTP_OFC_CANON_CRW3))
+		))
+			return GP_ERROR_NOT_SUPPORTED;
+		C_PTP_REP (ptp_getthumb(params, oid, &ximage, &xlen));
+		set_mimetype (file, params->deviceinfo.VendorExtensionID, ob->oi.ThumbFormat);
+		CR (gp_file_set_data_and_size (file, (char*)ximage, xlen));
+		break;
+	}
+	case	GP_FILE_TYPE_METADATA:
+		if (is_mtp_capable (camera) &&
+		    ptp_operation_issupported(params,PTP_OC_MTP_GetObjectPropsSupported)
+		)
+			return ptp_mtp_render_metadata (params,oid,ob->oi.ObjectFormat,file);
+		return (GP_ERROR_NOT_SUPPORTED);
+	default: {
+		if (ob->oi.ObjectFormat == PTP_OFC_Association)
+			return GP_ERROR_NOT_SUPPORTED;
+
+		/* We do not allow downloading unknown type files as in most
+		 * cases they are special file (like firmware or control) which
+		 * sometimes _cannot_ be downloaded. doing so we avoid errors.
+		 * Allow all types from MTP devices, like phones.
+		 */
+		if (	!is_mtp_capable (camera) &&
+			(ob->oi.ObjectFormat == PTP_OFC_Undefined &&
+				((ob->oi.ThumbFormat == PTP_OFC_Undefined) ||
+				 (ob->oi.ThumbFormat == 0)
+			)
+			)
+		)
+			return (GP_ERROR_NOT_SUPPORTED);
+
+		if (is_mtp_capable (camera) &&
+		    (ob->oi.ObjectFormat == PTP_OFC_MTP_AbstractAudioVideoPlaylist))
+			return mtp_get_playlist (camera, file, oid, context);
+
+		size=ob->oi.ObjectCompressedSize;
+		if (size) {
+			uint16_t	ret;
+			PTPDataHandler	handler;
+
+			ptp_init_camerafile_handler (&handler, file);
+			ret = ptp_getobject_to_handler(params, oid, &handler);
+			ptp_exit_camerafile_handler (&handler);
+			if (ret == PTP_ERROR_CANCEL)
+				return GP_ERROR_CANCEL;
+			C_PTP_REP (ret);
+		} else {
+			unsigned char *ximage = NULL;
+			/* Do not download 0 sized files.
+			 * It is not necessary and even breaks for some camera special files.
+			 */
+			C_MEM (ximage = malloc(1));
+			CR (gp_file_set_data_and_size (file, (char*)ximage, size));
+		}
+
+		/* clear the "new" flag on Canons */
+		if (	(params->deviceinfo.VendorExtensionID == PTP_VENDOR_CANON) &&
+			(ob->canon_flags & 0x20) &&
+			ptp_operation_issupported(params,PTP_OC_CANON_SetObjectArchive)
+		) {
+			/* seems just a byte (0x20 - new) */
+			C_PTP_REP (ptp_canon_setobjectarchive (params, oid, ob->canon_flags &~0x20));
+			ob->canon_flags &= ~0x20;
+		}
+		break;
+	}
+	}
+	return set_mimetype (file, params->deviceinfo.VendorExtensionID, ob->oi.ObjectFormat);
+}
+
+static int
+put_file_func (CameraFilesystem *fs, const char *folder, const char *filename,
+		CameraFileType type, CameraFile *file, void *data, GPContext *context)
+{
+	Camera *camera = data;
+	PTPObjectInfo oi;
+	uint32_t parent;
+	uint32_t storage;
+	uint32_t handle;
+	unsigned long intsize;
+	PTPParams* params = &camera->pl->params;
+
+	SET_CONTEXT_P(params, context);
+	camera->pl->checkevents = TRUE;
+
+	GP_LOG_D ("folder=%s, filename=%s", folder, filename);
+
+	if (!strcmp (folder, "/special")) {
+		unsigned int i;
+
+		for (i=0;i<nrofspecial_files;i++)
+			if (!strcmp (special_files[i].name, filename))
+				return special_files[i].putfunc (fs, folder, file, data, context);
+		return (GP_ERROR_BAD_PARAMETERS); /* file not found */
+	}
+	memset(&oi, 0, sizeof (PTPObjectInfo));
+	if (type == GP_FILE_TYPE_METADATA) {
+		if (is_mtp_capable (camera) &&
+		    ptp_operation_issupported(params,PTP_OC_MTP_GetObjectPropsSupported)
+		) {
+			uint32_t object_id;
+			PTPObject	*ob;
+
+			/* compute storage ID value from folder patch */
+			folder_to_storage(folder,storage);
+
+			/* Get file number omiting storage pseudofolder */
+			find_folder_handle(params, folder, storage, object_id);
+			object_id = find_child(params, filename, storage, object_id, &ob);
+			if (object_id ==PTP_HANDLER_SPECIAL) {
+				gp_context_error (context, _("File '%s/%s' does not exist."), folder, filename);
+				return (GP_ERROR_BAD_PARAMETERS);
+			}
+			return ptp_mtp_parse_metadata (params,object_id,ob->oi.ObjectFormat,file);
+		}
+		gp_context_error (context, _("Metadata only supported for MTP devices."));
+		return GP_ERROR_NOT_SUPPORTED;
+	}
+	C_PARAMS (type == GP_FILE_TYPE_NORMAL);
+	/* compute storage ID value from folder patch */
+	folder_to_storage(folder,storage);
+
+	/* get parent folder id omiting storage pseudofolder */
+	find_folder_handle(params,folder,storage,parent);
+
+	/* if you desire to put file to root folder, you have to use
+	 * 0xffffffff instead of 0x00000000 (which means responder decide).
+	 */
+	if (parent==PTP_HANDLER_ROOT) parent=PTP_HANDLER_SPECIAL;
+
+	/* We don't really want a file to exist with the same name twice. */
+	handle = find_child (params, filename, storage, parent, NULL);
+	if (handle != PTP_HANDLER_SPECIAL) {
+		GP_LOG_D ("%s/%s exists.", folder, filename);
+		return GP_ERROR_FILE_EXISTS;
+	}
+
+	oi.Filename=(char *)filename;
+	oi.ObjectFormat = get_mimetype(camera, file, params->deviceinfo.VendorExtensionID);
+	oi.ParentObject = parent;
+	gp_file_get_mtime(file, &oi.ModificationDate);
+
+	if (is_mtp_capable (camera) &&
+	    (	strstr(filename,".zpl") || strstr(filename, ".pla") )) {
+		char *object;
+		gp_file_get_data_and_size (file, (const char**)&object, &intsize);
+		return mtp_put_playlist (camera, object, intsize, &oi, context);
+	}
+
+	/* If the device is using PTP_VENDOR_EASTMAN_KODAK extension try
+	 * PTP_OC_EK_SendFileObject.
+	 */
+	gp_file_get_data_and_size (file, NULL, &intsize);
+	oi.ObjectCompressedSize = intsize;
+	if ((params->deviceinfo.VendorExtensionID==PTP_VENDOR_EASTMAN_KODAK) &&
+		(ptp_operation_issupported(params, PTP_OC_EK_SendFileObject)))
+	{
+		PTPDataHandler handler;
+		C_PTP_REP (ptp_ek_sendfileobjectinfo (params, &storage,
+			&parent, &handle, &oi));
+		ptp_init_camerafile_handler (&handler, file);
+		C_PTP_REP (ptp_ek_sendfileobject_from_handler (params, &handler, intsize));
+		ptp_exit_camerafile_handler (&handler);
+	} else if (ptp_operation_issupported(params, PTP_OC_SendObjectInfo)) {
+		uint16_t	ret;
+		PTPDataHandler handler;
+
+		C_PTP_REP (ptp_sendobjectinfo (params, &storage,
+			&parent, &handle, &oi));
+		ptp_init_camerafile_handler (&handler, file);
+		ret = ptp_sendobject_from_handler (params, &handler, intsize);
+		ptp_exit_camerafile_handler (&handler);
+		if (ret == PTP_ERROR_CANCEL)
+			return (GP_ERROR_CANCEL);
+		C_PTP_REP (ret);
+	} else {
+		GP_LOG_D ("The device does not support uploading files.");
+		return GP_ERROR_NOT_SUPPORTED;
+	}
+	/* update internal structures */
+	return add_object(camera, handle, context);
+}
+
+static int
+delete_file_func (CameraFilesystem *fs, const char *folder,
+			const char *filename, void *data, GPContext *context)
+{
+	Camera *camera = data;
+	uint32_t	oid;
+	uint32_t	storage;
+	PTPParams *params = &camera->pl->params;
+
+	SET_CONTEXT_P(params, context);
+
+	if (!strcmp (folder, "/special"))
+		return GP_ERROR_NOT_SUPPORTED;
+
+	/* virtual file created by Nikon special capture */
+	if (	((params->deviceinfo.VendorExtensionID == PTP_VENDOR_NIKON) ||
+		 (params->deviceinfo.VendorExtensionID == PTP_VENDOR_CANON) ||
+		 (params->deviceinfo.VendorExtensionID == PTP_VENDOR_SONY) ||
+		 (params->device_flags & DEVICE_FLAG_OLYMPUS_XML_WRAPPED)) &&
+		!strncmp (filename, "capt", 4)
+	)
+		return GP_OK;
+
+	if (!ptp_operation_issupported(params, PTP_OC_DeleteObject))
+		return GP_ERROR_NOT_SUPPORTED;
+
+	camera->pl->checkevents = TRUE;
+	C_PTP_REP (ptp_check_event (params));
+	/* compute storage ID value from folder patch */
+	folder_to_storage(folder,storage);
+	/* Get file number omiting storage pseudofolder */
+	find_folder_handle(params, folder, storage, oid);
+	oid = find_child(params, filename, storage, oid, NULL);
+
+	C_PTP_REP (ptp_deleteobject(params, oid, 0));
+
+	/* On some Canon firmwares, a DeleteObject causes a ObjectRemoved event
+	 * to be sent. At least on Digital IXUS II and PowerShot A85. But
+         * not on 350D.
+	 */
+	if (DELETE_SENDS_EVENT(params) &&
+	    ptp_event_issupported(params, PTP_EC_ObjectRemoved)) {
+		PTPContainer event;
+
+		ptp_check_event (params); /* ignore errors */
+		while (ptp_get_one_event (params, &event)) {
+			if (event.Code == PTP_EC_ObjectRemoved)
+				break;
+			if (event.Code == PTP_EC_ObjectAdded) {
+				PTPObject *ob;
+
+				ptp_object_want (params, event.Param1, 0, &ob);
+			}
+		}
+		/* FIXME: need to handle folder additions during capture-image-and-download */
+ 	}
+	return (GP_OK);
+}
+
+static int
+remove_dir_func (CameraFilesystem *fs, const char *folder,
+			const char *foldername, void *data, GPContext *context)
+{
+	Camera *camera = data;
+	uint32_t oid;
+	uint32_t storage;
+	PTPParams *params = &camera->pl->params;
+
+	SET_CONTEXT_P(params, context);
+
+	if (!ptp_operation_issupported(params, PTP_OC_DeleteObject))
+		return GP_ERROR_NOT_SUPPORTED;
+	camera->pl->checkevents = TRUE;
+	/* compute storage ID value from folder patch */
+	folder_to_storage(folder,storage);
+	/* Get file number omiting storage pseudofolder */
+	find_folder_handle(params, folder, storage, oid);
+	oid = find_child(params, foldername, storage, oid, NULL);
+	if (oid == PTP_HANDLER_SPECIAL)
+		return GP_ERROR;
+	C_PTP_REP (ptp_deleteobject(params, oid, 0));
+	return (GP_OK);
+}
+
+static int
+set_info_func (CameraFilesystem *fs, const char *folder, const char *filename,
+	       CameraFileInfo info, void *data, GPContext *context)
+{
+	Camera *camera = data;
+	PTPObject *ob;
+	uint32_t object_id;
+	uint32_t storage;
+	PTPParams *params = &camera->pl->params;
+
+	SET_CONTEXT_P(params, context);
+
+	C_PARAMS (strcmp (folder, "/special"));
+
+	camera->pl->checkevents = TRUE;
+	/* compute storage ID value from folder patch */
+	folder_to_storage(folder,storage);
+	/* Get file number omiting storage pseudofolder */
+	find_folder_handle(params, folder, storage, object_id);
+	object_id = find_child(params, filename, storage, object_id, &ob);
+	if (object_id == PTP_HANDLER_SPECIAL)
+		return GP_ERROR;
+
+	if (info.file.fields & GP_FILE_INFO_PERMISSIONS) {
+		uint16_t newprot;
+
+		if ((info.file.permissions & GP_FILE_PERM_DELETE) != GP_FILE_PERM_DELETE)
+			newprot = PTP_PS_ReadOnly;
+		else
+			newprot = PTP_PS_NoProtection;
+		if (ob->oi.ProtectionStatus != newprot) {
+			if (!ptp_operation_issupported(params, PTP_OC_SetObjectProtection)) {
+				gp_context_error (context, _("Device does not support setting object protection."));
+				return (GP_ERROR_NOT_SUPPORTED);
+			}
+			C_PTP_REP_MSG (ptp_setobjectprotection (params, object_id, newprot),
+				       _("Device failed to set object protection to %d"), newprot);
+			ob->oi.ProtectionStatus = newprot; /* should actually reread objectinfo to be sure, but lets not. */
+		}
+		info.file.fields &= ~GP_FILE_INFO_PERMISSIONS;
+		/* fall through */
+	}
+	/* ... no more cases implemented yet */
+	return (GP_OK);
+}
+
+static int
+get_info_func (CameraFilesystem *fs, const char *folder, const char *filename,
+	       CameraFileInfo *info, void *data, GPContext *context)
+{
+	Camera *camera = data;
+	PTPObject *ob;
+	uint32_t oid, storage;
+	PTPParams *params = &camera->pl->params;
+
+	SET_CONTEXT_P(params, context);
+
+	C_PARAMS (strcmp (folder, "/special"));
+
+	/* compute storage ID value from folder patch */
+	folder_to_storage(folder,storage);
+	/* Get file number omiting storage pseudofolder */
+	find_folder_handle(params, folder, storage, oid);
+	oid = find_child(params, filename, storage, oid, &ob);
+	if (oid == PTP_HANDLER_SPECIAL)
+		return GP_ERROR;
+
+	info->file.fields = GP_FILE_INFO_SIZE|GP_FILE_INFO_TYPE|GP_FILE_INFO_MTIME;
+	info->file.size   = ob->oi.ObjectCompressedSize;
+
+	if (params->deviceinfo.VendorExtensionID == PTP_VENDOR_CANON) {
+		info->file.fields |= GP_FILE_INFO_STATUS;
+		if (ob->canon_flags & 0x20)
+			info->file.status = GP_FILE_STATUS_NOT_DOWNLOADED;
+		else
+			info->file.status = GP_FILE_STATUS_DOWNLOADED;
+	}
+
+	/* MTP playlists have their own size calculation */
+	if (is_mtp_capable (camera) &&
+	    (ob->oi.ObjectFormat == PTP_OFC_MTP_AbstractAudioVideoPlaylist)) {
+		int contentlen;
+		CR (mtp_get_playlist_string (camera, oid, NULL, &contentlen));
+		info->file.size = contentlen;
+	}
+
+	strcpy_mime (info->file.type, params->deviceinfo.VendorExtensionID, ob->oi.ObjectFormat);
+	if (ob->oi.ModificationDate != 0) {
+		info->file.mtime = ob->oi.ModificationDate;
+	} else {
+		info->file.mtime = ob->oi.CaptureDate;
+	}
+
+	switch (ob->oi.ProtectionStatus) {
+	case PTP_PS_NoProtection:
+		info->file.fields	|= GP_FILE_INFO_PERMISSIONS;
+		info->file.permissions	 = GP_FILE_PERM_READ|GP_FILE_PERM_DELETE;
+		break;
+	case PTP_PS_ReadOnly:
+		info->file.fields	|= GP_FILE_INFO_PERMISSIONS;
+		info->file.permissions	 = GP_FILE_PERM_READ;
+		break;
+	default:
+		GP_LOG_E ("mapping protection to gp perm failed, prot is %x", ob->oi.ProtectionStatus);
+		break;
+	}
+
+	/* if object is an image */
+	if ((ob->oi.ObjectFormat & 0x0800) != 0) {
+		info->preview.fields = 0;
+		strcpy_mime(info->preview.type, params->deviceinfo.VendorExtensionID, ob->oi.ThumbFormat);
+		if (strlen(info->preview.type)) {
+			info->preview.fields |= GP_FILE_INFO_TYPE;
+		}
+		if (ob->oi.ThumbCompressedSize) {
+			info->preview.size   = ob->oi.ThumbCompressedSize;
+			info->preview.fields |= GP_FILE_INFO_SIZE;
+		}
+		if (ob->oi.ThumbPixWidth) {
+			info->preview.width  = ob->oi.ThumbPixWidth;
+			info->preview.fields |= GP_FILE_INFO_WIDTH;
+		}
+		if (ob->oi.ThumbPixHeight) {
+			info->preview.height  = ob->oi.ThumbPixHeight;
+			info->preview.fields |= GP_FILE_INFO_HEIGHT;
+		}
+		if (ob->oi.ImagePixWidth) {
+			info->file.width  = ob->oi.ImagePixWidth;
+			info->file.fields |= GP_FILE_INFO_WIDTH;
+		}
+		if (ob->oi.ImagePixHeight) {
+			info->file.height  = ob->oi.ImagePixHeight;
+			info->file.fields |= GP_FILE_INFO_HEIGHT;
+		}
+	}	
+	return (GP_OK);
+}
+
+static int
+make_dir_func (CameraFilesystem *fs, const char *folder, const char *foldername,
+	       void *data, GPContext *context)
+{
+	Camera *camera = data;
+	PTPObjectInfo oi;
+	uint32_t parent;
+	uint32_t storage;
+	uint32_t handle;
+	PTPParams* params = &camera->pl->params;
+
+	if (!strcmp (folder, "/special"))
+		return GP_ERROR_NOT_SUPPORTED;
+
+	SET_CONTEXT_P(params, context);
+	camera->pl->checkevents = TRUE;
+
+	memset(&oi, 0, sizeof (PTPObjectInfo));
+	/* compute storage ID value from folder patch */
+	folder_to_storage(folder,storage);
+	/* get parent folder id omiting storage pseudofolder */
+	find_folder_handle(params,folder,storage,parent);
+
+	/* if you desire to make dir in 'root' folder, you have to use
+	 * 0xffffffff instead of 0x00000000 (which means responder decide).
+	 */
+	if (parent==PTP_HANDLER_ROOT) parent=PTP_HANDLER_SPECIAL;
+
+	handle = folder_to_handle (params, foldername, storage, parent, NULL);
+	if (handle != PTP_HANDLER_SPECIAL)
+		return GP_ERROR_DIRECTORY_EXISTS;
+
+	oi.Filename=(char *)foldername;
+
+	oi.ObjectFormat=PTP_OFC_Association;
+	oi.ProtectionStatus=PTP_PS_NoProtection;
+	oi.AssociationType=PTP_AT_GenericFolder;
+
+	if ((params->deviceinfo.VendorExtensionID==
+			PTP_VENDOR_EASTMAN_KODAK) &&
+		(ptp_operation_issupported(params,
+			PTP_OC_EK_SendFileObjectInfo)))
+	{
+		C_PTP_REP (ptp_ek_sendfileobjectinfo (params, &storage,
+			&parent, &handle, &oi));
+	} else if (ptp_operation_issupported(params, PTP_OC_SendObjectInfo)) {
+		C_PTP_REP (ptp_sendobjectinfo (params, &storage,
+			&parent, &handle, &oi));
+	} else {
+		GP_LOG_D ("The device does not support creating a folder.");
+		return GP_ERROR_NOT_SUPPORTED;
+	}
+	/* update internal structures */
+	return add_object(camera, handle, context);
+}
+
+static int
+storage_info_func (CameraFilesystem *fs,
+		CameraStorageInformation **sinfos,
+		int *nrofsinfos,
+		void *data, GPContext *context
+) {
+	Camera *camera 		= data;
+	PTPParams *params 	= &camera->pl->params;
+	PTPStorageInfo		si;
+	PTPStorageIDs		sids;
+	unsigned int		i,n;
+	CameraStorageInformation*sif;
+
+	if (!ptp_operation_issupported (params, PTP_OC_GetStorageIDs))
+		return (GP_ERROR_NOT_SUPPORTED);
+
+	SET_CONTEXT_P(params, context);
+	C_PTP (ptp_getstorageids (params, &sids));
+	n = 0;
+	C_MEM (*sinfos = calloc (sids.n, sizeof (CameraStorageInformation)));
+	for (i = 0; i<sids.n; i++) {
+		sif = (*sinfos)+n;
+
+		/* Invalid storage, storageinfo might cause hangs on it (Nikon D300s e.g.) */
+		if ((sids.Storage[i]&0x0000ffff)==0) continue;
+
+		C_PTP (ptp_getstorageinfo (params, sids.Storage[i], &si));
+		sif->fields |= GP_STORAGEINFO_BASE;
+		sprintf (sif->basedir, "/"STORAGE_FOLDER_PREFIX"%08x", sids.Storage[i]);
+		
+		if (si.VolumeLabel && strlen(si.VolumeLabel)) {
+			sif->fields |= GP_STORAGEINFO_LABEL;
+			strcpy (sif->label, si.VolumeLabel);
+		}
+		if (si.StorageDescription && strlen(si.StorageDescription)) {
+			sif->fields |= GP_STORAGEINFO_DESCRIPTION;
+			strcpy (sif->description, si.StorageDescription);
+		}
+		sif->fields |= GP_STORAGEINFO_STORAGETYPE;
+		switch (si.StorageType) {
+		case PTP_ST_Undefined:
+			sif->type = GP_STORAGEINFO_ST_UNKNOWN;
+			break;
+		case PTP_ST_FixedROM:
+			sif->type = GP_STORAGEINFO_ST_FIXED_ROM;
+			break;
+		case PTP_ST_FixedRAM:
+			sif->type = GP_STORAGEINFO_ST_FIXED_RAM;
+			break;
+		case PTP_ST_RemovableRAM:
+			sif->type = GP_STORAGEINFO_ST_REMOVABLE_RAM;
+			break;
+		case PTP_ST_RemovableROM:
+			sif->type = GP_STORAGEINFO_ST_REMOVABLE_ROM;
+			break;
+		default:
+			GP_LOG_D ("unknown storagetype 0x%x", si.StorageType);
+			sif->type = GP_STORAGEINFO_ST_UNKNOWN;
+			break;
+		}
+		sif->fields |= GP_STORAGEINFO_ACCESS;
+		switch (si.AccessCapability) {
+		case PTP_AC_ReadWrite:
+			sif->access = GP_STORAGEINFO_AC_READWRITE;
+			break;
+		case PTP_AC_ReadOnly:
+			sif->access = GP_STORAGEINFO_AC_READONLY;
+			break;
+		case PTP_AC_ReadOnly_with_Object_Deletion:
+			sif->access = GP_STORAGEINFO_AC_READONLY_WITH_DELETE;
+			break;
+		default:
+			GP_LOG_D ("unknown accesstype 0x%x", si.AccessCapability);
+			sif->access = GP_STORAGEINFO_AC_READWRITE;
+			break;
+		}
+		sif->fields |= GP_STORAGEINFO_FILESYSTEMTYPE;
+		switch (si.FilesystemType) {
+		default:
+		case PTP_FST_Undefined:
+			sif->fstype = GP_STORAGEINFO_FST_UNDEFINED;
+			break;
+		case PTP_FST_GenericFlat:
+			sif->fstype = GP_STORAGEINFO_FST_GENERICFLAT;
+			break;
+		case PTP_FST_GenericHierarchical:
+			sif->fstype = GP_STORAGEINFO_FST_GENERICHIERARCHICAL;
+			break;
+		case PTP_FST_DCF:
+			sif->fstype = GP_STORAGEINFO_FST_DCF;
+			break;
+		}
+		sif->fields |= GP_STORAGEINFO_MAXCAPACITY;
+		sif->capacitykbytes = si.MaxCapability / 1024;
+		sif->fields |= GP_STORAGEINFO_FREESPACEKBYTES;
+		sif->freekbytes = si.FreeSpaceInBytes / 1024;
+		if (si.FreeSpaceInImages != -1) {
+			sif->fields |= GP_STORAGEINFO_FREESPACEIMAGES;
+			sif->freeimages = si.FreeSpaceInImages;
+		}
+		free (si.StorageDescription);
+		free (si.VolumeLabel);
+
+		n++;
+	}
+	free (sids.Storage);
+	*nrofsinfos = n;
+	return (GP_OK);
+}
+
+static void
+debug_objectinfo(PTPParams *params, uint32_t oid, PTPObjectInfo *oi) {
+	GP_LOG_D ("ObjectInfo for '%s':", oi->Filename);
+	GP_LOG_D ("  Object ID: 0x%08x", oid);
+	GP_LOG_D ("  StorageID: 0x%08x", oi->StorageID);
+	GP_LOG_D ("  ObjectFormat: 0x%04x", oi->ObjectFormat);
+	GP_LOG_D ("  ProtectionStatus: 0x%04x", oi->ProtectionStatus);
+	GP_LOG_D ("  ObjectCompressedSize: %ld", (unsigned long)oi->ObjectCompressedSize);
+	GP_LOG_D ("  ThumbFormat: 0x%04x", oi->ThumbFormat);
+	GP_LOG_D ("  ThumbCompressedSize: %d", oi->ThumbCompressedSize);
+	GP_LOG_D ("  ThumbPixWidth: %d", oi->ThumbPixWidth);
+	GP_LOG_D ("  ThumbPixHeight: %d", oi->ThumbPixHeight);
+	GP_LOG_D ("  ImagePixWidth: %d", oi->ImagePixWidth);
+	GP_LOG_D ("  ImagePixHeight: %d", oi->ImagePixHeight);
+	GP_LOG_D ("  ImageBitDepth: %d", oi->ImageBitDepth);
+	GP_LOG_D ("  ParentObject: 0x%08x", oi->ParentObject);
+	GP_LOG_D ("  AssociationType: 0x%04x", oi->AssociationType);
+	GP_LOG_D ("  AssociationDesc: 0x%08x", oi->AssociationDesc);
+	GP_LOG_D ("  SequenceNumber: 0x%08x", oi->SequenceNumber);
+	GP_LOG_D ("  ModificationDate: 0x%08x", (unsigned int)oi->ModificationDate);
+	GP_LOG_D ("  CaptureDate: 0x%08x", (unsigned int)oi->CaptureDate);
+}
+
+#if 0
+int
+init_ptp_fs (Camera *camera, GPContext *context)
+{
+	int i, id, nroot = 0;
+	PTPParams *params = &camera->pl->params;
+
+	SET_CONTEXT_P(params, context);
+
+#if 0
+	/* Microsoft/MTP has fast directory retrieval. */
+	if (is_mtp_capable (camera) &&
+	    ptp_operation_issupported(params,PTP_OC_MTP_GetObjPropList) &&
+	    (camera->pl->bugs & PTP_MTP_PROPLIST_WORKS)
+	) {
+		PTPObjectInfo	*oinfos = NULL;	
+		int		cnt = 0, i, j, nrofprops = 0;
+		uint32_t	lasthandle = 0xffffffff;
+		MTPProperties 	*props = NULL, *xpl;
+                int             oldtimeout;
+
+                /* The follow request causes the device to generate
+                 * a list of very file on the device and return it
+                 * in a single response.
+                 *
+                 * Some slow device as well as devices with very
+                 * large file systems can easily take longer then
+                 * the standard timeout value before it is able
+                 * to return a response.
+                 *
+                 * Temporarly set timeout to allow working with
+                 * widest range of devices.
+                 */
+                gp_port_get_timeout (camera->port, &oldtimeout);
+                gp_port_set_timeout (camera->port, 60000);
+
+		ret = ptp_mtp_getobjectproplist (params, 0xffffffff, &props, &nrofprops);
+                gp_port_set_timeout (camera->port, oldtimeout);
+
+		if (ret != PTP_RC_OK)
+			goto fallback;
+		params->props = props; /* cache it */
+		params->nrofprops = nrofprops; /* cache it */
+
+		/* count the objects */
+		for (i=0;i<nrofprops;i++) {
+			xpl = &props[i];
+			if (lasthandle != xpl->ObjectHandle) {
+				cnt++;
+				lasthandle = xpl->ObjectHandle;
+			}
+		}
+		lasthandle = 0xffffffff;
+		oinfos = params->objectinfo = malloc (sizeof (PTPObjectInfo) * cnt);
+		memset (oinfos ,0 ,sizeof (PTPObjectInfo) * cnt);
+		params->handles.Handler = malloc (sizeof (uint32_t) * cnt);
+		params->handles.n = cnt;
+
+		i = -1;
+		for (j=0;j<nrofprops;j++) {
+			xpl = &props[j];
+			if (lasthandle != xpl->ObjectHandle) {
+				if (i >= 0) {
+					if (!oinfos[i].Filename) {
+						/* i have one such file on my Creative */
+						oinfos[i].Filename = strdup("<null>");
+					}
+				}
+				i++;
+				lasthandle = xpl->ObjectHandle;
+				params->handles.Handler[i] = xpl->ObjectHandle;
+				GP_LOG_D ("objectid 0x%x", xpl->ObjectHandle);
+			}
+			switch (xpl->property) {
+			case PTP_OPC_ParentObject:
+				if (xpl->datatype != PTP_DTC_UINT32) {
+					GP_LOG_E ("parentobject has type 0x%x???", xpl->datatype);
+					break;
+				}
+				oinfos[i].ParentObject = xpl->propval.u32;
+				if (xpl->propval.u32 == 0)
+					nroot++;
+				GP_LOG_D ("parent 0x%x", xpl->propval.u32);
+				break;
+			case PTP_OPC_ObjectFormat:
+				if (xpl->datatype != PTP_DTC_UINT16) {
+					GP_LOG_E ("objectformat has type 0x%x???", xpl->datatype);
+					break;
+				}
+				oinfos[i].ObjectFormat = xpl->propval.u16;
+				GP_LOG_D ("ofc 0x%x", xpl->propval.u16);
+				break;
+			case PTP_OPC_ObjectSize:
+				switch (xpl->datatype) {
+				case PTP_DTC_UINT32:
+					oinfos[i].ObjectCompressedSize = xpl->propval.u32;
+					break;
+				case PTP_DTC_UINT64:
+					oinfos[i].ObjectCompressedSize = xpl->propval.u64;
+					break;
+				default:
+					GP_LOG_E ("objectsize has type 0x%x???", xpl->datatype);
+					break;
+				}
+				GP_LOG_D ("objectsize %u", xpl->propval.u32);
+				break;
+			case PTP_OPC_StorageID:
+				if (xpl->datatype != PTP_DTC_UINT32) {
+					GP_LOG_E ("storageid has type 0x%x???", xpl->datatype);
+					break;
+				}
+				oinfos[i].StorageID = xpl->propval.u32;
+				GP_LOG_D ("storageid 0x%x", xpl->propval.u32);
+				break;
+			case PTP_OPC_ProtectionStatus:/*UINT16*/
+				if (xpl->datatype != PTP_DTC_UINT16) {
+					GP_LOG_E ("protectionstatus has type 0x%x???", xpl->datatype);
+					break;
+				}
+				oinfos[i].ProtectionStatus = xpl->propval.u16;
+				GP_LOG_D ("protection 0x%x", xpl->propval.u16);
+				break;
+			case PTP_OPC_ObjectFileName:
+				if (xpl->datatype != PTP_DTC_STR) {
+					GP_LOG_E ("filename has type 0x%x???", xpl->datatype);
+					break;
+				}
+				if (xpl->propval.str) {
+					GP_LOG_D ("filename %s", xpl->propval.str);
+					oinfos[i].Filename = strdup(xpl->propval.str);
+				} else {
+					oinfos[i].Filename = NULL;
+				}
+				break;
+			case PTP_OPC_DateCreated:
+				if (xpl->datatype != PTP_DTC_STR) {
+					GP_LOG_E ("datecreated has type 0x%x???", xpl->datatype);
+					break;
+				}
+				GP_LOG_D ("capturedate %s", xpl->propval.str);
+				oinfos[i].CaptureDate = ptp_unpack_PTPTIME (xpl->propval.str);
+				break;
+			case PTP_OPC_DateModified:
+				if (xpl->datatype != PTP_DTC_STR) {
+					GP_LOG_E ("datemodified has type 0x%x???", xpl->datatype);
+					break;
+				}
+				GP_LOG_D ("moddate %s", xpl->propval.str);
+				oinfos[i].ModificationDate = ptp_unpack_PTPTIME (xpl->propval.str);
+				break;
+			default:
+				if ((xpl->property & 0xfff0) == 0xdc00)
+					GP_LOG_D ("case %x type %x unhandled", xpl->property, xpl->datatype);
+				break;
+			}
+		}
+		return PTP_RC_OK;
+	}
+#endif
+
+	/* Get file handles array for filesystem */
+	id = gp_context_progress_start (context, 100, _("Initializing Camera"));
+	/* Get objecthandles of all objects from all stores */
+	{
+		PTPObjectHandles	handles;
+		int i;
+
+		C_PTP_REP (ptp_getobjecthandles (params, 0xffffffff, 0x000000, 0x000000, &handles));
+		params->objects = calloc(sizeof(PTPObject),handles.n);
+		if (!params->objects)
+			return PTP_RC_GeneralError;
+		gp_context_progress_update (context, id, 10);
+		for (i=0;i<handles.n;i++) {
+			params->objects[i].oid = handles.Handler[i];
+			C_PTP_REP (ptp_getobjectinfo(params,
+				handles.Handler[i],
+				&params->objects[i].oi));
+#if 1
+			debug_objectinfo(params, handles.Handler[i], &params->objects[i].oi);
+#endif
+			if (params->objects[i].oi.ParentObject == 0)
+				nroot++;
+			if (	!params->objects[i].oi.Filename ||
+				!strlen (params->objects[i].oi.Filename)
+			) {
+				params->objects[i].oi.Filename = malloc(8+1);
+				sprintf (params->objects[i].oi.Filename, "%08x", handles.Handler[i]);
+				GP_LOG_E ("Replaced empty dirname by '%08x'", handles.Handler[i]);
+			}
+
+			gp_context_progress_update (context, id,
+			10+(90*i)/handles.n);
+		}
+		gp_context_progress_stop (context, id);
+	}
+
+	/* for older Canons we now retrieve their object flags, to allow
+	 * "new" image handling. This is not yet a substitute for regular
+	 * OI retrieval.
+	 */
+	if ((params->deviceinfo.VendorExtensionID == PTP_VENDOR_CANON) &&
+	    ptp_operation_issupported(params,PTP_OC_CANON_GetObjectInfoEx)) {
+		uint16_t ret;
+		int i;
+
+		/* Look for all directories, since this function apparently only
+		 * returns a directory full of entries and does not recurse
+		 */
+		for (i=0;i<params->nrofobjects;i++) {
+			int j;
+			PTPCANONFolderEntry	*ents = NULL;
+			uint32_t		numents = 0;
+			PTPObject		*ob;
+
+			ptp_object_want (params, params->objects[i].oid, PTPOBJECT_OBJECTINFO_LOADED, &ob);
+			/* only retrieve for directories */
+			if (!ob->oi.AssociationType)
+				continue;
+
+			ret = ptp_canon_getobjectinfo(params,
+				ob->oi.StorageID,0,
+				ob->oid,0,
+				&ents,&numents
+			);
+			if (ret != PTP_RC_OK) continue;
+			for (j=0;j<numents;j++) {
+				PTPObject	*ob2;
+
+				ptp_object_want (params, ents[j].ObjectHandle, 0, &ob2);
+				ob2->canon_flags = ents[j].Flags;
+			}
+		}
+	}
+
+	/* If there are no root directory objects, look for "DCIM" directories.
+	 * This way, we can handle cameras that report the wrong ParentObject ID for
+	 * root.
+	 *
+	 * FIXME: If DCIM is there, it will not look for other root directories.
+         */
+	if (nroot == 0 && params->nrofobjects > 0) {
+		uint32_t	badroothandle = 0xffffffff;
+
+		GP_LOG_D ("Bug workaround: Found no root directory objects, looking for some.");
+		for (i = 0; i < params->nrofobjects; i++) {
+			PTPObjectInfo *oi = &params->objects[i].oi;
+
+			if (strcmp(oi->Filename, "DCIM") == 0) {
+				GP_LOG_D ("Changing DCIM ParentObject ID from 0x%x to 0",
+					 oi->ParentObject);
+				badroothandle = oi->ParentObject;
+				oi->ParentObject = 0;
+				nroot++;
+				break;
+			}
+		}
+		for (i = 0; i < params->nrofobjects; i++) {
+			PTPObjectInfo *oi = &params->objects[i].oi;
+			if (oi->ParentObject == badroothandle) {
+				GP_LOG_D ("Changing %s ParentObject ID from 0x%x to 0",
+					oi->Filename, oi->ParentObject);
+				oi->ParentObject = 0;
+				nroot++;
+			}
+		}
+		/* Some cameras do not have a directory at all, just files or unattached
+		 * directories. In this case associate all unattached to the 0 object.
+		 *
+		 * O(n^2) search. Be careful.
+		 */
+		if (nroot == 0) {
+			GP_LOG_D ("Bug workaround: Found no root dir entries and no DCIM dir, looking for some.");
+			/* look for entries with parentobjects that do not exist */
+			for (i = 0; i < params->nrofobjects; i++) {
+				int j;
+				PTPObjectInfo *oi = &params->objects[i].oi;
+
+				for (j = 0;j < params->nrofobjects; j++)
+					if (oi->ParentObject == params->objects[j].oid)
+						break;
+				if (j == params->nrofobjects)
+					oi->ParentObject = 0;
+			}
+		}
+	}
+	return (GP_OK);
+}
+#endif
+
+/* CANON EOS fast directory mode */
+/* FIXME: incomplete ... needs storage mode retrieval support too (storage == 0xffffffff) */
+static uint16_t
+ptp_list_folder_eos (PTPParams *params, uint32_t storage, uint32_t handle) {
+	unsigned int	k, i, j, last, changed;
+	PTPCANONFolderEntry *tmp = NULL;
+	unsigned int	nroftmp = 0;
+	uint16_t	ret;
+	PTPStorageIDs	storageids;
+	PTPObject	*ob;
+
+	if (handle != 0xffffffff) {
+		ret = ptp_object_want (params, handle, PTPOBJECT_OBJECTINFO_LOADED, &ob);
+		if ((ret == PTP_RC_OK) && (ob->flags & PTPOBJECT_DIRECTORY_LOADED))
+			return PTP_RC_OK;
+	}
+
+	if (storage == 0xffffffff) {
+		if (handle != 0xffffffff)  {
+			GP_LOG_E ("storage 0x%08x, but handle 0x%08x?", storage, handle);
+			handle = 0xffffffff;
+		}
+		ret = ptp_getstorageids(params, &storageids);
+		if (ret != PTP_RC_OK)
+			return ret;
+	} else {
+		storageids.n = 1;
+		storageids.Storage = malloc(sizeof(storageids.Storage[0]));
+		storageids.Storage[0] = storage;
+	}
+	last = changed = 0;
+
+	for (k=0;k<storageids.n;k++) {
+		GP_LOG_D ("reading handle %08x directory of 0x%08x", storageids.Storage[k], handle);
+		ret = LOG_ON_PTP_E (ptp_canon_eos_getobjectinfoex (
+					  params, storageids.Storage[k], handle ? handle : 0xffffffff, 0x100000, &tmp, &nroftmp));
+		if (ret != PTP_RC_OK) {
+			free (storageids.Storage);
+			return ret;
+		}
+		/* convert read entries into objectinfos */
+		for (i=0;i<nroftmp;i++) {
+			PTPObject	*newobs;
+
+			ob = NULL;
+			for (j=0;j<params->nrofobjects;j++) {
+				if (params->objects[(last+j)%params->nrofobjects].oid == tmp[i].ObjectHandle)  {
+					ob = &params->objects[(last+j)%params->nrofobjects];
+					break;
+				}
+			}
+			if (j == params->nrofobjects) {
+				GP_LOG_D ("adding new objectid 0x%08x (nrofobs=%d,j=%d)", tmp[i].ObjectHandle, params->nrofobjects,j);
+				newobs = realloc (params->objects,sizeof(PTPObject)*(params->nrofobjects+1));
+				if (!newobs) return PTP_RC_GeneralError;
+				params->objects = newobs;
+				memset (&params->objects[params->nrofobjects],0,sizeof(params->objects[params->nrofobjects]));
+				params->objects[params->nrofobjects].oid   = tmp[i].ObjectHandle;
+				params->objects[params->nrofobjects].flags = 0;
+
+				params->objects[params->nrofobjects].oi.StorageID = storageids.Storage[k];
+				params->objects[params->nrofobjects].flags |= PTPOBJECT_STORAGEID_LOADED;
+				if (handle == 0xffffffff)
+					params->objects[params->nrofobjects].oi.ParentObject = 0;
+				else
+					params->objects[params->nrofobjects].oi.ParentObject = handle;
+				params->objects[params->nrofobjects].flags |= PTPOBJECT_PARENTOBJECT_LOADED;
+				C_MEM (params->objects[params->nrofobjects].oi.Filename = strdup(tmp[i].Filename));
+				params->objects[params->nrofobjects].oi.ObjectFormat = tmp[i].ObjectFormatCode;
+				params->objects[params->nrofobjects].oi.ProtectionStatus = PTP_DPGS_Get; /* FIXME: check if ok */
+				params->objects[params->nrofobjects].oi.ObjectCompressedSize = tmp[i].ObjectSize;
+				params->objects[params->nrofobjects].oi.CaptureDate = tmp[i].Time;
+				params->objects[params->nrofobjects].oi.ModificationDate = tmp[i].Time;
+				params->objects[params->nrofobjects].flags |= PTPOBJECT_OBJECTINFO_LOADED;
+
+				debug_objectinfo(params, tmp[i].ObjectHandle, &params->objects[params->nrofobjects].oi);
+				last = params->nrofobjects;
+				params->nrofobjects++;
+				changed = 1;
+			} else {
+				GP_LOG_D ("adding old objectid 0x%08x (nrofobs=%d,j=%d)", tmp[i].ObjectHandle, params->nrofobjects,j);
+				ob = &params->objects[(last+j)%params->nrofobjects];
+				/* for speeding up search */
+				last = (last+j)%params->nrofobjects;
+				if (handle != PTP_HANDLER_SPECIAL) {
+					ob->oi.ParentObject = handle;
+					ob->flags |= PTPOBJECT_PARENTOBJECT_LOADED;
+				}
+				if (storageids.Storage[k] != PTP_HANDLER_SPECIAL) {
+					ob->oi.StorageID = storageids.Storage[k];
+					ob->flags |= PTPOBJECT_STORAGEID_LOADED;
+				}
+			}
+		}
+		free (tmp);
+	}
+	if (changed) ptp_objects_sort (params);
+
+	/* Do not cache ob, it might be reallocated and have a new address */
+	if (handle != 0xffffffff) {
+		ret = ptp_object_want (params, handle, PTPOBJECT_OBJECTINFO_LOADED, &ob);
+		if (ret == PTP_RC_OK)
+			ob->flags |= PTPOBJECT_DIRECTORY_LOADED;
+	}
+	free (storageids.Storage);
+	return PTP_RC_OK;
+}
+
+uint16_t
+ptp_list_folder (PTPParams *params, uint32_t storage, uint32_t handle) {
+	unsigned int		i, changed, last;
+	uint16_t		ret;
+	uint32_t		xhandle = handle;
+	PTPObject		*newobs;
+	PTPObjectHandles	handles;
+
+	GP_LOG_D ("(storage=0x%08x, handle=0x%08x)", storage, handle);
+	/* handle=0 is only not read when there is no object in the list yet
+	 * and we do the initial read. */
+	if (!handle && params->nrofobjects)
+		return PTP_RC_OK;
+	/* but we can override this to read 0 object of storages */
+	if (handle == PTP_HANDLER_SPECIAL)
+		handle = 0;
+
+	/* Canon EOS Fast directory strategy */
+	if ((params->deviceinfo.VendorExtensionID == PTP_VENDOR_CANON) &&
+	    ptp_operation_issupported(params, PTP_OC_CANON_EOS_GetObjectInfoEx)) {
+		ret = ptp_list_folder_eos (params, storage, handle);
+		if (ret == PTP_RC_OK)
+			return ret;
+	}
+
+	if (handle) { /* 0 is the virtual root */
+		PTPObject		*ob;
+		/* first check if object itself is loaded, and get its objectinfo. */
+		ret = ptp_object_want (params, handle, PTPOBJECT_OBJECTINFO_LOADED, &ob);
+		if (ret != PTP_RC_OK)
+			return ret;
+		if (ob->oi.ObjectFormat != PTP_OFC_Association)
+			return PTP_RC_GeneralError;
+		if (ob->flags & PTPOBJECT_DIRECTORY_LOADED) return PTP_RC_OK;
+		ob->flags |= PTPOBJECT_DIRECTORY_LOADED;
+		debug_objectinfo(params, handle, &ob->oi);
+	}
+	GP_LOG_D ("Listing ... ");
+	if (handle == 0) xhandle = PTP_HANDLER_SPECIAL; /* 0 would mean all */
+	ret = ptp_getobjecthandles (params, storage, 0, xhandle, &handles);
+	if (ret == PTP_RC_ParameterNotSupported) {/* try without storage */
+		storage = PTP_HANDLER_SPECIAL;
+		ret = ptp_getobjecthandles (params, PTP_HANDLER_SPECIAL, 0, xhandle, &handles);
+	}
+	if (ret == PTP_RC_ParameterNotSupported) { /* fall back to always supported method */
+		xhandle = PTP_HANDLER_SPECIAL;
+		handle = PTP_HANDLER_SPECIAL;
+		ret = ptp_getobjecthandles (params, PTP_HANDLER_SPECIAL, 0, 0, &handles);
+	}
+	if (ret != PTP_RC_OK)
+		return ret;
+	last = changed = 0;
+	for (i=0;i<handles.n;i++) {
+		PTPObject	*ob;
+		unsigned int	j;
+
+		ob = NULL;
+		for (j=0;j<params->nrofobjects;j++) {
+			if (params->objects[(last+j)%params->nrofobjects].oid == handles.Handler[i])  {
+				ob = &params->objects[(last+j)%params->nrofobjects];
+				break;
+			}
+		}
+		if (j == params->nrofobjects) {
+			GP_LOG_D ("adding new objectid 0x%08x (nrofobs=%d,j=%d)", handles.Handler[i], params->nrofobjects,j);
+			newobs = realloc (params->objects,sizeof(PTPObject)*(params->nrofobjects+1));
+			if (!newobs) return PTP_RC_GeneralError;
+			params->objects = newobs;
+			memset (&params->objects[params->nrofobjects],0,sizeof(params->objects[params->nrofobjects]));
+			params->objects[params->nrofobjects].oid = handles.Handler[i];
+			params->objects[params->nrofobjects].flags = 0;
+			/* root directory list files might return all files, so avoid tagging it */
+			if (handle != PTP_HANDLER_SPECIAL && handle) {
+				GP_LOG_D ("  parenthandle 0x%08x", handle);
+				if (handles.Handler[i] == handle) { /* EOS bug where oid == parent(oid) */
+					params->objects[params->nrofobjects].oi.ParentObject = 0;
+				} else {
+					params->objects[params->nrofobjects].oi.ParentObject = handle;
+				}
+				params->objects[params->nrofobjects].flags |= PTPOBJECT_PARENTOBJECT_LOADED;
+			}
+			if (storage != PTP_HANDLER_SPECIAL) {
+				GP_LOG_D ("  storage 0x%08x", storage);
+				params->objects[params->nrofobjects].oi.StorageID = storage;
+				params->objects[params->nrofobjects].flags |= PTPOBJECT_STORAGEID_LOADED;
+			}
+			params->nrofobjects++;
+			changed = 1;
+		} else {
+			GP_LOG_D ("adding old objectid 0x%08x (nrofobs=%d,j=%d)", handles.Handler[i], params->nrofobjects,j);
+			ob = &params->objects[(last+j)%params->nrofobjects];
+			/* for speeding up search */
+			last = (last+j)%params->nrofobjects;
+			if (handle != PTP_HANDLER_SPECIAL) {
+				ob->oi.ParentObject = handle;
+				ob->flags |= PTPOBJECT_PARENTOBJECT_LOADED;
+			}
+			if (storage != PTP_HANDLER_SPECIAL) {
+				ob->oi.StorageID = storage;
+				ob->flags |= PTPOBJECT_STORAGEID_LOADED;
+			}
+		}
+	}
+	free (handles.Handler);
+	if (changed) ptp_objects_sort (params);
+	return PTP_RC_OK;
+}
+
+static CameraFilesystemFuncs fsfuncs = {
+	.file_list_func		= file_list_func,
+	.folder_list_func	= folder_list_func,
+	.get_info_func		= get_info_func,
+	.set_info_func		= set_info_func,
+	.get_file_func		= get_file_func,
+	.read_file_func		= read_file_func,
+	.del_file_func		= delete_file_func,
+	.put_file_func		= put_file_func,
+	.make_dir_func		= make_dir_func,
+	.remove_dir_func	= remove_dir_func,
+	.storage_info_func	= storage_info_func
+};
+
+int
+camera_init (Camera *camera, GPContext *context)
+{
+    	CameraAbilities a;
+	unsigned int i;
+	int ret, tries = 0;
+	PTPParams *params;
+	char *curloc, *camloc;
+	GPPortSettings	settings;
+	uint32_t	sessionid;
+	char		buf[20];
+	int 		start_timeout = USB_START_TIMEOUT;
+	int 		canon_start_timeout = USB_CANON_START_TIMEOUT;
+
+	gp_port_get_settings (camera->port, &settings);
+	/* Make sure our port is either USB or PTP/IP. */
+	if (	(camera->port->type != GP_PORT_USB)	&&
+		(camera->port->type != GP_PORT_PTPIP)	&&
+		(camera->port->type != GP_PORT_USB_SCSI)
+	) {
+		gp_context_error (context, _("Currently, PTP is only implemented for "
+			"USB and PTP/IP cameras currently, port type %x"), camera->port->type);
+		return (GP_ERROR_UNKNOWN_PORT);
+	}
+
+	camera->functions->about = camera_about;
+	camera->functions->exit = camera_exit;
+	camera->functions->trigger_capture = camera_trigger_capture;
+	camera->functions->capture = camera_capture;
+	camera->functions->capture_preview = camera_capture_preview;
+	camera->functions->summary = camera_summary;
+	camera->functions->get_config = camera_get_config;
+	camera->functions->set_config = camera_set_config;
+	camera->functions->wait_for_event = camera_wait_for_event;
+
+	/* We need some data that we pass around */
+	C_MEM (camera->pl = calloc (1, sizeof (CameraPrivateLibrary)));
+	params = &camera->pl->params;
+	params->debug_func = ptp_debug_func;
+	params->error_func = ptp_error_func;
+	C_MEM (params->data = calloc (1, sizeof (PTPData)));
+	((PTPData *) params->data)->camera = camera;
+	params->byteorder = PTP_DL_LE;
+	if (params->byteorder == PTP_DL_LE)
+		camloc = "UCS-2LE";
+	else
+		camloc = "UCS-2BE";
+
+        gp_camera_get_abilities(camera, &a);
+
+#if defined(HAVE_ICONV) && defined(HAVE_LANGINFO_H)
+	curloc = nl_langinfo (CODESET);
+	if (!curloc) curloc="UTF-8";
+	params->cd_ucs2_to_locale = iconv_open(curloc, camloc);
+	params->cd_locale_to_ucs2 = iconv_open(camloc, curloc);
+	if ((params->cd_ucs2_to_locale == (iconv_t) -1) ||
+	    (params->cd_locale_to_ucs2 == (iconv_t) -1)) {
+		GP_LOG_E ("Failed to create iconv converter.");
+		/* we can fallback */
+		/*return (GP_ERROR_OS_FAILURE);*/
+	}
+#endif
+
+        for (i = 0; i<sizeof(models)/sizeof(models[0]); i++) {
+            if ((a.usb_vendor == models[i].usb_vendor) &&
+                (a.usb_product == models[i].usb_product)){
+                params->device_flags = models[i].device_flags;
+                break;
+            }
+	    /* do not run the funny MTP stuff on the cameras for now */
+	    params->device_flags |= DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST_ALL;
+	    params->device_flags |= DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST;
+        }
+	/* map the libmtp flags to ours. Currently its just 1 flag. */
+        for (i = 0; i<sizeof(mtp_models)/sizeof(mtp_models[0]); i++) {
+            if ((a.usb_vendor == mtp_models[i].usb_vendor) &&
+                (a.usb_product == mtp_models[i].usb_product)) {
+			params->device_flags = mtp_models[i].flags;
+                break;
+            }
+        }
+
+
+	switch (camera->port->type) {
+	case GP_PORT_USB:
+		params->sendreq_func	= ptp_usb_sendreq;
+		params->senddata_func	= ptp_usb_senddata;
+		params->getresp_func	= ptp_usb_getresp;
+		params->getdata_func	= ptp_usb_getdata;
+		params->event_wait	= ptp_usb_event_wait;
+		params->event_check	= ptp_usb_event_check;
+		params->cancelreq_func	= ptp_usb_control_cancel_request;
+		params->maxpacketsize 	= settings.usb.maxpacketsize;
+		GP_LOG_D ("maxpacketsize %d", settings.usb.maxpacketsize);
+		if (params->device_flags & DEVICE_FLAG_OLYMPUS_XML_WRAPPED) {
+#ifdef HAVE_LIBXML2
+			GP_LOG_D ("Entering Olympus USB Mass Storage XML Wrapped Mode.\n");
+			olympus_setup (params);
+#else
+			gp_context_error (context, _("Olympus wrapped XML support is currently only available with libxml2 support built in."));				\
+			return GP_ERROR;
+#endif
+		}
+		break;
+	case GP_PORT_PTPIP: {
+		GPPortInfo	info;
+		char 		*xpath;
+
+		ret = gp_port_get_info (camera->port, &info);
+		if (ret != GP_OK) {
+			GP_LOG_E ("Failed to get port info?");
+			return ret;
+		}
+		gp_port_info_get_path (info, &xpath);
+		ret = ptp_ptpip_connect (params, xpath);
+		if (ret != GP_OK) {
+			GP_LOG_E ("Failed to connect.");
+			return ret;
+		}
+		params->sendreq_func	= ptp_ptpip_sendreq;
+		params->senddata_func	= ptp_ptpip_senddata;
+		params->getresp_func	= ptp_ptpip_getresp;
+		params->getdata_func	= ptp_ptpip_getdata;
+		params->event_wait	= ptp_ptpip_event_wait;
+		params->event_check	= ptp_ptpip_event_check;
+		break;
+	}
+	default:
+		break;
+	}
+	if (!params->maxpacketsize)
+		params->maxpacketsize = 64; /* assume USB 1.0 */
+
+	/* Read configurable timeouts */
+#define XT(val,def) 					\
+	if ((GP_OK == gp_setting_get("ptp2",#val,buf)))	\
+		sscanf(buf, "%d", &val);		\
+	if (!val) val = def;
+	XT(normal_timeout,USB_NORMAL_TIMEOUT);
+	XT(capture_timeout,USB_TIMEOUT_CAPTURE);
+
+	/* Choose a shorter timeout on inital setup to avoid
+	 * having the user wait too long.
+	 */
+	if (a.usb_vendor == 0x4a9) { /* CANON */
+		/* our special canon friends get a shorter timeout, sinc ethey
+		 * occasionaly need 2 retries. */
+		XT(canon_start_timeout,USB_CANON_START_TIMEOUT);
+		CR (gp_port_set_timeout (camera->port, canon_start_timeout));
+	} else {
+		XT(start_timeout,USB_START_TIMEOUT);
+		CR (gp_port_set_timeout (camera->port, start_timeout));
+	}
+#undef XT
+	/* Establish a connection to the camera */
+	SET_CONTEXT(camera, context);
+
+	tries = 0;
+	sessionid = 1;
+	while (1) {
+		ret = LOG_ON_PTP_E (ptp_opensession (params, sessionid));
+		if (ret == PTP_RC_SessionAlreadyOpened || ret == PTP_RC_OK)
+			break;
+
+		tries++;
+
+		if (ret==PTP_RC_InvalidTransactionID) {
+			sessionid++;
+			/* Try a couple sessionids starting with 1 */
+			if (tries < 10)
+				continue;
+
+			if (tries < 11 && camera->port->type == GP_PORT_USB) {
+				/* Try whacking PTP device */
+				ptp_usb_control_device_reset_request (&camera->pl->params);
+				sessionid = 1;
+				continue;
+			}
+		} else if ((ret == PTP_ERROR_RESP_EXPECTED) || (ret == PTP_ERROR_IO)) {
+			/* Try whacking PTP device */
+			if (tries < 3 && camera->port->type == GP_PORT_USB)
+				ptp_usb_control_device_reset_request (params);
+		}
+
+		if (tries < 3)
+			continue;
+
+		/* FIXME: deviceinfo is not read yet ... (see macro)*/
+		C_PTP_REP (ret);
+	}
+	/* We have cameras where a response takes 15 seconds(!), so make
+	 * post init timeouts longer */
+	CR (gp_port_set_timeout (camera->port, normal_timeout));
+
+	if (params->device_flags & DEVICE_FLAG_OLYMPUS_XML_WRAPPED) {
+		unsigned char	*data;
+		unsigned int	len;
+		PTPObjectInfo	oi;
+		uint32_t	parenthandle,storagehandle, handle;
+
+		GP_LOG_D ("Sending empty XDISCVRY.X3C file to camera ... ");
+
+		storagehandle = 0x80000001;
+		parenthandle = 0;
+		handle = 0;
+
+		memset (&oi, 0, sizeof (oi));
+		oi.ObjectFormat		= PTP_OFC_Script;
+		oi.StorageID 		= 0x80000001;
+		oi.Filename 		= "XDISCVRY.X3C";
+		oi.ObjectCompressedSize	= 0;
+		C_PTP_REP (ptp_sendobjectinfo (params, &storagehandle, &parenthandle, &handle, &oi));
+
+		GP_LOG_D ("olympus getcameraid\n");
+		ptp_olympus_getcameraid (params, &data, &len);
+
+		GP_LOG_D ("olympus setcameracontrolmode\n");
+		ptp_olympus_setcameracontrolmode (params, 1);
+
+		GP_LOG_D ("olympus opensession\n");
+		ptp_olympus_opensession (params, &data, &len);
+	}
+
+	/* Seems HP does not like getdevinfo outside of session
+	   although it's legal to do so */
+	/* get device info */
+	C_PTP_REP (ptp_getdeviceinfo(params, &params->deviceinfo));
+
+	CR (fixup_cached_deviceinfo (camera,&params->deviceinfo));
+
+	print_debug_deviceinfo(params, &params->deviceinfo);
+
+	switch (params->deviceinfo.VendorExtensionID) {
+	case PTP_VENDOR_CANON:
+#if 0
+		if (ptp_operation_issupported(params, PTP_OC_CANON_ThemeDownload)) {
+			add_special_file("startimage.jpg",	canon_theme_get, canon_theme_put);
+			add_special_file("startsound.wav",	canon_theme_get, canon_theme_put);
+			add_special_file("operation.wav",	canon_theme_get, canon_theme_put);
+			add_special_file("shutterrelease.wav",	canon_theme_get, canon_theme_put);
+			add_special_file("selftimer.wav",	canon_theme_get, canon_theme_put);
+		}
+#endif
+
+		/* If CHDK is present and enabled, this will go and overwrite the function tables again */
+		if (	ptp_operation_issupported(params, PTP_OC_CHDK) &&
+			(GP_OK == gp_setting_get("ptp2","chdk",buf)) &&
+			!strcmp(buf,"on")
+		)
+			return chdk_init (camera, context);
+
+		if (ptp_operation_issupported(params, PTP_OC_CANON_EOS_SetRemoteMode))
+			C_PTP (ptp_canon_eos_setremotemode(params, 1));
+		break;
+	case PTP_VENDOR_NIKON:
+		if (ptp_operation_issupported(params, PTP_OC_NIKON_CurveDownload))
+			add_special_file("curve.ntc", nikon_curve_get, nikon_curve_put);
+		break;
+	default:
+		break;
+	}
+#if 0
+	/* new ptp 1.1 command, implemented in the newer iphone firmware */
+	{
+		unsigned char *data;
+		ptp_getfilesystemmanifest (params, 0x00010001, 0, 0, &data);
+	}
+#endif
+
+	/* avoid doing this on the Sonys DSLRs in control mode, they hang. :( */
+
+	if (params->deviceinfo.VendorExtensionID != PTP_VENDOR_SONY)
+		ptp_list_folder (params, PTP_HANDLER_SPECIAL, PTP_HANDLER_SPECIAL);
+
+	/* read the root directory to avoid the "DCIM WRONG ROOT" bugs */
+	CR (gp_filesystem_set_funcs (camera->fs, &fsfuncs, camera));
+	{
+		PTPStorageIDs storageids;
+
+		/* TODO: ret is ignored here */
+		ret = ptp_getstorageids(params, &storageids);
+		if (ret == PTP_RC_OK) {
+			unsigned int k;
+
+			for (k=0;k<storageids.n;k++) {
+				if (!(storageids.Storage[k] & 0xffff)) continue;
+				if (storageids.Storage[k] == 0x80000001) continue;
+				ptp_list_folder (params, storageids.Storage[k], PTP_HANDLER_SPECIAL);
+			}
+			free (storageids.Storage);
+		}
+	}
+	SET_CONTEXT(camera, NULL);
+	return GP_OK;
+}
diff -urpN wireshark-3.2.1.orig/tools/music-players.h wireshark-3.2.1/tools/music-players.h
--- wireshark-3.2.1.orig/tools/music-players.h	1969-12-31 16:00:00.000000000 -0800
+++ wireshark-3.2.1/tools/music-players.h	2020-02-04 22:58:56.712432077 -0800
@@ -0,0 +1,3002 @@
+/**
+ * \file music-players.h
+ * List of music players as USB ids.
+ *
+ * Copyright (C) 2005-2007 Richard A. Low <richard@wentnet.com>
+ * Copyright (C) 2005-2013 Linus Walleij <triad@df.lth.se>
+ * Copyright (C) 2006-2007,2015 Marcus Meissner <marcus@jet.franken.de>
+ * Copyright (C) 2007 Ted Bullock
+ * Copyright (C) 2012 Sony Mobile Communications AB
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ *
+ * This file is supposed to be included within a struct from both libmtp
+ * and libgphoto2.
+ *
+ * Information can be harvested from Windows driver .INF files, see:
+ * http://msdn.microsoft.com/en-us/library/aa973606.aspx
+ */
+/*
+ * MTP device list, trying real bad to get all devices into
+ * this list by stealing from everyone I know.
+ * Some devices taken from the Rockbox device listing:
+ * http://www.rockbox.org/twiki/bin/view/Main/DeviceDetection
+ */
+
+  /*
+   * Creative Technology and ZiiLABS
+   * Initially the Creative devices was all we supported so these are
+   * the most thoroughly tested devices. Presumably only the devices
+   * with older firmware (the ones that have 32bit object size) will
+   * need the DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST_ALL flag. This bug
+   * manifest itself when you have a lot of folders on the device,
+   * some of the folders will start to disappear when getting all objects
+   * and properties.
+   */
+  { "Creative", 0x041e, "ZEN Vision", 0x411f,
+      DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST_ALL |
+      DEVICE_FLAG_BROKEN_GET_OBJECT_PROPVAL },
+  { "Creative", 0x041e, "Portable Media Center", 0x4123,
+      DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST_ALL |
+      DEVICE_FLAG_BROKEN_GET_OBJECT_PROPVAL },
+  { "Creative", 0x041e, "ZEN Xtra (MTP mode)", 0x4128,
+      DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST_ALL |
+      DEVICE_FLAG_BROKEN_GET_OBJECT_PROPVAL },
+  { "Dell", 0x041e, "DJ (2nd generation)", 0x412f,
+      DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST_ALL |
+      DEVICE_FLAG_BROKEN_GET_OBJECT_PROPVAL },
+  { "Creative", 0x041e, "ZEN Micro (MTP mode)", 0x4130,
+      DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST_ALL |
+      DEVICE_FLAG_BROKEN_GET_OBJECT_PROPVAL },
+  { "Creative", 0x041e, "ZEN Touch (MTP mode)", 0x4131,
+      DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST_ALL |
+      DEVICE_FLAG_BROKEN_GET_OBJECT_PROPVAL },
+  { "Dell", 0x041e, "Dell Pocket DJ (MTP mode)", 0x4132,
+      DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST_ALL |
+      DEVICE_FLAG_BROKEN_GET_OBJECT_PROPVAL },
+ { "Creative", 0x041e, "ZEN MicroPhoto (alternate version)", 0x4133,
+      DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST_ALL |
+      DEVICE_FLAG_BROKEN_GET_OBJECT_PROPVAL },
+  { "Creative", 0x041e, "ZEN Sleek (MTP mode)", 0x4137,
+      DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST_ALL |
+      DEVICE_FLAG_BROKEN_GET_OBJECT_PROPVAL },
+  { "Creative", 0x041e, "ZEN MicroPhoto", 0x413c,
+      DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST_ALL |
+      DEVICE_FLAG_BROKEN_GET_OBJECT_PROPVAL },
+  { "Creative", 0x041e, "ZEN Sleek Photo", 0x413d,
+      DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST_ALL |
+      DEVICE_FLAG_BROKEN_GET_OBJECT_PROPVAL },
+  { "Creative", 0x041e, "ZEN Vision:M", 0x413e,
+      DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST_ALL |
+      DEVICE_FLAG_BROKEN_GET_OBJECT_PROPVAL },
+  // Reported by marazm@o2.pl
+  { "Creative", 0x041e, "ZEN V", 0x4150,
+      DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST_ALL |
+      DEVICE_FLAG_BROKEN_GET_OBJECT_PROPVAL },
+  // Reported by danielw@iinet.net.au
+  // This version of the Vision:M needs the no release interface flag,
+  // unclear whether the other version above need it too or not.
+  { "Creative", 0x041e, "ZEN Vision:M (DVP-HD0004)", 0x4151,
+      DEVICE_FLAG_NO_RELEASE_INTERFACE |
+      DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST_ALL |
+      DEVICE_FLAG_BROKEN_GET_OBJECT_PROPVAL },
+  // Reported by Darel on the XNJB forums
+  { "Creative", 0x041e, "ZEN V Plus", 0x4152,
+      DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST_ALL |
+      DEVICE_FLAG_BROKEN_GET_OBJECT_PROPVAL },
+  { "Creative", 0x041e, "ZEN Vision W", 0x4153,
+      DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST_ALL |
+      DEVICE_FLAG_BROKEN_GET_OBJECT_PROPVAL },
+  // Don't add 0x4155: this is a Zen Stone device which is not MTP
+  // Reported by Paul Kurczaba <paul@kurczaba.com>
+  { "Creative", 0x041e, "ZEN", 0x4157,
+      DEVICE_FLAG_IGNORE_HEADER_ERRORS |
+      DEVICE_FLAG_BROKEN_SET_SAMPLE_DIMENSIONS |
+      DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST_ALL |
+      DEVICE_FLAG_BROKEN_GET_OBJECT_PROPVAL },
+  // Reported by Ringofan <mcroman@users.sourceforge.net>
+  { "Creative", 0x041e, "ZEN V 2GB", 0x4158,
+      DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST_ALL |
+      DEVICE_FLAG_BROKEN_GET_OBJECT_PROPVAL },
+  // Reported by j norment <stormzen@gmail.com>
+  { "Creative", 0x041e, "ZEN Mozaic", 0x4161,
+      DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST_ALL |
+      DEVICE_FLAG_BROKEN_GET_OBJECT_PROPVAL },
+  // Reported by Aaron F. Gonzalez <sub_tex@users.sourceforge.net>
+  { "Creative", 0x041e, "ZEN X-Fi", 0x4162,
+      DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST_ALL |
+      DEVICE_FLAG_BROKEN_GET_OBJECT_PROPVAL },
+  // Reported by farmerstimuli <farmerstimuli@users.sourceforge.net>
+  { "Creative", 0x041e, "ZEN X-Fi 3", 0x4169,
+      DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST_ALL |
+      DEVICE_FLAG_BROKEN_GET_OBJECT_PROPVAL },
+  // Reported by Todor Gyumyushev <yodor1@users.sourceforge.net>
+  { "ZiiLABS", 0x041e, "Zii EGG", 0x6000,
+      DEVICE_FLAG_UNLOAD_DRIVER |
+      DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST |
+      DEVICE_FLAG_NO_RELEASE_INTERFACE |
+      DEVICE_FLAG_ALWAYS_PROBE_DESCRIPTOR |
+      DEVICE_FLAG_CANNOT_HANDLE_DATEMODIFIED },
+
+  /*
+   * Samsung
+   * We suspect that more of these are dual mode.
+   * We suspect more of these might need DEVICE_FLAG_NO_ZERO_READS
+   * We suspect more of these might need DEVICE_FLAG_PLAYLIST_SPL_V1
+   *  or DEVICE_FLAG_PLAYLIST_SPL_V2 to get playlists working.
+   * YP-NEU, YP-NDU, YP-20, YP-800, YP-MF Series, YP-100, YP-30
+   * YP-700 and YP-90 are NOT MTP, but use a Samsung custom protocol.
+   * See: http://wiki.xiph.org/index.php/PortablePlayers for Ogg
+   * status.
+   */
+  // From anonymous SourceForge user, not verified
+  { "Samsung", 0x04e8, "YP-900", 0x0409, DEVICE_FLAG_NONE },
+  // From MItch <dbaker@users.sourceforge.net>
+  { "Samsung", 0x04e8, "I550W Phone", 0x04a4, DEVICE_FLAG_NONE },
+  // From Manfred Enning <menning@users.sourceforge.net>
+  { "Samsung", 0x04e8, "Jet S8000", 0x4f1f, DEVICE_FLAG_NONE },
+  // From Gabriel Nunes <gabrielkm1@yahoo.com.br>
+  { "Samsung", 0x04e8, "YH-920 (501d)", 0x501d, DEVICE_FLAG_UNLOAD_DRIVER },
+  // From Soren O'Neill
+  { "Samsung", 0x04e8, "YH-920 (5022)", 0x5022, DEVICE_FLAG_UNLOAD_DRIVER },
+  // Contributed by aronvanammers on SourceForge
+  { "Samsung", 0x04e8, "YH-925GS", 0x5024, DEVICE_FLAG_NONE },
+  // From libgphoto2, according to tests by Stephan Fabel it cannot
+  // get all objects with the getobjectproplist command..
+  { "Samsung", 0x04e8, "YH-820", 0x502e,
+      DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST_ALL },
+  // Contributed by polux2001@users.sourceforge.net
+  { "Samsung", 0x04e8, "YH-925(-GS)", 0x502f,
+      DEVICE_FLAG_UNLOAD_DRIVER |
+      DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST_ALL },
+  // Contributed by anonymous person on SourceForge
+  { "Samsung", 0x04e8, "YH-J70J", 0x5033,
+      DEVICE_FLAG_UNLOAD_DRIVER },
+  // From XNJB user
+  // Guessing on .spl flag
+  { "Samsung", 0x04e8, "YP-Z5", 0x503c,
+      DEVICE_FLAG_UNLOAD_DRIVER |
+      DEVICE_FLAG_OGG_IS_UNKNOWN |
+      DEVICE_FLAG_PLAYLIST_SPL_V1 },
+  // Don't add 0x5041 as this is YP-Z5 in USB mode
+  // Contributed by anonymous person on SourceForge
+  { "Samsung", 0x04e8, "YP-T7J", 0x5047,
+      DEVICE_FLAG_UNLOAD_DRIVER |
+      DEVICE_FLAG_OGG_IS_UNKNOWN },
+  // Reported by cstrickler@gmail.com
+  { "Samsung", 0x04e8, "YP-U2J (YP-U2JXB/XAA)", 0x5054,
+      DEVICE_FLAG_UNLOAD_DRIVER |
+      DEVICE_FLAG_OGG_IS_UNKNOWN },
+  // Reported by Andrew Benson
+  { "Samsung", 0x04e8, "YP-F2J", 0x5057,
+      DEVICE_FLAG_UNLOAD_DRIVER },
+  // Reported by Patrick <skibler@gmail.com>
+  // Just guessing but looks like .spl v1 http://www.anythingbutipod.com/forum/showthread.php?t=14160
+  { "Samsung", 0x04e8, "YP-K5", 0x505a,
+      DEVICE_FLAG_UNLOAD_DRIVER |
+      DEVICE_FLAG_NO_ZERO_READS |
+      DEVICE_FLAG_PLAYLIST_SPL_V1 },
+  // From dev.local@gmail.com - 0x4e8/0x507c is the UMS mode, apparently
+  // do not add that device.
+  // From m.eik michalke
+  // This device does NOT use the special SPL playlist according to sypqgjxu@gmx.de.
+  { "Samsung", 0x04e8, "YP-U3", 0x507d,
+      DEVICE_FLAG_UNLOAD_DRIVER |
+      DEVICE_FLAG_OGG_IS_UNKNOWN },
+  // Reported by Matthew Wilcox <matthew@wil.cx>
+  // Sergio <sfrdll@tiscali.it> reports this device need the BROKEN ALL flag.
+  // Guessing on .spl flag
+  { "Samsung", 0x04e8, "YP-T9", 0x507f,
+      DEVICE_FLAG_UNLOAD_DRIVER |
+      DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST_ALL |
+      DEVICE_FLAG_OGG_IS_UNKNOWN |
+      DEVICE_FLAG_PLAYLIST_SPL_V1 },
+  // From Paul Clinch
+  // Just guessing but looks like .spl v1 http://www.anythingbutipod.com/forum/showthread.php?t=14160
+  // Some versions of the firmware reportedly support OGG, reportedly only the
+  // UMS versions, so MTP+OGG is not possible on this device.
+  { "Samsung", 0x04e8, "YP-K3", 0x5081,
+      DEVICE_FLAG_UNLOAD_DRIVER |
+      DEVICE_FLAG_PLAYLIST_SPL_V1 },
+  // From XNJB user
+  // From Alistair Boyle, .spl v2 required for playlists
+  // According to the device log it properly supports OGG
+  { "Samsung", 0x04e8, "YP-P2", 0x5083,
+      DEVICE_FLAG_UNLOAD_DRIVER |
+      DEVICE_FLAG_NO_ZERO_READS |
+      DEVICE_FLAG_OGG_IS_UNKNOWN |
+      DEVICE_FLAG_PLAYLIST_SPL_V2 },
+  // From Paul Clinch
+  // Guessing on .spl flag
+  { "Samsung", 0x04e8, "YP-T10", 0x508a,
+      DEVICE_FLAG_UNLOAD_DRIVER |
+      DEVICE_FLAG_OGG_IS_UNKNOWN |
+      DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST |
+      DEVICE_FLAG_PLAYLIST_SPL_V1 |
+      DEVICE_FLAG_NO_ZERO_READS },
+  // From Wim Verwimp <wimverwimp@gmail.com>
+  // Not sure about the Ogg and broken proplist flags here. Just guessing.
+  // Guessing on .spl flag
+  { "Samsung", 0x04e8, "YP-S5", 0x508b,
+      DEVICE_FLAG_UNLOAD_DRIVER |
+      DEVICE_FLAG_OGG_IS_UNKNOWN |
+      DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST |
+      DEVICE_FLAG_PLAYLIST_SPL_V1 },
+  // From Ludovic Danigo
+  // Guessing on .spl flag
+  { "Samsung", 0x04e8, "YP-S3", 0x5091,
+      DEVICE_FLAG_UNLOAD_DRIVER |
+      DEVICE_FLAG_OGG_IS_UNKNOWN |
+      DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST |
+      DEVICE_FLAG_PLAYLIST_SPL_V1 },
+  // From Adrian Levi <adrian.levi@gmail.com>
+  // Guessing on .spl flag
+  // This one supports OGG properly through the correct MTP type.
+  { "Samsung", 0x04e8, "YP-U4", 0x5093, DEVICE_FLAG_UNLOAD_DRIVER },
+  // From Chris Le Sueur <thefishface@gmail.com>
+  // Guessing on .spl flag
+  // This one supports OGG properly through the correct MTP type.
+  { "Samsung", 0x04e8, "YP-R1", 0x510f,
+      DEVICE_FLAG_UNLOAD_DRIVER |
+      DEVICE_FLAG_UNIQUE_FILENAMES |
+      DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST },
+  // From Anonymous SourceForge user
+  // Guessing on .spl flag
+  { "Samsung", 0x04e8, "YP-Q1", 0x5115,
+      DEVICE_FLAG_UNLOAD_DRIVER |
+      DEVICE_FLAG_OGG_IS_UNKNOWN |
+      DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST |
+      DEVICE_FLAG_PLAYLIST_SPL_V1 },
+  // From Holger
+  { "Samsung", 0x04e8, "YP-M1", 0x5118,
+      DEVICE_FLAG_UNLOAD_DRIVER |
+      DEVICE_FLAG_OGG_IS_UNKNOWN |
+      DEVICE_FLAG_PLAYLIST_SPL_V2 },
+  // From Anonymous SourceForge user
+  // Guessing on .spl flag
+  { "Samsung", 0x04e8, "YP-P3", 0x511a,
+      DEVICE_FLAG_UNLOAD_DRIVER |
+     DEVICE_FLAG_OGG_IS_UNKNOWN |
+      DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST |
+     DEVICE_FLAG_PLAYLIST_SPL_V1 },
+  // From Anonymous SourceForge user
+  // Guessing on .spl flag
+  { "Samsung", 0x04e8, "YP-Q2", 0x511d,
+      DEVICE_FLAG_UNLOAD_DRIVER |
+      DEVICE_FLAG_OGG_IS_UNKNOWN |
+      DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST |
+      DEVICE_FLAG_PLAYLIST_SPL_V1 },
+  // From Marco Pizzocaro <mpizzocaro@users.sourceforge.net>
+  // Guessing on .spl flag
+  { "Samsung", 0x04e8, "YP-U5", 0x5121,
+      DEVICE_FLAG_UNLOAD_DRIVER |
+      DEVICE_FLAG_PLAYLIST_SPL_V1 |
+      DEVICE_FLAG_UNIQUE_FILENAMES |
+      DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST },
+  // From Leonardo Accorsi <laccorsi@users.sourceforge.net>
+  // Guessing on .spl flag
+  { "Samsung", 0x04e8, "YP-R0", 0x5125,
+      DEVICE_FLAG_UNLOAD_DRIVER |
+      DEVICE_FLAG_PLAYLIST_SPL_V1 |
+      DEVICE_FLAG_UNIQUE_FILENAMES |
+      DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST },
+  // The "YP-R2" (0x04e8/0x512d) is NOT MTP, it is UMS only.
+  // Guessing on device flags for the MTP mode...
+ { "Samsung", 0x04e8, "YP-R2", 0x512e,
+     DEVICE_FLAG_UNLOAD_DRIVER |
+     DEVICE_FLAG_OGG_IS_UNKNOWN |
+     DEVICE_FLAG_UNIQUE_FILENAMES |
+     DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST |
+     DEVICE_FLAG_PLAYLIST_SPL_V1 },
+  // From Manuel Carro
+  // Copied from Q2
+ { "Samsung", 0x04e8, "YP-Q3", 0x5130,
+     DEVICE_FLAG_UNLOAD_DRIVER |
+     DEVICE_FLAG_OGG_IS_UNKNOWN |
+     DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST |
+     DEVICE_FLAG_PLAYLIST_SPL_V1 },
+ // Reported by: traaf <traaf@users.sourceforge.net>
+ // Guessing on the playlist type!
+ // Appears to present itself properly as a PTP device with MTP extensions!
+ { "Samsung", 0x04e8, "YP-Z3", 0x5137,
+     DEVICE_FLAG_UNLOAD_DRIVER |
+     DEVICE_FLAG_OGG_IS_UNKNOWN |
+     DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST |
+     DEVICE_FLAG_PLAYLIST_SPL_V1 },
+  // YP-F3 is NOT MTP - USB mass storage
+  // From a rouge .INF file
+  // this device ID seems to have been recycled for:
+  // the Samsung SGH-A707 Cingular cellphone
+  // the Samsung L760-V cellphone
+  // the Samsung SGH-U900 cellphone
+  // the Samsung Fascinate player
+  { "Samsung", 0x04e8,
+      "YH-999 Portable Media Center/SGH-A707/SGH-L760V/SGH-U900/Verizon Intensity/Fascinate",
+      0x5a0f, DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST_ALL },
+  // From Santi Béjar <sbejar@gmail.com> - not sure this is MTP...
+  // { "Samsung", 0x04e8, "Z170 Mobile Phone", 0x6601, DEVICE_FLAG_UNLOAD_DRIVER },
+  // From Santi Béjar <sbejar@gmail.com> - not sure this is MTP...
+  // { "Samsung", 0x04e8, "E250 Mobile Phone", 0x663e, DEVICE_FLAG_UNLOAD_DRIVER },
+  // From an anonymous SF user
+  { "Samsung", 0x04e8, "M7600 Beat/GT-S8300T/SGH-F490/S8300", 0x6642,
+      DEVICE_FLAG_UNLOAD_DRIVER |
+      DEVICE_FLAG_BROKEN_BATTERY_LEVEL },
+  // From Lionel Bouton
+  { "Samsung", 0x04e8, "X830 Mobile Phone", 0x6702,
+      DEVICE_FLAG_UNLOAD_DRIVER },
+  // From James <jamestech@gmail.com>
+  { "Samsung", 0x04e8, "U600 Mobile Phone", 0x6709,
+      DEVICE_FLAG_UNLOAD_DRIVER },
+  // From Cesar Cardoso <cesar@cesarcardoso.tk>
+  // No confirmation that this is really MTP.
+  { "Samsung", 0x04e8, "F250 Mobile Phone", 0x6727,
+      DEVICE_FLAG_UNLOAD_DRIVER },
+  // From Charlie Todd  2007-10-31
+  { "Samsung", 0x04e8, "Juke (SCH-U470)", 0x6734,
+      DEVICE_FLAG_UNLOAD_DRIVER},
+  // Reported by Tenn
+  { "Samsung", 0x04e8, "GT-B2700", 0x6752,
+      DEVICE_FLAG_UNLOAD_DRIVER },
+  // Added by Greg Fitzgerald <netzdamon@gmail.com>
+  { "Samsung", 0x04e8, "SAMSUNG Trance", 0x6763,
+      DEVICE_FLAG_UNLOAD_DRIVER |
+     DEVICE_FLAG_NO_ZERO_READS |
+      DEVICE_FLAG_PLAYLIST_SPL_V1 },
+  // From anonymous sourceforge user
+  // Guessing on .spl flag, maybe needs NO_ZERO_READS, whatdoIknow
+  { "Samsung", 0x04e8, "GT-S8500", 0x6819,
+      DEVICE_FLAG_UNLOAD_DRIVER |
+      DEVICE_FLAG_PLAYLIST_SPL_V1 },
+  /*
+   * These entries seems to be used on a *lot* of Samsung
+   * Android phones. It is *not* the Android MTP stack but an internal
+   * Samsung stack. The devices present a few different product IDs
+   * depending on mode:
+   *
+   * 0x685b - UMS
+   * 0x685c - MTP + ADB
+   * 0x685e - UMS + CDC (not MTP)
+   * 0x6860 - MTP mode (default)
+   * 0x6863 - USB CDC RNDIS (not MTP)
+   * 0x6865 - PTP mode (not MTP)
+   * 0x6877 - Kies mode? Does it have MTP?
+   *
+   * Used on these samsung devices:
+   * GT P7310/P7510/N7000/I9100/I9250/I9300
+   * Galaxy Nexus
+   * Galaxy Tab 7.7/10.1
+   * Galaxy S GT-I9000
+   * Galaxy S Advance GT-I9070
+   * Galaxy S2
+   * Galaxy S3
+   * Galaxy Note
+   * Gakaxy Xcover
+   * Galaxy Y
+   *
+   * - It seems that some PTP commands are broken.
+   * - Devices seem to have a connection timeout, the session must be
+   *   open in about 3 seconds since the device is plugged in, after
+   *   that time it will not respond. Thus GUI programs work fine.
+   * - Seems also to be used with Galaxy Nexus debug mode and on
+   *   US markets for some weird reason.
+   *
+   * From: Ignacio Martínez <ignacio.martinezrivera@yahoo.es> and others
+   * From Harrison Metzger <harrisonmetz@gmail.com>
+   */
+  { "Samsung", 0x04e8,
+      "Galaxy models (MTP+ADB)", 0x685c,
+      DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST_ALL |
+      DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST |
+      DEVICE_FLAG_UNLOAD_DRIVER |
+      DEVICE_FLAG_LONG_TIMEOUT |
+      DEVICE_FLAG_PROPLIST_OVERRIDES_OI	|
+      DEVICE_FLAG_OGG_IS_UNKNOWN |
+      DEVICE_FLAG_FLAC_IS_UNKNOWN },
+  { "Samsung", 0x04e8,
+      "Galaxy models (MTP)", 0x6860,
+      DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST_ALL |
+      DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST |
+      DEVICE_FLAG_UNLOAD_DRIVER |
+      DEVICE_FLAG_LONG_TIMEOUT |
+      DEVICE_FLAG_PROPLIST_OVERRIDES_OI |
+      DEVICE_FLAG_OGG_IS_UNKNOWN |
+      DEVICE_FLAG_FLAC_IS_UNKNOWN },
+  // From: Erik Berglund <erikjber@users.sourceforge.net>
+  // Logs indicate this needs DEVICE_FLAG_NO_ZERO_READS
+  // No Samsung platlists on this device.
+  // https://sourceforge.net/tracker/?func=detail&atid=809061&aid=3026337&group_id=158745
+  // i5800 duplicate reported by igel <igel-kun@users.sourceforge.net>
+  // Guessing this has the same problematic MTP stack as the device
+  // above.
+  { "Samsung", 0x04e8, "Galaxy models Kies mode", 0x6877,
+      DEVICE_FLAG_UNLOAD_DRIVER |
+      DEVICE_FLAG_LONG_TIMEOUT |
+      DEVICE_FLAG_PROPLIST_OVERRIDES_OI	|
+      DEVICE_FLAG_OGG_IS_UNKNOWN |
+      DEVICE_FLAG_FLAC_IS_UNKNOWN },
+  // From: John Gorkos <ab0oo@users.sourceforge.net> and
+  // Akos Maroy <darkeye@users.sourceforge.net>
+  { "Samsung", 0x04e8, "Vibrant SGH-T959/Captivate/Media player mode", 0x68a9,
+      DEVICE_FLAG_UNLOAD_DRIVER |
+      DEVICE_FLAG_PLAYLIST_SPL_V1 },
+  // Reported by Sleep.Walker <froser@users.sourceforge.net>
+  { "Samsung", 0x04e8, "GT-B2710/Xcover 271", 0x68af,
+      DEVICE_FLAG_UNLOAD_DRIVER |
+      DEVICE_FLAG_PLAYLIST_SPL_V1 },
+  // From anonymous Sourceforge user
+  { "Samsung", 0x04e8, "GT-S5230", 0xe20c, DEVICE_FLAG_NONE },
+
+
+  /*
+   * Microsoft
+   * All except the first probably need MTPZ to work
+   */
+  { "Microsoft/Intel", 0x045e, "Bandon Portable Media Center", 0x00c9,
+      DEVICE_FLAG_NONE },
+  // HTC Mozart is using the PID, as is Nokia Lumia 800
+  // May need MTPZ to work
+  { "Microsoft", 0x045e, "Windows Phone", 0x04ec, DEVICE_FLAG_NONE },
+  // Reported by Tadimarri Sarath <sarath.tadi@gmail.com>
+  // No idea why this use an Intel PID, perhaps a leftover from
+  // the early PMC development days when Intel and Microsoft were
+  // partnering.
+  { "Microsoft", 0x045e, "Windows MTP Simulator", 0x0622, DEVICE_FLAG_NONE },
+  // Reported by Edward Hutchins (used for Zune HDs)
+  { "Microsoft", 0x045e, "Zune HD", 0x063e, DEVICE_FLAG_NONE },
+  { "Microsoft", 0x045e, "Kin 1", 0x0640, DEVICE_FLAG_NONE },
+  { "Microsoft/Sharp/nVidia", 0x045e, "Kin TwoM", 0x0641, DEVICE_FLAG_NONE },
+  // Reported by Farooq Zaman (used for all Zunes)
+  { "Microsoft", 0x045e, "Zune", 0x0710, DEVICE_FLAG_NONE },
+  // Reported by Olegs Jeremejevs
+  { "Microsoft/HTC", 0x045e, "HTC 8S", 0xf0ca, DEVICE_FLAG_NONE },
+
+  /*
+   * JVC
+   */
+  // From Mark Veinot
+  { "JVC", 0x04f1, "Alneo XA-HD500", 0x6105, DEVICE_FLAG_NONE },
+
+  /*
+   * Philips
+   */
+  { "Philips", 0x0471, "HDD6320/00 or HDD6330/17", 0x014b, DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST_ALL },
+  // Anonymous SourceForge user
+  { "Philips", 0x0471, "HDD14XX,HDD1620 or HDD1630/17", 0x014c, DEVICE_FLAG_NONE },
+  // from discussion forum
+  { "Philips", 0x0471, "HDD085/00 or HDD082/17", 0x014d, DEVICE_FLAG_NONE },
+  // from XNJB forum
+  { "Philips", 0x0471, "GoGear SA9200", 0x014f, DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST_ALL },
+  // From John Coppens <jcoppens@users.sourceforge.net>
+  { "Philips", 0x0471, "SA1115/55", 0x0164, DEVICE_FLAG_NONE },
+  // From Gerhard Mekenkamp
+  { "Philips", 0x0471, "GoGear Audio", 0x0165, DEVICE_FLAG_NONE },
+  // from David Holm <wormie@alberg.dk>
+  { "Philips", 0x0471, "Shoqbox", 0x0172, DEVICE_FLAG_ONLY_7BIT_FILENAMES },
+  // from npedrosa
+  { "Philips", 0x0471, "PSA610", 0x0181, DEVICE_FLAG_NONE },
+  // From libgphoto2 source
+  { "Philips", 0x0471, "HDD6320", 0x01eb, DEVICE_FLAG_NONE },
+  // From Detlef Meier <dm@emlix.com>
+  { "Philips", 0x0471, "GoGear SA6014/SA6015/SA6024/SA6025/SA6044/SA6045", 0x084e, DEVICE_FLAG_UNLOAD_DRIVER },
+  // From anonymous Sourceforge user SA5145/02
+  { "Philips", 0x0471, "GoGear SA5145", 0x0857, DEVICE_FLAG_UNLOAD_DRIVER },
+  /* https://sourceforge.net/p/libmtp/bugs/1260/ */
+  { "Philips", 0x0471, "i908", 0x190b, DEVICE_FLAG_UNLOAD_DRIVER },
+  // From a
+  { "Philips", 0x0471, "GoGear SA6125/SA6145/SA6185", 0x2002, DEVICE_FLAG_UNLOAD_DRIVER },
+  // From anonymous Sourceforge user, not verified to be MTP!
+  { "Philips", 0x0471, "GoGear SA3345", 0x2004, DEVICE_FLAG_UNLOAD_DRIVER },
+  // From Roberto Vidmar <rvidmar@libero.it>
+  { "Philips", 0x0471, "SA5285", 0x2022, DEVICE_FLAG_UNLOAD_DRIVER },
+  // From Elie De Brauwer <elie@de-brauwer.be>
+  { "Philips", 0x0471, "GoGear ViBE SA1VBE04", 0x2075,
+    DEVICE_FLAG_UNLOAD_DRIVER },
+  // From Anonymous SourceForge user
+  { "Philips", 0x0471, "GoGear Muse", 0x2077,
+      DEVICE_FLAG_UNLOAD_DRIVER },
+  // From Elie De Brauwer <elie@de-brauwer.be>
+  { "Philips", 0x0471, "GoGear ViBE SA1VBE04/08", 0x207b,
+    DEVICE_FLAG_UNLOAD_DRIVER },
+  // From josmtx <josmtx@users.sourceforge.net>
+  { "Philips", 0x0471, "GoGear Aria", 0x207c,
+    DEVICE_FLAG_UNLOAD_DRIVER },
+  // From epklein
+  { "Philips", 0x0471, "GoGear SA1VBE08KX/78", 0x208e,
+    DEVICE_FLAG_UNLOAD_DRIVER },
+  // From Anonymous SourceForge User
+  { "Philips", 0x0471, "GoGear VIBE SA2VBE[08|16]K/02", 0x20b7,
+      DEVICE_FLAG_UNLOAD_DRIVER },
+  // From Anonymous SourceForge User
+  { "Philips", 0x0471, "GoGear Ariaz", 0x20b9,
+      DEVICE_FLAG_UNLOAD_DRIVER },
+  // From Anonymous SourceForge User
+  { "Philips", 0x0471, "GoGear Vibe/02", 0x20e5,
+      DEVICE_FLAG_UNLOAD_DRIVER },
+  // Reported by Philip Rhoades
+  { "Philips", 0x0471, "GoGear Ariaz/97", 0x2138,
+      DEVICE_FLAG_UNLOAD_DRIVER },
+  /* https://sourceforge.net/p/libmtp/bugs/1186/ */
+  { "Philips", 0x0471, "PI3900B2/58 ", 0x2190,
+      DEVICE_FLAG_UNLOAD_DRIVER },
+  // from XNJB user
+  { "Philips", 0x0471, "PSA235", 0x7e01, DEVICE_FLAG_NONE },
+
+  /*
+   * Acer
+   * Reporters:
+   * Franck VDL <franckv@users.sourceforge.net>
+   * Matthias Arndt <simonsunnyboy@users.sourceforge.net>
+   * Arvin Schnell <arvins@users.sourceforge.net>
+   * Philippe Marzouk <philm@users.sourceforge.net>
+   * nE0sIghT <ne0sight@users.sourceforge.net>
+   * Maxime de Roucy <maxime1986@users.sourceforge.net>
+   */
+  { "Acer", 0x0502, "Iconia TAB A500 (ID1)", 0x3325,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "Acer", 0x0502, "Iconia TAB A500 (ID2)", 0x3341,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "Acer", 0x0502, "Iconia TAB A501 (ID1)", 0x3344,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "Acer", 0x0502, "Iconia TAB A501 (ID2)", 0x3345,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "Acer", 0x0502, "Iconia TAB A100 (ID1)", 0x3348,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "Acer", 0x0502, "Iconia TAB A100 (ID2)", 0x3349,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "Acer", 0x0502, "Iconia TAB A101 (ID1)", 0x334a,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "Acer", 0x0502, "Iconia TAB A700", 0x3378,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "Acer", 0x0502, "Iconia TAB A200 (ID1)", 0x337c,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "Acer", 0x0502, "Iconia TAB A200 (ID2)", 0x337d,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "Acer", 0x0502, "Iconia TAB A510 (ID1)", 0x3389,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "Acer", 0x0502, "Iconia TAB A510 (ID2)", 0x338a,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "Acer", 0x0502, "S500 CloudMobile", 0x33aa,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "Acer", 0x0502, "E350 Liquid Gallant Duo (ID1)", 0x33c3,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "Acer", 0x0502, "E350 Liquid Gallant Duo (ID2)", 0x33c4,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "Acer", 0x0502, "Iconia TAB A210", 0x33cb,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "Acer", 0x0502, "Iconia TAB A110", 0x33d8,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "Acer", 0x0502, "Liquid Z120 MT65xx Android Phone", 0x3473,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  /* https://sourceforge.net/p/libmtp/bugs/1029/ */
+  { "Acer", 0x0502, "Liquid E2", 0x3514,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "Acer", 0x0502, "Iconia A1-810", 0x353c,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "Acer", 0x0502, "Liquid Z130 MT65xx Android Phone", 0x355f,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  /* https://sourceforge.net/p/libmtp/bugs/1206/ */
+  { "Acer", 0x0502, "Iconia A3-A11", 0x3586,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  /* https://sourceforge.net/p/libmtp/bugs/1103/ */
+  { "Acer", 0x0502, "Liquid E3", 0x35a8,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  /* https://sourceforge.net/p/libmtp/bugs/1147/ */
+  { "Acer", 0x0502, "Z150", 0x35e4,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  /* https://sourceforge.net/p/libmtp/bugs/1184/ */
+  { "Acer", 0x0502, "Liquid X1", 0x3609,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  /* https://sourceforge.net/p/libmtp/bugs/1298/ */
+  { "Acer", 0x0502, "Z160", 0x361d,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "Acer", 0x0502, "Iconia A1-840FHD", 0x362d,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  /* https://sourceforge.net/p/libmtp/bugs/1251/ */
+  { "Acer", 0x0502, "E39", 0x3643,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  /* https://sourceforge.net/p/libmtp/bugs/1369/ */
+  { "Acer", 0x0502, "liquid e700", 0x3644,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "Acer", 0x0502, "One 7", 0x3657,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  /* https://sourceforge.net/p/libmtp/bugs/1341/ */
+  { "Acer", 0x0502, "Liquid S56", 0x3725,
+      DEVICE_FLAGS_ANDROID_BUGS },
+
+  /*
+   * SanDisk
+   * several devices (c150 for sure) are definately dual-mode and must
+   * have the USB mass storage driver that hooks them unloaded first.
+   * They all have problematic dual-mode making the device unload effect
+   * uncertain on these devices.
+   *
+   * All older devices seem to need DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST_ALL.
+   * Old chipsets: e200/c200 use PP5024 from Nvidia (formerly PortalPlayer).
+   * m200 use TCC770 from Telechips.
+   *
+   * The newer Sansa v2 chipset, AD3525 from Austriamicrosystems (AMS) found
+   * in e280 v2 c200 v2, Clip, Fuze etc require
+   * DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST
+   * and DEVICE_FLAG_ALWAYS_PROBE_DESCRIPTOR to work properly.
+   *
+   * For more info see: http://daniel.haxx.se/sansa/v2.html
+   */
+  // Reported by Brian Robison
+  { "SanDisk", 0x0781, "Sansa m230/m240", 0x7400,
+    DEVICE_FLAG_UNLOAD_DRIVER | DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST_ALL |
+    DEVICE_FLAG_NO_RELEASE_INTERFACE | DEVICE_FLAG_CANNOT_HANDLE_DATEMODIFIED },
+  // From Rockbox device listing
+  { "SanDisk", 0x0781, "Sansa m200-tcc (MTP mode)", 0x7401,
+    DEVICE_FLAG_UNLOAD_DRIVER | DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST_ALL |
+    DEVICE_FLAG_NO_RELEASE_INTERFACE | DEVICE_FLAG_CANNOT_HANDLE_DATEMODIFIED },
+  // Reported by tangent_@users.sourceforge.net
+  { "SanDisk", 0x0781, "Sansa c150", 0x7410,
+    DEVICE_FLAG_UNLOAD_DRIVER | DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST_ALL |
+    DEVICE_FLAG_NO_RELEASE_INTERFACE | DEVICE_FLAG_CANNOT_HANDLE_DATEMODIFIED },
+  // From libgphoto2 source
+  // Reported by <gonkflea@users.sourceforge.net>
+  // Reported by Mike Owen <mikeowen@computerbaseusa.com>
+  { "SanDisk", 0x0781, "Sansa e200/e250/e260/e270/e280", 0x7420,
+    DEVICE_FLAG_UNLOAD_DRIVER |  DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST_ALL |
+    DEVICE_FLAG_NO_RELEASE_INTERFACE | DEVICE_FLAG_CANNOT_HANDLE_DATEMODIFIED },
+  // Don't add 0x7421 as this is e280 in MSC mode
+  // Reported by XNJB user
+  { "SanDisk", 0x0781, "Sansa e260/e280 v2", 0x7422,
+    DEVICE_FLAG_UNLOAD_DRIVER | DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST |
+    DEVICE_FLAG_NO_RELEASE_INTERFACE | DEVICE_FLAG_ALWAYS_PROBE_DESCRIPTOR |
+    DEVICE_FLAG_CANNOT_HANDLE_DATEMODIFIED },
+  // Reported by XNJB user
+  { "SanDisk", 0x0781, "Sansa m240/m250", 0x7430,
+    DEVICE_FLAG_UNLOAD_DRIVER |  DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST_ALL |
+    DEVICE_FLAG_NO_RELEASE_INTERFACE | DEVICE_FLAG_CANNOT_HANDLE_DATEMODIFIED },
+  // Reported by Eugene Brevdo <ebrevdo@princeton.edu>
+  { "SanDisk", 0x0781, "Sansa Clip", 0x7432,
+    DEVICE_FLAG_UNLOAD_DRIVER |  DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST |
+    DEVICE_FLAG_NO_RELEASE_INTERFACE | DEVICE_FLAG_ALWAYS_PROBE_DESCRIPTOR |
+    DEVICE_FLAG_CANNOT_HANDLE_DATEMODIFIED},
+  // Reported by HackAR <hackar@users.sourceforge.net>
+  { "SanDisk", 0x0781, "Sansa Clip v2", 0x7434,
+    DEVICE_FLAG_UNLOAD_DRIVER |  DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST |
+    DEVICE_FLAG_NO_RELEASE_INTERFACE | DEVICE_FLAG_ALWAYS_PROBE_DESCRIPTOR |
+    DEVICE_FLAG_CANNOT_HANDLE_DATEMODIFIED},
+  // Reported by anonymous user at sourceforge.net
+  { "SanDisk", 0x0781, "Sansa c240/c250", 0x7450,
+    DEVICE_FLAG_UNLOAD_DRIVER |  DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST_ALL |
+    DEVICE_FLAG_NO_RELEASE_INTERFACE | DEVICE_FLAG_CANNOT_HANDLE_DATEMODIFIED },
+  // Reported by anonymous SourceForge user
+  { "SanDisk", 0x0781, "Sansa c250 v2", 0x7452,
+    DEVICE_FLAG_UNLOAD_DRIVER |  DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST_ALL |
+    DEVICE_FLAG_NO_RELEASE_INTERFACE | DEVICE_FLAG_CANNOT_HANDLE_DATEMODIFIED },
+  // Reported by Troy Curtis Jr.
+  { "SanDisk", 0x0781, "Sansa Express", 0x7460,
+    DEVICE_FLAG_UNLOAD_DRIVER | DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST |
+    DEVICE_FLAG_NO_RELEASE_INTERFACE | DEVICE_FLAG_CANNOT_HANDLE_DATEMODIFIED },
+  // Reported by XNJB user, and Miguel de Icaza <miguel@gnome.org>
+  // This has no dual-mode so no need to unload any driver.
+  // This is a Linux based device!
+  { "SanDisk", 0x0781, "Sansa Connect", 0x7480, DEVICE_FLAG_NONE },
+  // Reported by anonymous SourceForge user
+  { "SanDisk", 0x0781, "Sansa View", 0x74b0,
+    DEVICE_FLAG_UNLOAD_DRIVER |  DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST_ALL |
+    DEVICE_FLAG_NO_RELEASE_INTERFACE | DEVICE_FLAG_CANNOT_HANDLE_DATEMODIFIED },
+  // Reported by Patrick <skibler@gmail.com>
+  // There are apparently problems with this device.
+  { "SanDisk", 0x0781, "Sansa Fuze", 0x74c0,
+    DEVICE_FLAG_UNLOAD_DRIVER |  DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST |
+    DEVICE_FLAG_NO_RELEASE_INTERFACE | DEVICE_FLAG_ALWAYS_PROBE_DESCRIPTOR |
+    DEVICE_FLAG_BROKEN_SET_SAMPLE_DIMENSIONS |
+    DEVICE_FLAG_CANNOT_HANDLE_DATEMODIFIED },
+  // Harry Phillips <tuxcomputers@users.sourceforge.net>
+  { "SanDisk", 0x0781, "Sansa Fuze v2", 0x74c2,
+    DEVICE_FLAG_UNLOAD_DRIVER |  DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST |
+    DEVICE_FLAG_NO_RELEASE_INTERFACE | DEVICE_FLAG_ALWAYS_PROBE_DESCRIPTOR |
+    DEVICE_FLAG_BROKEN_SET_SAMPLE_DIMENSIONS |
+    DEVICE_FLAG_CANNOT_HANDLE_DATEMODIFIED },
+  // Reported by anonymous SourceForge user
+  // Need BROKEN_SET_SAMPLE_DIMENSIONS accordning to
+  // Michael <mpapet@users.sourceforge.net>
+  { "SanDisk", 0x0781, "Sansa Clip+", 0x74d0,
+    DEVICE_FLAG_UNLOAD_DRIVER |  DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST |
+    DEVICE_FLAG_NO_RELEASE_INTERFACE | DEVICE_FLAG_ALWAYS_PROBE_DESCRIPTOR |
+    DEVICE_FLAG_BROKEN_SET_SAMPLE_DIMENSIONS |
+    DEVICE_FLAG_CANNOT_HANDLE_DATEMODIFIED},
+  // Reported by anonymous SourceForge user
+  { "SanDisk", 0x0781, "Sansa Fuze+", 0x74e0,
+    DEVICE_FLAG_UNLOAD_DRIVER |  DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST |
+    DEVICE_FLAG_NO_RELEASE_INTERFACE | DEVICE_FLAG_ALWAYS_PROBE_DESCRIPTOR |
+    DEVICE_FLAG_BROKEN_SET_SAMPLE_DIMENSIONS |
+    DEVICE_FLAG_CANNOT_HANDLE_DATEMODIFIED},
+  // Reported by mattyj2001@users.sourceforge.net
+  { "SanDisk", 0x0781, "Sansa Clip Zip", 0x74e4,
+    DEVICE_FLAG_UNLOAD_DRIVER |  DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST |
+    DEVICE_FLAG_NO_RELEASE_INTERFACE | DEVICE_FLAG_ALWAYS_PROBE_DESCRIPTOR |
+    DEVICE_FLAG_BROKEN_SET_SAMPLE_DIMENSIONS |
+    DEVICE_FLAG_CANNOT_HANDLE_DATEMODIFIED},
+
+  /*
+   * iRiver
+   * we assume that PTP_OC_MTP_GetObjPropList is essentially
+   * broken on all iRiver devices, meaning it simply won't return
+   * all properties for a file when asking for metadata 0xffffffff.
+   * Please test on your device if you believe it isn't broken!
+   */
+  { "iRiver", 0x1006, "H300 Series MTP", 0x3004,
+    DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST | DEVICE_FLAG_NO_ZERO_READS |
+    DEVICE_FLAG_IRIVER_OGG_ALZHEIMER },
+  { "iRiver", 0x1006, "Portable Media Center 1", 0x4002,
+    DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST | DEVICE_FLAG_NO_ZERO_READS |
+    DEVICE_FLAG_IRIVER_OGG_ALZHEIMER },
+  { "iRiver", 0x1006, "Portable Media Center 2", 0x4003,
+    DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST | DEVICE_FLAG_NO_ZERO_READS |
+    DEVICE_FLAG_IRIVER_OGG_ALZHEIMER },
+  // From [st]anislav <iamstanislav@gmail.com>
+  { "iRiver", 0x1042, "T7 Volcano", 0x1143, DEVICE_FLAG_IRIVER_OGG_ALZHEIMER },
+  // From an anonymous person at SourceForge, uncertain about this one
+  { "iRiver", 0x4102, "iFP-880", 0x1008,
+    DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST | DEVICE_FLAG_NO_ZERO_READS |
+    DEVICE_FLAG_IRIVER_OGG_ALZHEIMER },
+  // 0x4102, 0x1042 is a USB mass storage mode for E100 v2/Lplayer
+  // From libgphoto2 source
+  { "iRiver", 0x4102, "T10", 0x1113,
+    DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST | DEVICE_FLAG_NO_ZERO_READS |
+    DEVICE_FLAG_IRIVER_OGG_ALZHEIMER },
+  { "iRiver", 0x4102, "T20 FM", 0x1114,
+    DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST | DEVICE_FLAG_NO_ZERO_READS |
+    DEVICE_FLAG_IRIVER_OGG_ALZHEIMER },
+  // This appears at the MTP-UMS site
+  { "iRiver", 0x4102, "T20", 0x1115,
+    DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST | DEVICE_FLAG_NO_ZERO_READS |
+    DEVICE_FLAG_IRIVER_OGG_ALZHEIMER },
+  { "iRiver", 0x4102, "U10", 0x1116,
+    DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST | DEVICE_FLAG_NO_ZERO_READS |
+    DEVICE_FLAG_IRIVER_OGG_ALZHEIMER },
+  { "iRiver", 0x4102, "T10b", 0x1117,
+    DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST | DEVICE_FLAG_NO_ZERO_READS |
+    DEVICE_FLAG_IRIVER_OGG_ALZHEIMER },
+  { "iRiver", 0x4102, "T20b", 0x1118,
+    DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST | DEVICE_FLAG_NO_ZERO_READS |
+    DEVICE_FLAG_IRIVER_OGG_ALZHEIMER },
+  { "iRiver", 0x4102, "T30", 0x1119,
+    DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST | DEVICE_FLAG_NO_ZERO_READS |
+    DEVICE_FLAG_IRIVER_OGG_ALZHEIMER },
+  // Reported by David Wolpoff
+  { "iRiver", 0x4102, "T10 2GB", 0x1120,
+    DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST | DEVICE_FLAG_NO_ZERO_READS |
+    DEVICE_FLAG_IRIVER_OGG_ALZHEIMER },
+  // Rough guess this is the MTP device ID...
+  { "iRiver", 0x4102, "N12", 0x1122,
+    DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST | DEVICE_FLAG_NO_ZERO_READS |
+    DEVICE_FLAG_IRIVER_OGG_ALZHEIMER },
+  // Reported by Philip Antoniades <philip@mysql.com>
+  // Newer iriver devices seem to have shaped-up firmware without any
+  // of the annoying bugs.
+  { "iRiver", 0x4102, "Clix2", 0x1126, DEVICE_FLAG_NONE },
+  // Reported by Adam Torgerson
+  { "iRiver", 0x4102, "Clix", 0x112a,
+    DEVICE_FLAG_NO_ZERO_READS | DEVICE_FLAG_IRIVER_OGG_ALZHEIMER },
+  // Reported by Douglas Roth <dougaus@gmail.com>
+  { "iRiver", 0x4102, "X20", 0x1132,
+    DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST | DEVICE_FLAG_NO_ZERO_READS |
+    DEVICE_FLAG_IRIVER_OGG_ALZHEIMER },
+  // Reported by Robert Ugo <robert_ugo@users.sourceforge.net>
+  { "iRiver", 0x4102, "T60", 0x1134,
+    DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST | DEVICE_FLAG_NO_ZERO_READS |
+    DEVICE_FLAG_IRIVER_OGG_ALZHEIMER },
+  // Reported by two anonymous SourceForge users
+  // Needs the stronger OGG_IS_UNKNOWN flag to support OGG properly,
+  // be aware of newer players that may be needing this too.
+  { "iRiver", 0x4102, "E100", 0x1141,
+    DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST | DEVICE_FLAG_NO_ZERO_READS |
+    DEVICE_FLAG_OGG_IS_UNKNOWN },
+  // Reported by anonymous SourceForge user
+  // Need verification of whether this firmware really need all these flags
+  { "iRiver", 0x4102, "E100 v2/Lplayer", 0x1142,
+    DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST | DEVICE_FLAG_NO_ZERO_READS |
+    DEVICE_FLAG_OGG_IS_UNKNOWN },
+  // Reported by Richard Vennemann <vennemann@users.sourceforge.net>
+  // In USB Mass Storage mode it is 0x4102/0x1047
+  // Seems to use the new shaped-up firmware.
+  { "iRiver", 0x4102, "Spinn", 0x1147, DEVICE_FLAG_NONE },
+  // Reported by Tony Janssen <tonyjanssen@users.sourceforge.net>
+  { "iRiver", 0x4102, "E50", 0x1151,
+    DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST | DEVICE_FLAG_NO_ZERO_READS |
+    DEVICE_FLAG_OGG_IS_UNKNOWN },
+  // Reported by anonymous SourceForge user, guessing on flags
+  { "iRiver", 0x4102, "E150", 0x1152,
+    DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST | DEVICE_FLAG_NO_ZERO_READS |
+    DEVICE_FLAG_OGG_IS_UNKNOWN },
+  // Reported by Jakub Matraszek <jakub.matraszek@gmail.com>
+  { "iRiver", 0x4102, "T5", 0x1153,
+    DEVICE_FLAG_UNLOAD_DRIVER | DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST |
+    DEVICE_FLAG_NO_ZERO_READS | DEVICE_FLAG_OGG_IS_UNKNOWN },
+  // Reported by pyalex@users.sourceforge.net
+  // Guessing that this needs the FLAG_NO_ZERO_READS...
+  { "iRiver", 0x4102, "E30", 0x1167,
+    DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST | DEVICE_FLAG_NO_ZERO_READS |
+    DEVICE_FLAG_OGG_IS_UNKNOWN },
+  // Reported by Scott Call
+  // Assume this actually supports OGG though it reports it doesn't.
+  { "iRiver", 0x4102, "H10 20GB", 0x2101,
+    DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST | DEVICE_FLAG_NO_ZERO_READS |
+    DEVICE_FLAG_OGG_IS_UNKNOWN },
+  { "iRiver", 0x4102, "H10 5GB", 0x2102,
+    DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST | DEVICE_FLAG_NO_ZERO_READS |
+    DEVICE_FLAG_OGG_IS_UNKNOWN },
+  // From Rockbox device listing
+  { "iRiver", 0x4102, "H10 5.6GB", 0x2105,
+    DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST | DEVICE_FLAG_NO_ZERO_READS |
+    DEVICE_FLAG_OGG_IS_UNKNOWN },
+
+
+  /*
+   * Dell
+   */
+  { "Dell Inc", 0x413c, "DJ Itty", 0x4500,
+      DEVICE_FLAG_NONE },
+  /* Reported by: JR */
+  { "Dell Inc", 0x413c, "Dell Streak 7", 0xb10b,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "Dell Inc", 0x413c, "Dell Venue 7 inch", 0xb11a,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "Dell Inc", 0x413c, "Dell Venue 7 inch (2nd ID)", 0xb11b,
+      DEVICE_FLAGS_ANDROID_BUGS },
+
+  /*
+   * Toshiba
+   * Tentatively flagged all Toshiba devices with
+   * DEVICE_FLAG_BROKEN_SEND_OBJECT_PROPLIST after one of them
+   * showed erroneous behaviour.
+   */
+  { "Toshiba", 0x0930, "Gigabeat MEGF-40", 0x0009,
+      DEVICE_FLAG_NO_RELEASE_INTERFACE |
+      DEVICE_FLAG_BROKEN_SEND_OBJECT_PROPLIST },
+  { "Toshiba", 0x0930, "Gigabeat", 0x000c,
+      DEVICE_FLAG_NO_RELEASE_INTERFACE |
+      DEVICE_FLAG_BROKEN_SEND_OBJECT_PROPLIST },
+  // Reported by Nicholas Tripp
+  { "Toshiba", 0x0930, "Gigabeat P20", 0x000f,
+      DEVICE_FLAG_NO_RELEASE_INTERFACE |
+      DEVICE_FLAG_BROKEN_SEND_OBJECT_PROPLIST },
+  // From libgphoto2
+  { "Toshiba", 0x0930, "Gigabeat S", 0x0010,
+      DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST_ALL |
+      DEVICE_FLAG_NO_RELEASE_INTERFACE |
+      DEVICE_FLAG_BROKEN_SEND_OBJECT_PROPLIST },
+  // Reported by Rob Brown
+  { "Toshiba", 0x0930, "Gigabeat P10", 0x0011,
+      DEVICE_FLAG_NO_RELEASE_INTERFACE |
+      DEVICE_FLAG_BROKEN_SEND_OBJECT_PROPLIST },
+  // Reported by solanum@users.sourceforge.net
+  { "Toshiba", 0x0930, "Gigabeat V30", 0x0014,
+      DEVICE_FLAG_NO_RELEASE_INTERFACE |
+      DEVICE_FLAG_BROKEN_SEND_OBJECT_PROPLIST },
+  // Reported by Michael Davis <slithy@yahoo.com>
+  { "Toshiba", 0x0930, "Gigabeat U", 0x0016,
+      DEVICE_FLAG_NO_RELEASE_INTERFACE |
+      DEVICE_FLAG_BROKEN_SEND_OBJECT_PROPLIST },
+  // Reported by Devon Jacobs <devo@godevo.com>
+  { "Toshiba", 0x0930, "Gigabeat MEU202", 0x0018,
+      DEVICE_FLAG_NO_RELEASE_INTERFACE |
+      DEVICE_FLAG_BROKEN_SEND_OBJECT_PROPLIST },
+  // Reported by Rolf <japan (at) dl3lar.de>
+  { "Toshiba", 0x0930, "Gigabeat T", 0x0019,
+      DEVICE_FLAG_NO_RELEASE_INTERFACE |
+      DEVICE_FLAG_BROKEN_SEND_OBJECT_PROPLIST },
+  // Reported by Phil Ingram <ukpbert@users.sourceforge.net>
+  // Tentatively added - no real reports of this device ID being MTP,
+  // reports as USB Mass Storage currently.
+  { "Toshiba", 0x0930, "Gigabeat MEU201", 0x001a,
+      DEVICE_FLAG_NO_RELEASE_INTERFACE |
+      DEVICE_FLAG_BROKEN_SEND_OBJECT_PROPLIST },
+  // Reported by anonymous SourceForge user
+  { "Toshiba", 0x0930, "Gigabeat MET401", 0x001d,
+      DEVICE_FLAG_NO_RELEASE_INTERFACE |
+      DEVICE_FLAG_BROKEN_SEND_OBJECT_PROPLIST },
+  // Reported by Andree Jacobson <nmcandree@users.sourceforge.net>
+  { "Toshiba", 0x0930, "Excite AT300", 0x0963,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  // Reported by Nigel Cunningham <nigel@tuxonice.net>
+  // Guessing on Android bugs
+  { "Toshiba", 0x0930, "Thrive AT100/AT105", 0x7100,
+      DEVICE_FLAGS_ANDROID_BUGS },
+
+  /*
+   * Archos
+   * These devices have some dual-mode interfaces which will really
+   * respect the driver unloading, so DEVICE_FLAG_UNLOAD_DRIVER
+   * really work on these devices!
+   *
+   * Devices reported by:
+   * Archos
+   * Alexander Haertig <AlexanderHaertig@gmx.de>
+   * Jan Binder
+   * gudul1@users.sourceforge.net
+   * Etienne Chauchot <chauchot.etienne@free.fr>
+   * Kay McCormick <kaym@modsystems.com>
+   * Joe Rabinoff
+   * Jim Krehl <jimmuhk@users.sourceforge.net>
+   * Adrien Guichard <tmor@users.sourceforge.net>
+   * Clément <clemvangelis@users.sourceforge.net>
+   * Thackert <hackertenator@users.sourceforge.net>
+   * Till <Till@users.sourceforge.net>
+   * Sebastien ROHAUT
+   */
+  { "Archos", 0x0e79, "Gmini XS100", 0x1207, DEVICE_FLAG_UNLOAD_DRIVER },
+  { "Archos", 0x0e79, "XS202 (MTP mode)", 0x1208, DEVICE_FLAG_NONE },
+  { "Archos", 0x0e79, "104 (MTP mode)", 0x120a, DEVICE_FLAG_NONE },
+  { "Archos", 0x0e79, "204 (MTP mode)", 0x120c, DEVICE_FLAG_UNLOAD_DRIVER },
+  { "Archos", 0x0e79, "404 (MTP mode)", 0x1301, DEVICE_FLAG_UNLOAD_DRIVER },
+  { "Archos", 0x0e79, "404CAM (MTP mode)", 0x1303, DEVICE_FLAG_UNLOAD_DRIVER },
+  { "Archos", 0x0e79, "504 (MTP mode)", 0x1307, DEVICE_FLAG_UNLOAD_DRIVER },
+  { "Archos", 0x0e79, "604 (MTP mode)", 0x1309, DEVICE_FLAG_UNLOAD_DRIVER },
+  { "Archos", 0x0e79, "604WIFI (MTP mode)", 0x130b, DEVICE_FLAG_UNLOAD_DRIVER },
+  { "Archos", 0x0e79, "704 mobile dvr", 0x130d, DEVICE_FLAG_UNLOAD_DRIVER },
+  { "Archos", 0x0e79, "704TV (MTP mode)", 0x130f, DEVICE_FLAG_UNLOAD_DRIVER },
+  { "Archos", 0x0e79, "405 (MTP mode)", 0x1311, DEVICE_FLAG_UNLOAD_DRIVER },
+  { "Archos", 0x0e79, "605 (MTP mode)", 0x1313, DEVICE_FLAG_UNLOAD_DRIVER },
+  { "Archos", 0x0e79, "605F (MTP mode)", 0x1315, DEVICE_FLAG_UNLOAD_DRIVER },
+  { "Archos", 0x0e79, "705 (MTP mode)", 0x1319, DEVICE_FLAG_UNLOAD_DRIVER },
+  { "Archos", 0x0e79, "TV+ (MTP mode)", 0x131b, DEVICE_FLAG_UNLOAD_DRIVER },
+  { "Archos", 0x0e79, "105 (MTP mode)", 0x131d, DEVICE_FLAG_UNLOAD_DRIVER },
+  { "Archos", 0x0e79, "405HDD (MTP mode)", 0x1321, DEVICE_FLAG_UNLOAD_DRIVER },
+  { "Archos", 0x0e79, "5 (MTP mode 1)", 0x1331, DEVICE_FLAG_UNLOAD_DRIVER },
+  { "Archos", 0x0e79, "5 (MTP mode 2)", 0x1333, DEVICE_FLAG_UNLOAD_DRIVER },
+  { "Archos", 0x0e79, "7 (MTP mode)", 0x1335, DEVICE_FLAG_UNLOAD_DRIVER },
+  { "Archos", 0x0e79, "SPOD (MTP mode)", 0x1341, DEVICE_FLAG_UNLOAD_DRIVER },
+  { "Archos", 0x0e79, "5S IT (MTP mode)", 0x1351, DEVICE_FLAG_UNLOAD_DRIVER },
+  { "Archos", 0x0e79, "5H IT (MTP mode)", 0x1357, DEVICE_FLAG_UNLOAD_DRIVER },
+  { "Archos", 0x0e79, "Arnova Childpad", 0x1458, DEVICE_FLAGS_ANDROID_BUGS },
+  { "Archos", 0x0e79, "Arnova 8c G3", 0x145e, DEVICE_FLAGS_ANDROID_BUGS },
+  { "Archos", 0x0e79, "Arnova 10bG3 Tablet", 0x146b, DEVICE_FLAGS_ANDROID_BUGS },
+  { "Archos", 0x0e79, "97 Xenon", 0x149a, DEVICE_FLAGS_ANDROID_BUGS },
+  { "Archos", 0x0e79, "97 Titanium", 0x14ad, DEVICE_FLAGS_ANDROID_BUGS },
+  { "Archos", 0x0e79, "80 Titanium", 0x14bf, DEVICE_FLAGS_ANDROID_BUGS },
+  { "Archos", 0x0e79, "101 Titanium", 0x14b9, DEVICE_FLAGS_ANDROID_BUGS },
+  /* https://sourceforge.net/p/libmtp/feature-requests/91/ */
+  { "Archos", 0x0e79, "70b Titanium", 0x14ef, DEVICE_FLAGS_ANDROID_BUGS },
+  { "Archos", 0x0e79, "8o G9 (MTP mode)", 0x1508, DEVICE_FLAG_UNLOAD_DRIVER },
+  { "Archos", 0x0e79, "8o G9 Turbo (MTP mode)", 0x1509, DEVICE_FLAG_UNLOAD_DRIVER },
+  { "Archos", 0x0e79, "80G9", 0x1518, DEVICE_FLAGS_ANDROID_BUGS },
+  { "Archos", 0x0e79, "101 G9 (ID1)", 0x1528, DEVICE_FLAGS_ANDROID_BUGS },
+  { "Archos", 0x0e79, "101 G9 (ID2)", 0x1529, DEVICE_FLAGS_ANDROID_BUGS },
+  { "Archos", 0x0e79, "101 G9 Turbo 250 HD", 0x1538, DEVICE_FLAGS_ANDROID_BUGS },
+  { "Archos", 0x0e79, "101 G9 Turbo", 0x1539, DEVICE_FLAGS_ANDROID_BUGS },
+  { "Archos", 0x0e79, "101 XS", 0x1548, DEVICE_FLAGS_ANDROID_BUGS },
+  { "Archos", 0x0e79, "70it2 (ID 1)", 0x1568, DEVICE_FLAGS_ANDROID_BUGS },
+  { "Archos", 0x0e79, "70it2 (ID 2)", 0x1569, DEVICE_FLAGS_ANDROID_BUGS },
+  { "Archos", 0x0e79, "50c", 0x2008, DEVICE_FLAGS_ANDROID_BUGS },
+  { "Archos", 0x0e79, "C40", 0x31ab, DEVICE_FLAGS_ANDROID_BUGS },
+  /* https://sourceforge.net/p/libmtp/bugs/1325/ */
+  { "Archos", 0x0e79, "45 Neon", 0x31f3, DEVICE_FLAGS_ANDROID_BUGS },
+  /* https://sourceforge.net/p/libmtp/bugs/1352/ */
+  { "Archos", 0x0e79, "50 Diamond", 0x3229, DEVICE_FLAGS_ANDROID_BUGS },
+  { "Archos", 0x0e79, "101 G4", 0x4002, DEVICE_FLAGS_ANDROID_BUGS },
+  { "Archos (for Tesco)", 0x0e79, "Hudl (ID1)", 0x5008, DEVICE_FLAGS_ANDROID_BUGS },
+  { "Archos (for Tesco)", 0x0e79, "Hudl (ID2)", 0x5009, DEVICE_FLAGS_ANDROID_BUGS },
+
+  /*
+   * Dunlop (OEM of EGOMAN ltd?) reported by Nanomad
+   * This unit is falsely detected as USB mass storage in Linux
+   * prior to kernel 2.6.19 (fixed by patch from Alan Stern)
+   * so on older kernels special care is needed to remove the
+   * USB mass storage driver that erroneously binds to the device
+   * interface.
+   *
+   * More problematic, this manufacturer+device ID seems to be
+   * reused in a USB Mass Storage device named "Zipy Fox 8GB",
+   * which means libmtp may mistreat it.
+   */
+  { "Dunlop", 0x10d6, "MP3 player 1GB / EGOMAN MD223AFD", 0x2200, DEVICE_FLAG_UNLOAD_DRIVER},
+  // Reported by Steven Black <stevenblack1956@users.sourceforge.net>
+  // Obviously this company goes by many names.
+  // This device is USB 2.0 only. Broken pipe on closing.
+  // A later report indicates that this is also used by the iRiver E200
+  { "Memorex or iRiver", 0x10d6, "MMP 8585/8586 or iRiver E200", 0x2300,
+      DEVICE_FLAG_UNLOAD_DRIVER |
+      DEVICE_FLAG_NO_RELEASE_INTERFACE},
+
+  /*
+   * Sirius
+   */
+  { "Sirius", 0x18f6, "Stiletto", 0x0102, DEVICE_FLAG_NONE },
+  // Reported by Chris Bagwell <chris@cnpbagwell.com>
+  { "Sirius", 0x18f6, "Stiletto 2", 0x0110, DEVICE_FLAG_NONE },
+
+  /*
+   * Nokia
+   * Please verify the low device IDs here, I suspect these might be for
+   * things like USB storage or modem mode actually, whereas the higher
+   * range (0x04nn) could be for MTP. Some of the devices were gathered
+   * from the Nokia WMP drivers:
+   * http://nds2.nokia.com/files/support/global/phones/software/
+   * Address was gathered from going to:
+   * nseries.com
+   * -> support
+   * -> select supported device
+   *  -> PC software
+   *    -> Music software
+   *      -> Windows Media Player 10 driver
+   */
+  // From: DoomHammer <gaczek@users.sourceforge.net>
+  { "Nokia", 0x0421, "N81 Mobile Phone", 0x000a, DEVICE_FLAG_NONE },
+  // From an anonymous SourceForge user
+  { "Nokia", 0x0421, "6120c Classic Mobile Phone", 0x002e, DEVICE_FLAG_NONE },
+  // From Stefano
+  { "Nokia", 0x0421, "N96 Mobile Phone", 0x0039, DEVICE_FLAG_NONE },
+  // From Martijn van de Streek <martijn@vandestreek.net>
+  { "Nokia", 0x0421, "6500c Classic Mobile Phone", 0x003c, DEVICE_FLAG_NONE },
+  // From: DoomHammer <gaczek@users.sourceforge.net>
+  { "Nokia", 0x0421, "3110c Mobile Phone", 0x005f, DEVICE_FLAG_NONE },
+  // From: Vasily <spc-@users.sourceforge.net>
+  { "Nokia", 0x0421, "3109c Mobile Phone", 0x0065, DEVICE_FLAG_NONE },
+  // From: <rawc@users.sourceforge.net>
+  { "Nokia", 0x0421, "5310 XpressMusic", 0x006c, DEVICE_FLAG_NONE },
+  // From: robin (AT) headbank D0Tco DOTuk
+  { "Nokia", 0x0421, "N95 Mobile Phone 8GB", 0x006e, DEVICE_FLAG_NONE },
+  // From Bastien Nocera <hadess@hadess.net>
+  { "Nokia", 0x0421, "N82 Mobile Phone", 0x0074,
+      DEVICE_FLAG_UNLOAD_DRIVER },
+  // From Martijn van de Streek <martijn@vandestreek.net>
+  { "Nokia", 0x0421, "N78 Mobile Phone", 0x0079, DEVICE_FLAG_NONE },
+  // From William Pettersson <the_enigma@users.sourceforge.net>
+  { "Nokia", 0x0421, "6220 Classic", 0x008d, DEVICE_FLAG_NONE },
+  // From kellerkev@gmail.com
+  { "Nokia", 0x0421, "N85 Mobile Phone", 0x0092, DEVICE_FLAG_NONE },
+  // From Alexandre LISSY <lissyx@users.sourceforge.net>
+  { "Nokia", 0x0421, "6210 Navigator", 0x0098, DEVICE_FLAG_NONE },
+  // From: danielw
+  { "Nokia", 0x0421, "E71", 0x00e4, DEVICE_FLAG_NONE },
+  // From: Laurent Bigonville <bigon@users.sourceforge.net>
+  { "Nokia", 0x0421, "E66", 0x00e5, DEVICE_FLAG_NONE },
+  // From: Pier <pierlucalino@users.sourceforge.net>
+  { "Nokia", 0x0421, "5320 XpressMusic", 0x00ea, DEVICE_FLAG_NONE },
+  // From: Gausie <innerdreams@users.sourceforge.net>
+  { "Nokia", 0x0421, "5800 XpressMusic", 0x0154,
+      DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST_ALL },
+  // From: Willy Gardiol (web) <willy@gardiol.org>
+  // Spurious errors for getting all objects, lead me to believe
+  // this flag atleast is needed
+  { "Nokia", 0x0421, "5800 XpressMusic v2", 0x0155,
+      DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST_ALL },
+  // Yet another version... I think
+  { "Nokia", 0x0421, "5800 XpressMusic v3", 0x0159,
+      DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST_ALL },
+  // From an anonymous SourceForge user
+  // Not verified to be MTP
+  { "Nokia", 0x0421, "E63", 0x0179, DEVICE_FLAG_NONE },
+  // Reported by: max g <exactt@users.sourceforge.net>
+  // Reported by: oswillios <loswillios@users.sourceforge.net>
+  { "Nokia", 0x0421, "N79", 0x0186, DEVICE_FLAG_NONE },
+  // From an anonymous SourceForge user
+  { "Nokia", 0x0421, "E71x", 0x01a1, DEVICE_FLAG_NONE },
+  // From Ser <ser@users.sourceforge.net>
+  { "Nokia", 0x0421, "E52", 0x01cf, DEVICE_FLAG_NONE },
+  // From Marcus Meissner
+  { "Nokia", 0x0421, "3710", 0x01ee, DEVICE_FLAG_NONE },
+  // From: AxeL <axel__17@users.sourceforge.net>
+  { "Nokia", 0x0421, "N97-1", 0x01f4, DEVICE_FLAG_NONE },
+  // From: FunkyPenguin <awafaa@users.sourceforge.net>
+  { "Nokia", 0x0421, "N97", 0x01f5, DEVICE_FLAG_NONE },
+  // From: Anonymous SourceForge user
+  { "Nokia", 0x0421, "5130 XpressMusic", 0x0209, DEVICE_FLAG_NONE },
+  // From: Anonymous SourceForge user
+  { "Nokia", 0x0421, "E72", 0x0221, DEVICE_FLAG_NONE },
+  // From: Anonymous SourceForge user
+  { "Nokia", 0x0421, "5530", 0x0229, DEVICE_FLAG_NONE },
+  /* Grzegorz Woźniak <wozniakg@gmail.com> */
+  { "Nokia", 0x0421, "E6", 0x032f, DEVICE_FLAG_NONE },
+  // From: Anonymous SourceForge user
+  { "Nokia", 0x0421, "N97 mini", 0x026b, DEVICE_FLAG_NONE },
+  // From: Anonymous SourceForge user
+  { "Nokia", 0x0421, "X6", 0x0274, DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST_ALL },
+  // From: Alexander Kojevnikov <alex-kay@users.sourceforge.net>
+  { "Nokia", 0x0421, "6600i", 0x0297, DEVICE_FLAG_NONE },
+  // From: Karthik Paithankar <whyagain2005@users.sourceforge.net>
+  { "Nokia", 0x0421, "2710", 0x02c1, DEVICE_FLAG_NONE },
+  // From: Mick Stephenson <MickStep@users.sourceforge.net>
+  { "Nokia", 0x0421, "5230", 0x02e2, DEVICE_FLAG_NONE },
+  // From: Lan Liu at Nokia <lan.liu@nokia.com>
+  { "Nokia", 0x0421, "N8", 0x02fe, DEVICE_FLAG_NONE },
+  // From: Lan Liu at Nokia <lan.liu@nokia.com>
+  { "Nokia", 0x0421, "N8 (Ovi mode)", 0x0302, DEVICE_FLAG_NONE },
+  // From: Martijn Hoogendoorn <m.hoogendoorn@gmail.com>
+  { "Nokia", 0x0421, "E7", 0x0334, DEVICE_FLAG_NONE },
+  // From: Raul Metsma <raul@innovaatik.ee>
+  { "Nokia", 0x0421, "E7 (Ovi mode)", 0x0335, DEVICE_FLAG_NONE },
+  // Reported by Serg <rd77@users.sourceforge.net>
+  // Symbian phone
+  { "Nokia", 0x0421, "C7", 0x03c1, DEVICE_FLAG_NONE },
+  // Reported by Anonymous SourceForge user
+  { "Nokia", 0x0421, "C7 (ID2)", 0x03cd, DEVICE_FLAG_NONE },
+  // Reported by Anonymous SourceForge user
+  { "Nokia", 0x0421, "N950", 0x03d2, DEVICE_FLAG_NONE },
+  // From: http://nds2.nokia.com/files/support/global/phones/software/Nokia_3250_WMP10_driver.inf
+  { "Nokia", 0x0421, "3250 Mobile Phone", 0x0462, DEVICE_FLAG_NONE },
+  // From http://nds2.nokia.com/files/support/global/phones/software/Nokia_N93_WMP10_Driver.inf
+  { "Nokia", 0x0421, "N93 Mobile Phone", 0x0478, DEVICE_FLAG_NONE },
+  // From: http://nds2.nokia.com/files/support/global/phones/software/Nokia_5500_Sport_WMP10_driver.inf
+  { "Nokia", 0x0421, "5500 Sport Mobile Phone", 0x047e, DEVICE_FLAG_NONE },
+  // From http://nds2.nokia.com/files/support/global/phones/software/Nokia_N91_WMP10_Driver.inf
+  { "Nokia", 0x0421, "N91 Mobile Phone", 0x0485, DEVICE_FLAG_NONE },
+  // From: Christian Rusa <kristous@users.sourceforge.net>
+  { "Nokia", 0x0421, "5700 XpressMusic Mobile Phone", 0x04b4, DEVICE_FLAG_NONE },
+  // From: Mitchell Hicks <mitchix@yahoo.com>
+  { "Nokia", 0x0421, "5300 Mobile Phone", 0x04ba, DEVICE_FLAG_NONE },
+  // https://sourceforge.net/tracker/index.php?func=detail&aid=2692473&group_id=8874&atid=358874
+  // From: Tiburce <tiburce@users.sourceforge.net>
+  { "Nokia", 0x0421, "5200 Mobile Phone", 0x04be,
+      DEVICE_FLAG_BROKEN_BATTERY_LEVEL },
+  // From Christian Arnold <webmaster@arctic-media.de>
+  { "Nokia", 0x0421, "N73 Mobile Phone", 0x04d1, DEVICE_FLAG_UNLOAD_DRIVER },
+  // From Swapan <swapan@yahoo.com>
+  { "Nokia", 0x0421, "N75 Mobile Phone", 0x04e1, DEVICE_FLAG_NONE },
+  // From: http://nds2.nokia.com/files/support/global/phones/software/Nokia_N93i_WMP10_driver.inf
+  { "Nokia", 0x0421, "N93i Mobile Phone", 0x04e5, DEVICE_FLAG_NONE },
+  // From Anonymous Sourceforge User
+  { "Nokia", 0x0421, "N95 Mobile Phone", 0x04ef, DEVICE_FLAG_NONE },
+  // From: Pat Nicholls <pat@patandannie.co.uk>
+  { "Nokia", 0x0421, "N80 Internet Edition (Media Player)", 0x04f1,
+      DEVICE_FLAG_UNLOAD_DRIVER },
+  // From: Maxin B. John <maxin.john@gmail.com>
+  { "Nokia", 0x0421, "N9", 0x051a, DEVICE_FLAG_NONE },
+  /* https://sourceforge.net/p/libmtp/bugs/1308/ */
+  { "Nokia", 0x0421, "N300", 0x0524, DEVICE_FLAG_NONE },
+  { "Nokia", 0x0421, "C5-00", 0x0592, DEVICE_FLAG_NONE },
+  { "Nokia", 0x0421, "808 PureView", 0x05d3, DEVICE_FLAG_NONE },
+  // Reported by Sampo Savola
+  // Covers Lumia 920, 820 and probably any WP8 device.
+  { "Nokia", 0x0421, "Lumia WP8", 0x0661, DEVICE_FLAG_NONE },
+  /* https://sourceforge.net/p/libmtp/bugs/1176/ */
+  { "Nokia", 0x0421, "Lumia 301", 0x0666, DEVICE_FLAG_NONE },
+  /* https://sourceforge.net/p/libmtp/support-requests/146/ */
+  { "Nokia", 0x0421, "XL", 0x06e8, DEVICE_FLAG_UNLOAD_DRIVER },
+  /* https://sourceforge.net/p/libmtp/patches/69/
+   * https://sourceforge.net/p/libmtp/bugs/1285/
+   * ID is the same for various Lumia version.
+   */
+  { "Nokia", 0x0421, "Lumia (RM-975)", 0x06fc, DEVICE_FLAG_NONE },
+
+
+  /*
+   * Qualcomm
+   * This vendor ID seems to be used a bit by others.
+   */
+
+  // Reported by Richard Wall <richard@the-moon.net>
+  { "Qualcomm (for Nokia)", 0x05c6, "5530 Xpressmusic", 0x0229,
+      DEVICE_FLAG_NONE },
+  // One thing stated by reporter (Nokia model) another by the detect log...
+  { "Qualcomm (for Nokia/Verizon)", 0x05c6, "6205 Balboa/Verizon Music Phone",
+      0x3196, DEVICE_FLAG_NONE },
+  { "Qualcomm (for Gigabyte)", 0x05c6, "GSmart G1342",
+      0x8800, DEVICE_FLAG_NONE },
+  { "Qualcomm (for Smartfren)", 0x05c6, "Andromax U",
+      0x9025, DEVICE_FLAG_NONE },
+  // New Android phone of the OnePlus brand : the One model
+  { "Qualcomm (for OnePlus)", 0x05c6, "One (MTP)",
+      0x6764, DEVICE_FLAGS_ANDROID_BUGS },
+  { "Qualcomm (for OnePlus)", 0x05c6, "One (MTP+ADB)",
+      0x6765, DEVICE_FLAGS_ANDROID_BUGS },
+
+  { "Qualcomm (for PhiComm)", 0x05c6, "C230w (MTP)",
+      0x9039, DEVICE_FLAGS_ANDROID_BUGS },
+
+  /* https://sourceforge.net/p/libmtp/bugs/1284/ */
+  { "Qualcomm (for Highscreen)", 0x05c6, "Omega Prime S",
+      0xf003, DEVICE_FLAGS_ANDROID_BUGS },
+
+  /*
+   * Vendor ID 0x13d1 is some offshoring company in China,
+   * in one source named "A-Max Technology Macao Commercial
+   * Offshore Co. Ltd." sometime "CCTech".
+   */
+  // Logik brand
+  { "Logik", 0x13d1, "LOG DAX MP3 and DAB Player", 0x7002, DEVICE_FLAG_UNLOAD_DRIVER },
+  // Technika brand
+  // Reported by <Ooblick@users.sourceforge.net>
+  { "Technika", 0x13d1, "MP-709", 0x7017, DEVICE_FLAG_UNLOAD_DRIVER },
+
+
+  /*
+   * RCA / Thomson
+   */
+  // From kiki <omkiki@users.sourceforge.net>
+  { "Thomson", 0x069b, "EM28 Series", 0x0774, DEVICE_FLAG_NONE },
+  { "Thomson / RCA", 0x069b, "Opal / Lyra MC4002", 0x0777, DEVICE_FLAG_NONE },
+  { "Thomson", 0x069b, "Lyra MC5104B (M51 Series)", 0x077c, DEVICE_FLAG_NONE },
+  { "Thomson", 0x069b, "RCA H106", 0x301a, DEVICE_FLAG_UNLOAD_DRIVER },
+  // From Svenna <svenna@svenna.de>
+  // Not confirmed to be MTP.
+  { "Thomson", 0x069b, "scenium E308", 0x3028, DEVICE_FLAG_NONE },
+  // From XNJB user
+  { "Thomson / RCA", 0x069b, "Lyra HC308A", 0x3035, DEVICE_FLAG_NONE },
+
+  /*
+   * Fujitsu devices
+   */
+  { "Fujitsu, Ltd", 0x04c5, "F903iX HIGH-SPEED", 0x1140, DEVICE_FLAG_NONE },
+  // Reported by Thomas Bretthauer
+  { "Fujitsu, Ltd", 0x04c5, "STYLISTIC M532", 0x133b,
+      DEVICE_FLAGS_ANDROID_BUGS },
+
+  /*
+   * Palm device userland program named Pocket Tunes
+   * Reported by Peter Gyongyosi <gyp@impulzus.com>
+   */
+  { "NormSoft, Inc.", 0x1703, "Pocket Tunes", 0x0001, DEVICE_FLAG_NONE },
+  // Reported by anonymous submission
+  { "NormSoft, Inc.", 0x1703, "Pocket Tunes 4", 0x0002, DEVICE_FLAG_NONE },
+
+  /*
+   * TrekStor, Medion and Maxfield devices
+   * Their datasheet claims their devices are dualmode so probably needs to
+   * unload the attached drivers here.
+   */
+  // Reported by Stefan Voss <svoss@web.de>
+  // This is a Sigmatel SoC with a hard disk.
+  { "TrekStor", 0x066f, "Vibez 8/12GB", 0x842a,
+    DEVICE_FLAG_UNLOAD_DRIVER | DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST },
+  // Reported by anonymous SourceForge user.
+  // This one done for Medion, whatever that is. Error reported so assume
+  // the same bug flag as its ancestor above.
+  { "Medion", 0x066f, "MD8333 (ID1)", 0x8550,
+    DEVICE_FLAG_UNLOAD_DRIVER | DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST },
+  // Reported by anonymous SourceForge user
+  { "Medion", 0x066f, "MD8333 (ID2)", 0x8588,
+    DEVICE_FLAG_UNLOAD_DRIVER | DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST },
+  /* https://sourceforge.net/p/libmtp/bugs/1359/ */
+  { "Verizon", 0x0408, "Ellipsis 7", 0x3899,
+    DEVICE_FLAGS_ANDROID_BUGS },
+  // The vendor ID is "Quanta Computer, Inc."
+  // same as Olivetti Olipad 110
+  // Guessing on device flags
+  { "Medion", 0x0408, "MD99000 (P9514)/Olivetti Olipad 110", 0xb009,
+    DEVICE_FLAG_UNLOAD_DRIVER | DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST },
+  // Reported by Richard Eigenmann <richieigenmann@users.sourceforge.net>
+  { "Medion", 0x0408, "Lifetab P9514", 0xb00a,
+    DEVICE_FLAG_UNLOAD_DRIVER | DEVICE_FLAGS_ANDROID_BUGS },
+  // Reported by anonymous SourceForge user
+  { "Maxfield", 0x066f, "G-Flash NG 1GB", 0x846c,
+    DEVICE_FLAG_UNLOAD_DRIVER | DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST },
+  // Reported by PaoloC <efmpsc@users.sourceforge.net>
+  // Apparently SigmaTel has an SDK for MTP players with this ID
+  { "SigmaTel Inc.", 0x066f, "MTPMSCN Audio Player", 0xa010,
+    DEVICE_FLAG_UNLOAD_DRIVER | DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST },
+  // Reported by Cristi Magherusan <majeru@gentoo.ro>
+  { "TrekStor", 0x0402, "i.Beat Sweez FM", 0x0611,
+    DEVICE_FLAG_UNLOAD_DRIVER },
+  // Reported by Fox-ino <fox-ino@users.sourceforge.net>
+  // No confirmation that this is really MTP so commented it out.
+  // { "ALi Corp.", 0x0402, "MPMAN 2GB", 0x5668,
+  // DEVICE_FLAG_UNLOAD_DRIVER },
+  // Reported by Anonymous SourceForge user
+  {"TrekStor", 0x1e68, "i.Beat Organix 2.0", 0x0002,
+    DEVICE_FLAG_UNLOAD_DRIVER },
+
+  /* Also Thalia Toline. https://sourceforge.net/p/libmtp/bugs/1156/ */
+  {"iRiver", 0x1e68, "Tolino Tab 7", 0x1002,
+    DEVICE_FLAGS_ANDROID_BUGS },
+
+  /*
+   * Disney/Tevion/MyMusix
+   */
+  // Reported by XNJB user
+  { "Disney", 0x0aa6, "MixMax", 0x6021, DEVICE_FLAG_NONE },
+  // Reported by anonymous Sourceforge user
+  { "Tevion", 0x0aa6, "MD 81488", 0x3011, DEVICE_FLAG_NONE },
+  // Reported by Peter Hedlund <peter@peterandlinda.com>
+  { "MyMusix", 0x0aa6, "PD-6070", 0x9601, DEVICE_FLAG_UNLOAD_DRIVER |
+    DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST |
+    DEVICE_FLAG_BROKEN_SEND_OBJECT_PROPLIST |
+    DEVICE_FLAG_NO_RELEASE_INTERFACE },
+
+  /*
+   * Cowon Systems, Inc.
+   * The iAudio audiophile devices don't encourage the use of MTP.
+   * See: http://wiki.xiph.org/index.php/PortablePlayers for Ogg
+   * status
+   */
+  // Reported by Patrik Johansson <Patrik.Johansson@qivalue.com>
+  { "Cowon", 0x0e21, "iAudio U3 (MTP mode)", 0x0701,
+   DEVICE_FLAG_UNLOAD_DRIVER | DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST |
+   DEVICE_FLAG_OGG_IS_UNKNOWN | DEVICE_FLAG_FLAC_IS_UNKNOWN },
+  // Reported by Kevin Michael Smith <hai-etlik@users.sourceforge.net>
+  { "Cowon", 0x0e21, "iAudio 6 (MTP mode)", 0x0711,
+   DEVICE_FLAG_UNLOAD_DRIVER | DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST },
+  // Reported by Roberth Karman
+  { "Cowon", 0x0e21, "iAudio 7 (MTP mode)", 0x0751,
+   DEVICE_FLAG_UNLOAD_DRIVER | DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST |
+   DEVICE_FLAG_OGG_IS_UNKNOWN | DEVICE_FLAG_FLAC_IS_UNKNOWN },
+  // Reported by an anonymous SourceForge user
+  { "Cowon", 0x0e21, "iAudio U5 (MTP mode)", 0x0761,
+   DEVICE_FLAG_UNLOAD_DRIVER | DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST |
+   DEVICE_FLAG_OGG_IS_UNKNOWN | DEVICE_FLAG_FLAC_IS_UNKNOWN },
+  // Reported by TJ Something <tjbk_tjb@users.sourceforge.net>
+  { "Cowon", 0x0e21, "iAudio D2 (MTP mode)", 0x0801,
+   DEVICE_FLAG_UNLOAD_DRIVER | DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST |
+   DEVICE_FLAG_OGG_IS_UNKNOWN | DEVICE_FLAG_FLAC_IS_UNKNOWN },
+  // Reported by anonymous Sourceforge user
+  { "Cowon", 0x0e21, "iAudio D2+ FW 2.x (MTP mode)", 0x0861,
+   DEVICE_FLAG_UNLOAD_DRIVER | DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST |
+   DEVICE_FLAG_OGG_IS_UNKNOWN | DEVICE_FLAG_FLAC_IS_UNKNOWN },
+  // From Rockbox device listing
+  { "Cowon", 0x0e21, "iAudio D2+ DAB FW 4.x (MTP mode)", 0x0871,
+   DEVICE_FLAG_UNLOAD_DRIVER | DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST |
+   DEVICE_FLAG_OGG_IS_UNKNOWN | DEVICE_FLAG_FLAC_IS_UNKNOWN },
+  // From Rockbox device listing
+  { "Cowon", 0x0e21, "iAudio D2+ FW 3.x (MTP mode)", 0x0881,
+   DEVICE_FLAG_UNLOAD_DRIVER | DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST |
+   DEVICE_FLAG_OGG_IS_UNKNOWN | DEVICE_FLAG_FLAC_IS_UNKNOWN },
+  // From Rockbox device listing
+  { "Cowon", 0x0e21, "iAudio D2+ DMB FW 1.x (MTP mode)", 0x0891,
+   DEVICE_FLAG_UNLOAD_DRIVER | DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST |
+   DEVICE_FLAG_OGG_IS_UNKNOWN | DEVICE_FLAG_FLAC_IS_UNKNOWN },
+  // Reported by <twkonefal@users.sourceforge.net>
+  { "Cowon", 0x0e21, "iAudio S9 (MTP mode)", 0x0901,
+   DEVICE_FLAG_UNLOAD_DRIVER | DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST |
+   DEVICE_FLAG_OGG_IS_UNKNOWN | DEVICE_FLAG_FLAC_IS_UNKNOWN },
+  // Reported by Dan Nicholson <dbn.lists@gmail.com>
+  { "Cowon", 0x0e21, "iAudio 9 (MTP mode)", 0x0911,
+   DEVICE_FLAG_UNLOAD_DRIVER | DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST |
+   DEVICE_FLAG_OGG_IS_UNKNOWN | DEVICE_FLAG_FLAC_IS_UNKNOWN },
+  // Reported by Franck VDL <franckv@users.sourceforge.net>
+  { "Cowon", 0x0e21, "iAudio J3 (MTP mode)", 0x0921,
+   DEVICE_FLAG_UNLOAD_DRIVER | DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST |
+   DEVICE_FLAG_OGG_IS_UNKNOWN | DEVICE_FLAG_FLAC_IS_UNKNOWN },
+  // Reported by anonymous SourceForge user
+  { "Cowon", 0x0e21, "iAudio X7 (MTP mode)", 0x0931,
+   DEVICE_FLAG_UNLOAD_DRIVER | DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST |
+   DEVICE_FLAG_OGG_IS_UNKNOWN | DEVICE_FLAG_FLAC_IS_UNKNOWN },
+  // Reported by anonymous SourceForge user
+  { "Cowon", 0x0e21, "iAudio C2 (MTP mode)", 0x0941,
+   DEVICE_FLAG_UNLOAD_DRIVER | DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST |
+   DEVICE_FLAG_OGG_IS_UNKNOWN | DEVICE_FLAG_FLAC_IS_UNKNOWN },
+  { "Cowon", 0x0e21, "iAudio 10 (MTP mode)", 0x0952,
+   DEVICE_FLAG_UNLOAD_DRIVER | DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST |
+   DEVICE_FLAG_OGG_IS_UNKNOWN | DEVICE_FLAG_FLAC_IS_UNKNOWN },
+
+  /*
+   * Insignia, dual-mode.
+   */
+  { "Insignia", 0x19ff, "NS-DV45", 0x0303, DEVICE_FLAG_UNLOAD_DRIVER },
+  // Reported by Rajan Bella <rajanbella@yahoo.com>
+  { "Insignia", 0x19ff, "Sport Player", 0x0307, DEVICE_FLAG_UNLOAD_DRIVER },
+  // Reported by "brad" (anonymous, sourceforge)
+  { "Insignia", 0x19ff, "Pilot 4GB", 0x0309, DEVICE_FLAG_UNLOAD_DRIVER },
+
+  /*
+   * LG Electronics
+   */
+  // Uncertain if this is really the MTP mode device ID...
+  { "LG Electronics Inc.", 0x043e, "T54", 0x7040,
+      DEVICE_FLAG_UNLOAD_DRIVER },
+  // Not verified - anonymous submission
+  { "LG Electronics Inc.", 0x043e, "UP3", 0x70b1, DEVICE_FLAG_NONE },
+  // Reported by Joseph Nahmias <joe@nahimas.net>
+  { "LG Electronics Inc.", 0x1004, "VX8550 V CAST Mobile Phone", 0x6010,
+      DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST |
+      DEVICE_FLAG_ALWAYS_PROBE_DESCRIPTOR },
+  // Reported by Cyrille Potereau <cyrille.potereau@wanadoo.fr>
+  { "LG Electronics Inc.", 0x1004, "KC910 Renoir Mobile Phone", 0x608f,
+      DEVICE_FLAG_UNLOAD_DRIVER },
+  // Reported by Aaron Slunt <tongle@users.sourceforge.net>
+  { "LG Electronics Inc.", 0x1004, "GR-500 Music Player", 0x611b,
+      DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST |
+      DEVICE_FLAG_ALWAYS_PROBE_DESCRIPTOR },
+  { "LG Electronics Inc.", 0x1004, "KM900", 0x6132,
+      DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST |
+      DEVICE_FLAG_UNLOAD_DRIVER },
+  { "LG Electronics Inc.", 0x1004, "LG8575", 0x619a,
+      DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST |
+      DEVICE_FLAG_UNLOAD_DRIVER },
+  /*
+   * These two are LG Android phones:
+   * LG-F6
+   * V909 G-Slate
+   */
+  { "LG Electronics Inc.", 0x1004, "Android phone (ID1)", 0x61f1,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "LG Electronics Inc.", 0x1004, "Android phone (ID2)", 0x61f9,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  /* https://sourceforge.net/p/libmtp/bugs/1007/ */
+  { "LG Electronics Inc.", 0x1004, "LG VS980", 0x621c,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "LG Electronics Inc.", 0x1004, "LG2 Optimus", 0x6225,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "LG Electronics Inc.", 0x1004, "LG VS870", 0x6239,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  /* https://sourceforge.net/p/libmtp/bugs/992/ */
+  { "LG Electronics Inc.", 0x1004, "LG VS890", 0x623d,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "LG Electronics Inc.", 0x1004, "VK810", 0x6265,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "LG Electronics Inc.", 0x1004, "G3", 0x627f,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  /* https://sourceforge.net/p/libmtp/support-requests/134/ */
+  { "LG Electronics Inc.", 0x1004, "G3 (VS985)", 0x626e,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  /*
+   * This VID+PID is used by a lot of LG models:
+   * E430
+   * E460
+   * E610
+   * E612
+   * E617G
+   * E970
+   * P700
+   */
+  { "LG Electronics Inc.", 0x1004, "Various E and P models", 0x631c,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  /* https://sourceforge.net/p/libmtp/bugs/1294/ */
+  { "LG Electronics Inc.", 0x1004, "LG G Flex 2", 0x633e,
+      DEVICE_FLAGS_ANDROID_BUGS },
+
+  /*
+   * Sony
+   * It could be that these PIDs are one-per hundred series, so
+   * NWZ-A8xx is 0325, NWZ-S5xx is 0x326 etc. We need more devices
+   * reported to see a pattern here.
+   */
+  // Reported by Alessandro Radaelli <alessandro.radaelli@aruba.it>
+  { "Sony", 0x054c, "NWZ-A815/NWZ-A818", 0x0325,
+      DEVICE_FLAGS_SONY_NWZ_BUGS },
+  // Reported by anonymous Sourceforge user.
+  { "Sony", 0x054c, "NWZ-S516", 0x0326,
+      DEVICE_FLAGS_SONY_NWZ_BUGS },
+  // Reported by Endre Oma <endre.88.oma@gmail.com>
+  { "Sony", 0x054c, "NWZ-S615F/NWZ-S616F/NWZ-S618F", 0x0327,
+      DEVICE_FLAGS_SONY_NWZ_BUGS },
+  // Reported by Jean-Marc Bourguet <jm@bourguet.org>
+  { "Sony", 0x054c, "NWZ-S716F", 0x035a,
+      DEVICE_FLAGS_SONY_NWZ_BUGS },
+  // Reported by Anon SF User / Anthon van der Neut <avanderneut@avid.com>
+  { "Sony", 0x054c, "NWZ-A826/NWZ-A828/NWZ-A829", 0x035b,
+      DEVICE_FLAGS_SONY_NWZ_BUGS },
+  // Reported by Niek Klaverstijn <niekez@users.sourceforge.net>
+  { "Sony", 0x054c, "NWZ-A726/NWZ-A728/NWZ-A768", 0x035c,
+      DEVICE_FLAGS_SONY_NWZ_BUGS },
+  // Reported by Mehdi AMINI <mehdi.amini - at - ulp.u-strasbg.fr>
+  { "Sony", 0x054c, "NWZ-B135", 0x036e,
+      DEVICE_FLAGS_SONY_NWZ_BUGS },
+  // Reported by <tiagoboldt@users.sourceforge.net>
+  { "Sony", 0x054c, "NWZ-E436F", 0x0385,
+      DEVICE_FLAGS_SONY_NWZ_BUGS },
+  // Reported by Michael Wilkinson
+  { "Sony", 0x054c, "NWZ-W202", 0x0388,
+      DEVICE_FLAGS_SONY_NWZ_BUGS },
+  // Reported by Ondrej Sury <ondrej@sury.org>
+  { "Sony", 0x054c, "NWZ-S739F", 0x038c,
+      DEVICE_FLAGS_SONY_NWZ_BUGS },
+  // Reported by Marco Filipe Nunes Soares Abrantes Pereira <marcopereira@ua.pt>
+  { "Sony", 0x054c, "NWZ-S638F", 0x038e,
+      DEVICE_FLAGS_SONY_NWZ_BUGS },
+  // Reported by Elliot <orwells@users.sourceforge.net>
+  { "Sony", 0x054c, "NWZ-X1050B/NWZ-X1060B",
+    0x0397, DEVICE_FLAGS_SONY_NWZ_BUGS },
+  // Reported by Silvio J. Gutierrez <silviogutierrez@users.sourceforge.net>
+  { "Sony", 0x054c, "NWZ-X1051/NWZ-X1061", 0x0398,
+      DEVICE_FLAGS_SONY_NWZ_BUGS },
+  // Reported by Gregory Boddin <gregory@siwhine.net>
+  { "Sony", 0x054c, "NWZ-B142F", 0x03d8,
+      DEVICE_FLAGS_SONY_NWZ_BUGS },
+  // Reported by Rick Warner <rick@reptileroom.net>
+  { "Sony", 0x054c, "NWZ-E344/E345", 0x03fc,
+      DEVICE_FLAGS_SONY_NWZ_BUGS },
+  // Reported by Jonathan Stowe <gellyfish@users.sourceforge.net>
+  { "Sony", 0x054c, "NWZ-E445", 0x03fd,
+      DEVICE_FLAGS_SONY_NWZ_BUGS },
+  // Reported by Anonymous SourceForge user
+  { "Sony", 0x054c, "NWZ-S545", 0x03fe,
+      DEVICE_FLAGS_SONY_NWZ_BUGS },
+  { "Sony", 0x054c, "NWZ-A845", 0x0404,
+      DEVICE_FLAGS_SONY_NWZ_BUGS },
+  // Reported by anonymous SourceForge user
+  { "Sony", 0x054c, "NWZ-W252B", 0x04bb,
+      DEVICE_FLAGS_SONY_NWZ_BUGS },
+  // Suspect this device has strong DRM features
+  // See https://answers.launchpad.net/ubuntu/+source/libmtp/+question/149587
+  { "Sony", 0x054c, "NWZ-B153F", 0x04be,
+      DEVICE_FLAGS_SONY_NWZ_BUGS },
+  { "Sony", 0x054c, "NWZ-E354", 0x04cb,
+      DEVICE_FLAGS_SONY_NWZ_BUGS },
+  // Reported by Toni Burgarello
+  { "Sony", 0x054c, "NWZ-S754", 0x04cc,
+      DEVICE_FLAGS_SONY_NWZ_BUGS },
+  // Reported by Hideki Yamane <henrich@debian.org>
+  { "Sony", 0x054c, "Sony Tablet P1", 0x04d1,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  // Reported by dmiceman
+  { "Sony", 0x054c, "NWZ-B163F", 0x059a,
+      DEVICE_FLAGS_SONY_NWZ_BUGS },
+  { "Sony", 0x054c, "NWZ-E464", 0x05a6,
+      DEVICE_FLAGS_SONY_NWZ_BUGS },
+  // Reported by Jan Rheinlaender <jrheinlaender@users.sourceforge.net>
+  { "Sony", 0x054c, "NWZ-S765", 0x05a8,
+      DEVICE_FLAGS_SONY_NWZ_BUGS },
+  // Olivier Keshavjee <olivierkes@users.sourceforge.net>
+  { "Sony", 0x054c, "Sony Tablet S", 0x05b3,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  // Reported by ghalambaz <ghalambaz@users.sourceforge.net>
+  { "Sony", 0x054c, "Sony Tablet S1", 0x05b4,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "Sony", 0x054c, "NWZ-B173F", 0x0689,
+      DEVICE_FLAGS_SONY_NWZ_BUGS },
+  { "Sony", 0x054c, "DCR-SR75", 0x1294,
+      DEVICE_FLAGS_SONY_NWZ_BUGS },
+
+  /*
+   * SonyEricsson
+   * These initially seemed to support GetObjPropList but later revisions
+   * of the firmware seem to have broken it, so all are flagged as broken
+   * for now.
+   */
+  // Reported by Øyvind Stegard <stegaro@users.sourceforge.net>
+  { "SonyEricsson", 0x0fce, "K850i", 0x0075,
+      DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST },
+  // Reported by Michael Eriksson
+  { "SonyEricsson", 0x0fce, "W910", 0x0076,
+      DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST },
+  // Reported by Zack <zackdvd@users.sourceforge.net>
+  { "SonyEricsson", 0x0fce, "W890i", 0x00b3,
+      DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST },
+  // Reported by robert dot ahlskog at gmail
+  { "SonyEricsson", 0x0fce, "W760i", 0x00c6,
+      DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST },
+  // Reported by Linus Åkesson <linusakesson@users.sourceforge.net>
+  { "SonyEricsson", 0x0fce, "C902", 0x00d4,
+      DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST },
+  // Reported by an anonymous SourceForge user
+  { "SonyEricsson", 0x0fce, "C702", 0x00d9,
+      DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST },
+  // Reported by Christian Zuckschwerdt <christian@zuckschwerdt.org>
+  { "SonyEricsson", 0x0fce, "W980", 0x00da,
+      DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST },
+  // Reported by David Taylor <davidt-libmtp@yadt.co.uk>
+  { "SonyEricsson", 0x0fce, "C905", 0x00ef,
+      DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST },
+  // Reported by David House <dmhouse@users.sourceforge.net>
+  { "SonyEricsson", 0x0fce, "W595", 0x00f3,
+      DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST_ALL |
+      DEVICE_FLAG_BROKEN_SET_OBJECT_PROPLIST },
+  // Reported by Mattias Evensson <mevensson@users.sourceforge.net>
+  { "SonyEricsson", 0x0fce, "W902", 0x00f5,
+      DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST },
+  // Reported by Sarunas <sarunas@users.sourceforge.net>
+  // Doesn't need any flags according to reporter
+  { "SonyEricsson", 0x0fce, "T700", 0x00fb,
+      DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST_ALL },
+  // Reported by Stéphane Pontier <shadow_walker@users.sourceforge.net>
+  { "SonyEricsson", 0x0fce, "W705/W715", 0x0105,
+      DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST },
+  // Reported by Håkan Kvist
+  { "SonyEricsson", 0x0fce, "W995", 0x0112,
+      DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST },
+  // Reported by anonymous SourceForge user
+  { "SonyEricsson", 0x0fce, "U5", 0x0133,
+      DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST },
+  // Reported by Flo <lhugsereg@users.sourceforge.net>
+  { "SonyEricsson", 0x0fce, "U8i", 0x013a,
+      DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST },
+  // Reported by xirotyu <xirotyu@users.sourceforge.net>
+  { "SonyEricsson", 0x0fce,  "j10i2 (Elm)", 0x0144,
+      DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST },
+  // Reported by Serge Chirik <schirik@users.sourceforge.net>
+  { "SonyEricsson", 0x0fce,  "j108i (Cedar)", 0x014e,
+      DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST },
+  // Reported by Jonas Nyrén <spectralmks@users.sourceforge.net>
+  { "SonyEricsson", 0x0fce, "W302", 0x10c8,
+      DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST },
+  // Reported by Anonymous Sourceforge user
+  { "SonyEricsson", 0x0fce,  "j10i (Elm)", 0xd144,
+      DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST },
+  // Reported by Thomas Schweitzer <thomas_-_s@users.sourceforge.net>
+  { "SonyEricsson", 0x0fce, "K550i", 0xe000,
+      DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST },
+
+  /*
+   * SonyEricsson/SONY Android devices usually have three personalities due to
+   * using composite descriptors and the fact that Windows cannot distinguish
+   * the device unless each composite descriptor is unique.
+   *
+   * Legend:
+   * MTP = Media Transfer Protocol
+   * UMS = USB Mass Storage Protocol
+   * ADB = Android Debug Bridge Protocol
+   * CDC = Communications Device Class, Internet Sharing
+   *
+   * 0x0nnn = MTP
+   * 0x4nnn = MTP + UMS (for CD-ROM)
+   * 0x5nnn = MTP + ADB
+   * 0x6nnn = UMS + ADB
+   * 0x7nnn = MTP + CDC
+   * 0x8nnn = MTP + CDC + ADB
+   * 0xannn = MTP + UMS (MTP for eMMC and UMS for external SD card)
+   * 0xbnnn = MTP + UMS + ADB
+   * 0xennn = UMS only
+   *
+   * The SonyEricsson and SONY devices have (at least) two deployed MTP
+   * stacks: Aricent and Android. These have different bug flags, and
+   * sometimes the same device has firmware upgrades moving it from
+   * the Aricent to Android MTP stack without changing the device
+   * VID+PID (first observed on the SK17i Xperia Mini Pro), so the
+   * detection has to be more elaborate. The code in libmtp.c will do
+   * this and assign the proper bug flags (hopefully).
+   * That is why DEVICE_FLAG_NONE is used for these devices.
+   *
+   * Devices reported by:
+   * Sony Mobile Communications (via Toby Collett)
+   * Jonas Salling
+   * Eamonn Webster <eweb@users.sourceforge.net>
+   * Alejandro DC <Alejandro_DC@users.sourceforge.ne>
+   * StehpanKa <stehp@users.sourceforge.net>
+   * hdhoang <hdhoang@users.sourceforge.net>
+   * Paul Taylor
+   * Bruno Basilio <bbasilio@users.sourceforge.net>
+   * Christoffer Holmstedt <christofferh@users.sourceforge.net>
+   * equaeghe <equaeghe@users.sourceforge.net>
+   * Ondra Lengal
+   * Michael K. <kmike@users.sourceforge.net>
+   * Jean-François  B. <changi67@users.sourceforge.net>
+   * Eduard Bloch <blade@debian.org>
+   * Ah Hong <hongster@users.sourceforge.net>
+   * Eowyn Carter
+   */
+  { "SonyEricsson", 0x0fce,  "c1605 Xperia Dual E MTP", 0x0146,
+      DEVICE_FLAG_NONE },
+  { "SonyEricsson", 0x0fce, "LT15i Xperia arc S MTP", 0x014f,
+      DEVICE_FLAG_NONE },
+  { "SonyEricsson", 0x0fce, "MT11i Xperia Neo MTP", 0x0156,
+      DEVICE_FLAG_NONE },
+  { "SonyEricsson", 0x0fce, "IS12S Xperia Acro MTP", 0x0157,
+      DEVICE_FLAG_NONE },
+  { "SonyEricsson", 0x0fce, "MK16i Xperia MTP", 0x015a,
+      DEVICE_FLAG_NONE },
+  { "SonyEricsson", 0x0fce, "R800/R88i Xperia Play MTP", 0x015d,
+      DEVICE_FLAG_NONE },
+  { "SonyEricsson", 0x0fce, "ST18a Xperia Ray MTP", 0x0161,
+      DEVICE_FLAG_NONE },
+  { "SonyEricsson", 0x0fce, "SK17i Xperia Mini Pro MTP", 0x0166,
+      DEVICE_FLAG_NONE },
+  { "SonyEricsson", 0x0fce, "ST15i Xperia Mini MTP", 0x0167,
+      DEVICE_FLAG_NONE },
+  { "SonyEricsson", 0x0fce, "ST17i Xperia Active MTP", 0x0168,
+      DEVICE_FLAG_NONE },
+  { "SONY", 0x0fce, "LT26i Xperia S MTP", 0x0169,
+      DEVICE_FLAG_NO_ZERO_READS },
+  { "SONY", 0x0fce, "WT19i Live Walkman MTP", 0x016d,
+      DEVICE_FLAG_NONE },
+  { "SONY", 0x0fce, "ST21i Xperia Tipo MTP", 0x0170,
+      DEVICE_FLAG_NONE },
+  { "SONY", 0x0fce, "ST15i Xperia U MTP", 0x0171,
+      DEVICE_FLAG_NONE },
+  { "SONY", 0x0fce, "LT22i Xperia P MTP", 0x0172,
+      DEVICE_FLAG_NONE },
+  { "SONY", 0x0fce, "MT27i Xperia Sola MTP", 0x0173,
+      DEVICE_FLAG_NONE },
+  { "SONY", 0x0fce, "LT26w Xperia Acro HD IS12S MTP", 0x0175,
+      DEVICE_FLAG_NONE },
+  { "SONY", 0x0fce, "LT26w Xperia Acro HD SO-03D MTP", 0x0176,
+      DEVICE_FLAG_NONE },
+  { "SONY", 0x0fce, "LT28at Xperia Ion MTP", 0x0177,
+      DEVICE_FLAG_NONE },
+  { "SONY", 0x0fce, "LT29i Xperia GX MTP", 0x0178,
+      DEVICE_FLAG_NONE },
+  { "SONY", 0x0fce, "ST27i/ST27a Xperia go MTP", 0x017e,
+      DEVICE_FLAG_NONE },
+  { "SONY", 0x0fce, "ST23i Xperia Miro MTP", 0x0180,
+      DEVICE_FLAG_NONE },
+  { "SONY", 0x0fce, "SO-05D Xperia SX MTP", 0x0181,
+      DEVICE_FLAG_NONE },
+  { "SONY", 0x0fce, "LT30p Xperia T MTP", 0x0182,
+      DEVICE_FLAG_NONE },
+  { "SONY", 0x0fce, "LT25i Xperia V MTP", 0x0186,
+      DEVICE_FLAG_NONE },
+  { "SONY", 0x0fce, "Xperia J MTP", 0x0188,
+      DEVICE_FLAG_NONE },
+  { "SONY", 0x0fce, "Xperia ZL MTP", 0x0189,
+      DEVICE_FLAG_NONE },
+  { "SONY", 0x0fce, "Xperia E MTP", 0x018c,
+      DEVICE_FLAG_NONE },
+  { "SONY", 0x0fce, "Xperia Tablet Z MTP 1", 0x018d,
+      DEVICE_FLAG_NONE },
+  { "SONY", 0x0fce, "Xperia L MTP", 0x0192,
+      DEVICE_FLAG_NONE },
+  { "SONY", 0x0fce, "Xperia Z MTP", 0x0193,
+      DEVICE_FLAG_NONE },
+  { "SONY", 0x0fce, "Xperia Tablet Z MTP 2", 0x0194,
+      DEVICE_FLAG_NONE },
+  { "SONY", 0x0fce, "Xperia SP MTP", 0x0195,
+      DEVICE_FLAG_NONE },
+  { "SONY", 0x0fce, "Xperia Z Ultra MTP (ID2)", 0x0196,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "SONY", 0x0fce, "Xperia ZR MTP", 0x0197,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "SONY", 0x0fce, "Xperia A MTP", 0x0198,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "SONY", 0x0fce, "Xperia M MTP", 0x019b,
+      DEVICE_FLAG_NONE },
+  { "SONY", 0x0fce, "Xperia Z Ultra MTP (ID3)", 0x019c,
+      DEVICE_FLAG_NONE },
+  { "SONY", 0x0fce, "Xperia Z1 MTP", 0x019e,
+      DEVICE_FLAG_NONE },
+  { "SONY", 0x0fce, "Xperia C MTP", 0x01a3,
+      DEVICE_FLAG_NONE },
+  { "SONY", 0x0fce, "Xperia Z1 Compact D5503", 0x01a7,
+      DEVICE_FLAG_NONE },
+  { "SONY", 0x0fce, "Xperia M2 MTP", 0x01aa,
+      DEVICE_FLAG_NONE },
+  { "SONY", 0x0fce, "Xperia M2 Dual MTP", 0x01ab,
+      DEVICE_FLAG_NONE },
+  { "SONY", 0x0fce, "Xperia Z2 MTP", 0x01af,
+      DEVICE_FLAG_NONE },
+  { "SONY", 0x0fce, "Xperia Z Ultra MTP", 0x01b6,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "SONY", 0x0fce, "Xperia Z3 MTP", 0x01ba,
+      DEVICE_FLAG_NONE },
+  { "SONY", 0x0fce, "Xperia Z3 Compact MTP", 0x01bb,
+      DEVICE_FLAG_NONE },
+  { "SONY", 0x0fce, "Xperia E3 MTP", 0x01bc,
+      DEVICE_FLAG_NONE },
+  { "SONY", 0x0fce, "XPeria E4g MTP", 0x01cb,
+      DEVICE_FLAG_NONE },
+
+
+  /*
+   * MTP+UMS personalities of MTP devices (see above)
+   */
+  { "SonyEricsson", 0x0fce, "IS12S Xperia Acro MTP+CDROM", 0x4157,
+      DEVICE_FLAG_NONE },
+  { "SonyEricsson", 0x0fce, "ST17i Xperia Active MTP+CDROM", 0x4168,
+      DEVICE_FLAG_NONE },
+  { "SONY", 0x0fce, "LT26i Xperia S MTP+CDROM", 0x4169,
+      DEVICE_FLAG_NO_ZERO_READS },
+  { "SONY", 0x0fce, "ST21i Xperia Tipo MTP+CDROM", 0x4170,
+      DEVICE_FLAG_NONE },
+  { "SONY", 0x0fce, "ST25i Xperia U MTP+CDROM", 0x4171,
+      DEVICE_FLAG_NONE },
+  { "SONY", 0x0fce, "LT22i Xperia P MTP+CDROM", 0x4172,
+      DEVICE_FLAG_NONE },
+  { "SONY", 0x0fce, "MT27i Xperia Sola MTP+CDROM", 0x4173,
+      DEVICE_FLAG_NONE },
+  { "SONY", 0x0fce, "LT26w Xperia Acro HD IS12S MTP+CDROM", 0x4175,
+      DEVICE_FLAG_NONE },
+  { "SONY", 0x0fce, "LT26w Xperia Acro HD SO-03D MTP+CDROM", 0x4176,
+      DEVICE_FLAG_NONE },
+  { "SONY", 0x0fce, "LT28at Xperia Ion MTP+CDROM", 0x4177,
+      DEVICE_FLAG_NONE },
+  { "SONY", 0x0fce, "LT29i Xperia GX MTP+CDROM", 0x4178,
+      DEVICE_FLAG_NONE },
+  { "SONY", 0x0fce, "ST27i/ST27a Xperia go MTP+CDROM", 0x417e,
+      DEVICE_FLAG_NONE },
+  { "SONY", 0x0fce, "ST23i Xperia Miro MTP+CDROM", 0x4180,
+      DEVICE_FLAG_NONE },
+  { "SONY", 0x0fce, "SO-05D Xperia SX MTP+CDROM", 0x4181,
+      DEVICE_FLAG_NONE },
+  { "SONY", 0x0fce, "LT30p Xperia T MTP+CDROM", 0x4182,
+      DEVICE_FLAG_NONE },
+  { "SONY", 0x0fce, "LT25i Xperia V MTP+CDROM", 0x4186,
+      DEVICE_FLAG_NONE },
+  { "SONY", 0x0fce, "Xperia J MTP+CDROM", 0x4188,
+      DEVICE_FLAG_NONE },
+  { "SONY", 0x0fce, "Xperia ZL MTP+CDROM", 0x4189,
+      DEVICE_FLAG_NONE },
+  { "SONY", 0x0fce, "Xperia E MTP+CDROM", 0x418c,
+      DEVICE_FLAG_NONE },
+  { "SONY", 0x0fce, "Xperia Tablet Z MTP+CDROM 1", 0x418d,
+      DEVICE_FLAG_NONE },
+  { "SONY", 0x0fce, "Xperia L MTP+CDROM", 0x4192,
+      DEVICE_FLAG_NONE },
+  { "SONY", 0x0fce, "Xperia Z MTP+CDROM", 0x4193,
+      DEVICE_FLAG_NONE },
+  { "SONY", 0x0fce, "Xperia Tablet Z MTP+CDROM 2", 0x4194,
+      DEVICE_FLAG_NONE },
+  { "SONY", 0x0fce, "Xperia SP MTP+CDROM", 0x4195,
+      DEVICE_FLAG_NONE },
+  { "SONY", 0x0fce, "Xperia M MTP+CDROM", 0x419b,
+      DEVICE_FLAG_NONE },
+  { "SONY", 0x0fce, "Xperia Z Ultra MTP+CDROM (ID3)", 0x419c,
+      DEVICE_FLAG_NONE },
+  { "SONY", 0x0fce, "Xperia Z1 MTP+CDROM", 0x419e,
+      DEVICE_FLAG_NONE },
+  { "SONY", 0x0fce, "Xperia C MTP+CDROM", 0x41a3,
+      DEVICE_FLAG_NONE },
+  { "SONY", 0x0fce, "Xperia Z1 Compact D5503 MTP+CDROM", 0x41a7,
+      DEVICE_FLAG_NONE },
+  { "SONY", 0x0fce, "Xperia M2 MTP+CDROM", 0x41aa,
+      DEVICE_FLAG_NONE },
+  { "SONY", 0x0fce, "Xperia M2 Dual MTP+CDROM", 0x41ab,
+      DEVICE_FLAG_NONE },
+  { "SONY", 0x0fce, "Xperia Z2 MTP+CDROM", 0x41af,
+      DEVICE_FLAG_NONE },
+  { "SONY", 0x0fce, "Xperia Z3 MTP+CDROM", 0x41ba,
+      DEVICE_FLAG_NONE },
+  { "SONY", 0x0fce, "Xperia Z3 Compact MTP+CDROM", 0x41bb,
+      DEVICE_FLAG_NONE },
+  { "SONY", 0x0fce, "Xperia E3 MTP+CDROM", 0x01bc,
+      DEVICE_FLAG_NONE },
+  { "SONY", 0x0fce, "XPeria E4g MTP+CDROM", 0x41cb,
+      DEVICE_FLAG_NONE },
+
+  /*
+   * MTP+ADB personalities of MTP devices (see above)
+   */
+  { "SonyEricsson", 0x0fce,  "c1605 Xperia Dual E MTP+ADB", 0x5146,
+      DEVICE_FLAG_NONE },
+  { "SonyEricsson", 0x0fce, "LT15i Xperia Arc MTP+ADB", 0x514f,
+      DEVICE_FLAG_NONE },
+  { "SonyEricsson", 0x0fce, "MT11i Xperia Neo MTP+ADB", 0x5156,
+      DEVICE_FLAG_NONE },
+  { "SonyEricsson", 0x0fce, "IS12S Xperia Acro MTP+ADB", 0x5157,
+      DEVICE_FLAG_NONE },
+  { "SonyEricsson", 0x0fce, "MK16i Xperia MTP+ADB", 0x515a,
+      DEVICE_FLAG_NONE },
+  { "SonyEricsson", 0x0fce, "R800/R88i Xperia Play MTP+ADB", 0x515d,
+      DEVICE_FLAG_NONE },
+  { "SonyEricsson", 0x0fce, "ST18i Xperia Ray MTP+ADB", 0x5161,
+      DEVICE_FLAG_NONE },
+  { "SonyEricsson", 0x0fce, "SK17i Xperia Mini Pro MTP+ADB", 0x5166,
+      DEVICE_FLAG_NONE },
+  { "SonyEricsson", 0x0fce, "ST15i Xperia Mini MTP+ADB", 0x5167,
+      DEVICE_FLAG_NONE },
+  { "SonyEricsson", 0x0fce, "ST17i Xperia Active MTP+ADB", 0x5168,
+      DEVICE_FLAG_NONE },
+  { "SONY", 0x0fce, "LT26i Xperia S MTP+ADB", 0x5169,
+      DEVICE_FLAG_NO_ZERO_READS },
+  { "SonyEricsson", 0x0fce, "WT19i Live Walkman MTP+ADB", 0x516d,
+      DEVICE_FLAG_NONE },
+  { "SONY", 0x0fce, "ST21i Xperia Tipo MTP+ADB", 0x5170,
+      DEVICE_FLAG_NONE },
+  { "SONY", 0x0fce, "ST25i Xperia U MTP+ADB", 0x5171,
+      DEVICE_FLAG_NONE },
+  { "SONY", 0x0fce, "LT22i Xperia P MTP+ADB", 0x5172,
+      DEVICE_FLAG_NONE },
+  { "SONY", 0x0fce, "MT27i Xperia Sola MTP+ADB", 0x5173,
+      DEVICE_FLAG_NONE },
+  { "SONY", 0x0fce, "IS12S Xperia Acro HD MTP+ADB", 0x5175,
+      DEVICE_FLAG_NONE },
+  { "SONY", 0x0fce, "SO-03D Xperia Acro HD MTP+ADB", 0x5176,
+      DEVICE_FLAG_NONE },
+  { "SONY", 0x0fce, "LT28at Xperia Ion MTP+ADB", 0x5177,
+      DEVICE_FLAG_NONE },
+  { "SONY", 0x0fce, "LT29i Xperia GX MTP+ADB", 0x5178,
+      DEVICE_FLAG_NONE },
+  { "SONY", 0x0fce, "ST27i/ST27a Xperia go MTP+ADB", 0x517e,
+      DEVICE_FLAG_NONE },
+  { "SONY", 0x0fce, "ST23i Xperia Miro MTP+ADB", 0x5180,
+      DEVICE_FLAG_NONE },
+  { "SONY", 0x0fce, "SO-05D Xperia SX MTP+ADB", 0x5181,
+      DEVICE_FLAG_NONE },
+  { "SONY", 0x0fce, "LT30p Xperia T MTP+ADB", 0x5182,
+      DEVICE_FLAG_NONE },
+  { "SONY", 0x0fce, "LT25i Xperia V MTP+ADB", 0x5186,
+      DEVICE_FLAG_NONE },
+  { "SONY", 0x0fce, "Xperia J MTP+ADB", 0x5188,
+      DEVICE_FLAG_NONE },
+  { "SONY", 0x0fce, "Xperia ZL MTP+ADB", 0x5189,
+      DEVICE_FLAG_NONE },
+  { "SONY", 0x0fce, "Xperia E MTP+ADB", 0x518c,
+      DEVICE_FLAG_NONE },
+  { "SONY", 0x0fce, "Xperia Tablet Z MTP+ADB 1", 0x518d,
+      DEVICE_FLAG_NONE },
+  { "SONY", 0x0fce, "Xperia L MTP+ADB", 0x5192,
+      DEVICE_FLAG_NONE },
+  { "SONY", 0x0fce, "Xperia Z MTP+ADB", 0x5193,
+      DEVICE_FLAG_NONE },
+  { "SONY", 0x0fce, "Xperia Tablet Z MTP+ADB 2", 0x5194,
+      DEVICE_FLAG_NONE },
+  { "SONY", 0x0fce, "Xperia SP MTP+ADB", 0x5195,
+      DEVICE_FLAG_NONE },
+  { "SONY", 0x0fce, "Xperia Z Ultra MTP+ADB (ID2)", 0x5196,
+      DEVICE_FLAG_NONE },
+  { "SONY", 0x0fce, "Xperia ZR MTP+ADB", 0x5197,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "SONY", 0x0fce, "Xperia A MTP+ADB", 0x5198,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "SONY", 0x0fce, "Xperia M MTP+ADB", 0x519b,
+      DEVICE_FLAG_NONE },
+  { "SONY", 0x0fce, "Xperia Z Ultra MTP+ADB (ID3)", 0x519c,
+      DEVICE_FLAG_NONE },
+  { "SONY", 0x0fce, "Xperia Z1 MTP+ADB", 0x519e,
+      DEVICE_FLAG_NONE },
+  { "SONY", 0x0fce, "Xperia C MTP+ADB", 0x51a3,
+      DEVICE_FLAG_NONE },
+  { "SONY", 0x0fce, "Xperia Z1 Compact MTP+ADB", 0x51a7,
+      DEVICE_FLAG_NONE },
+  { "SONY", 0x0fce, "Xperia M2 MTP+ADB", 0x51aa,
+      DEVICE_FLAG_NONE },
+  { "SONY", 0x0fce, "Xperia M2 Dual MTP+ADB", 0x51ab,
+      DEVICE_FLAG_NONE },
+  { "SONY", 0x0fce, "Xperia Z2 MTP+ADB", 0x51af,
+      DEVICE_FLAG_NONE },
+  { "SONY", 0x0fce, "Xperia Z Ultra MTP+ADB", 0x51b6,
+      DEVICE_FLAG_NONE },
+  { "SONY", 0x0fce, "Xperia Z3 MTP+ADB", 0x51ba,
+      DEVICE_FLAG_NONE },
+  { "SONY", 0x0fce, "Xperia Z3 Compact MTP+ADB", 0x51bb,
+      DEVICE_FLAG_NONE },
+  { "SONY", 0x0fce, "Xperia E3 MTP+ADB", 0x51bc,
+      DEVICE_FLAG_NONE },
+  { "SONY", 0x0fce,  "XPeria E4g MTP+ADB", 0x51cb,
+      DEVICE_FLAG_NONE },
+
+  /*
+   * MTP+UMS modes
+   * This mode is for using MTP on the internal storage (eMMC)
+   * and using UMS (Mass Storage Device Class) on the external
+   * SD card
+   */
+  { "SONY", 0x0fce, "MT27i Xperia Sola MTP+UMS", 0xa173,
+      DEVICE_FLAG_NONE },
+  { "SONY", 0x0fce, "IS12S Xperia Acro HD MTP+UMS", 0xa175,
+      DEVICE_FLAG_NONE },
+  { "SONY", 0x0fce, "SO-03D Xperia Acro HD MTP+UMS", 0xa176,
+      DEVICE_FLAG_NONE },
+  { "SONY", 0x0fce, "LT28at Xperia Ion MTP+UMS", 0xa177,
+      DEVICE_FLAG_NONE },
+  { "SONY", 0x0fce, "ST27i/ST27a Xperia go MTP+UMS", 0xa17e,
+      DEVICE_FLAG_NONE },
+
+  /*
+   * MTP+UMS+ADB modes
+   * Like the above, but also ADB
+   */
+  { "SONY", 0x0fce, "MT27i Xperia Sola MTP+UMS+ADB", 0xb173,
+      DEVICE_FLAG_NONE },
+  { "SONY", 0x0fce, "IS12S Xperia Acro MTP+UMS+ADB", 0xb175,
+      DEVICE_FLAG_NONE },
+  { "SONY", 0x0fce, "SO-03D Xperia Acro MTP+UMS+ADB", 0xb176,
+      DEVICE_FLAG_NONE },
+  { "SONY", 0x0fce, "LT28at Xperia Ion MTP+UMS+ADB", 0xb177,
+      DEVICE_FLAG_NONE },
+  { "SONY", 0x0fce, "ST27i/ST27a Xperia go MTP+UMS+ADB", 0xb17e,
+      DEVICE_FLAG_NONE },
+
+
+  /*
+   * Motorola
+   * Assume DEVICE_FLAG_BROKEN_SET_OBJECT_PROPLIST on all of these.
+   */
+  // Reported by David Boyd <tiggrdave@users.sourceforge.net>
+  { "Motorola", 0x22b8, "V3m/V750 verizon", 0x2a65,
+      DEVICE_FLAG_BROKEN_SET_OBJECT_PROPLIST |
+      DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST_ALL },
+  { "Motorola", 0x22b8, "Atrix/Razr HD (MTP)", 0x2e32,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "Motorola", 0x22b8, "Atrix/Razr HD (MTP+ADB)", 0x2e33,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "Motorola", 0x22b8, "RAZR M XT907 (MTP)", 0x2e50,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "Motorola", 0x22b8, "RAZR M XT907 (MTP+ADB)", 0x2e51,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "Motorola", 0x22b8, "Moto X (XT1053)", 0x2e62,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "Motorola", 0x22b8, "Moto X (XT1058)", 0x2e63,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  /* https://sourceforge.net/p/libmtp/bugs/1323/ */
+  { "Motorola", 0x22b8, "Moto X (XT1080)", 0x2e66,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "Motorola", 0x22b8, "Droid Maxx (XT1080)", 0x2e67,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "Motorola", 0x22b8, "Droid Ultra", 0x2e68,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "Motorola", 0x22b8, "Moto G (ID1)", 0x2e76,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "Motorola", 0x22b8, "Moto G (ID2)", 0x2e82,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  /* https://sourceforge.net/p/libmtp/bugs/1030/, PTP Id */
+  { "Motorola", 0x22b8, "Moto G (XT1032)", 0x2e84,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  // Reported by Jader Rodrigues Simoes <jadersimoes@users.sourceforge.net>
+  { "Motorola", 0x22b8, "Xoom 2 Media Edition (ID3)", 0x41cf,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  // Reported by Steven Roemen <sdroemen@users.sourceforge.net>
+  { "Motorola", 0x22b8, "Droid X/MB525 (Defy)", 0x41d6,
+      DEVICE_FLAG_NONE },
+  { "Motorola", 0x22b8, "DROID2 (ID1)", 0x41da,
+      DEVICE_FLAG_NONE },
+  { "Motorola", 0x22b8, "Milestone / Verizon Droid", 0x41dc,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "Motorola", 0x22b8, "DROID2 (ID2)", 0x42a7,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "Motorola", 0x22b8, "Xoom 2 Media Edition (ID2)", 0x4306,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "Motorola", 0x22b8, "Xoom 2 Media Edition", 0x4311,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  // Reported by  B,H,Kissinger <mrkissinger@users.sourceforge.net>
+  { "Motorola", 0x22b8, "XT912/XT928", 0x4362,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  /* https://sourceforge.net/p/libmtp/bugs/1104/ , PTP id. */
+  { "Motorola", 0x22b8, "DROID4 (PTP)", 0x4373,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  // Reported by Lundgren <alundgren@users.sourceforge.net>
+  { "Motorola", 0x22b8, "DROID4", 0x437f,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  // Reported by Marcus Meissner to libptp2
+  { "Motorola", 0x22b8, "IdeaPad K1", 0x4811,
+      DEVICE_FLAG_BROKEN_SET_OBJECT_PROPLIST },
+  // Reported by Hans-Joachim Baader <hjb@pro-linux.de> to libptp2
+  { "Motorola", 0x22b8, "A1200", 0x60ca,
+      DEVICE_FLAG_BROKEN_SET_OBJECT_PROPLIST },
+  // http://mark.cdmaforums.com/Files/Motdmmtp.inf
+  { "Motorola", 0x22b8, "MTP Test Command Interface", 0x6413,
+      DEVICE_FLAG_BROKEN_SET_OBJECT_PROPLIST },
+  // Reported by anonymous user
+  { "Motorola", 0x22b8, "RAZR2 V8/U9/Z6", 0x6415,
+      DEVICE_FLAG_BROKEN_SET_OBJECT_PROPLIST },
+  // Reported by Rodrigo Angelo Rafael
+  // Razr D1, D3
+  { "Motorola", 0x22b8, "Razr D1/D3/i (MTP)", 0x64b5,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "Motorola", 0x22b8, "Razr D1/D3/i (MTP+?)", 0x64b6,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  /* https://sourceforge.net/p/libmtp/bugs/697/ */
+  { "Motorola", 0x22b8, "Atrix XT687 (MTP)", 0x64cf,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  // Reported by Brian Dolbec <dol-sen@users.sourceforge.net>
+  { "Motorola", 0x22b8, "Atrix MB860 (MTP)", 0x7088,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  /*
+   * Motorola Xoom (Wingray) variants
+   *
+   * These devices seem to use these product IDs simulatenously
+   * https://code.google.com/p/android-source-browsing/source/browse/init.stingray.usb.rc?repo=device--moto--wingray
+   *
+   * 0x70a3 - Factory test - reported as early MTP ID
+   * 0x70a8 - MTP
+   * 0x70a9 - MTP+ADB
+   * 0x70ae - RNDIS
+   * 0x70af - RNDIS+ADB
+   * 0x70b0 - ACM
+   * 0x70b1 - ACM+ADB
+   * 0x70b2 - ACM+RNDIS
+   * 0x70b3 - ACM+RNDIS+ADB
+   * 0x70b4 - PTP
+   * 0x70b5 - PTP+ADB
+   *
+   * Reported by Google Inc's Yavor Goulishev <yavor@google.com>
+   */
+  { "Motorola", 0x22b8, "Xoom (Factory test)", 0x70a3,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "Motorola", 0x22b8, "Xoom (MTP)", 0x70a8,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "Motorola", 0x22b8, "Xoom (MTP+ADB)", 0x70a9,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  // "carried by C Spire and other CDMA US carriers"
+  { "Motorola", 0x22b8, "Milestone X2", 0x70ca,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "Motorola", 0x22b8, "XT890/907/Razr (MTP)", 0x710d,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "Motorola", 0x22b8, "XT890/907/Razr (MTP+ADB)", 0x710e,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  /* https://sourceforge.net/p/libmtp/bugs/1183/ */
+  { "Motorola", 0x22b8, "Droid Turbo (XT1254)", 0x2ea5,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "Motorola", 0x22b8, "Droid Turbo Verizon", 0x2ea8,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  /*
+   * XT890/907/Razr
+   * 710f is USB mass storage
+   */
+
+  /*
+   * Google
+   * These guys lend their Vendor ID to anyone who comes down the
+   * road to produce an Android tablet it seems... The Vendor ID
+   * was originally used for Nexus phones
+   */
+  { "Google Inc (for Allwinner)", 0x18d1, "A31 SoC", 0x0006,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "Google Inc (for Ainol Novo)", 0x18d1, "Fire/Flame", 0x0007,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "Google Inc (for Sony)", 0x18d1, "S1", 0x05b3,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  // Reported by anonymous Sourceforge user
+  { "Google Inc (for Barnes & Noble)", 0x18d1, "Nook Color", 0x2d02,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  // Reported by anonymous Sourceforge user
+  { "Google Inc (for Asus)", 0x18d1, "TF201 Transformer", 0x4d00,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  // Reported by anonymous Sourceforge user
+  { "Google Inc (for Asus)", 0x18d1, "TF101 Transformer", 0x4e0f,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  // 0x4e21 (Nexus S) is a USB Mass Storage device.
+  { "Google Inc (for Samsung)", 0x18d1, "Nexus S (MTP)", 0x4e25,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  // 0x4e26 is also used by "Ramos W30HD Pro Quad Core"
+  { "Google Inc (for Samsung)", 0x18d1, "Nexus S (MTP+ADB)", 0x4e26,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  // Reported by Chris Smith <tcgsmythe@users.sourceforge.net>
+  { "Google Inc (for Asus)", 0x18d1, "Nexus 7 (MTP)", 0x4e41,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  // Reported by Michael Hess <mhess126@gmail.com>
+  { "Google Inc (for Asus)", 0x18d1, "Nexus 7 (MTP+ADB)", 0x4e42,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "Google Inc (for LG Electronics/Samsung)", 0x18d1,
+      "Nexus 4/5/7/10 (MTP)", 0x4ee1,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "Google Inc (for LG Electronics/Samsung)", 0x18d1,
+      "Nexus 4/5/7/10 (MTP+ADB)", 0x4ee2,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  /* https://sourceforge.net/p/libmtp/bugs/1255/ */
+  { "Google", 0x18d1, "Nexus 5 (MTP)", 0x4ee5,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  // WiFi-only version of Xoom
+  // See: http://bugzilla.gnome.org/show_bug.cgi?id=647506
+  { "Google Inc (for Motorola)", 0x18d1, "Xoom (MZ604)", 0x70a8,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "Google Inc (for Toshiba)", 0x18d1, "Thrive 7/AT105", 0x7102,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "Google Inc (for Lenovo)", 0x18d1, "Ideapad K1", 0x740a,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  // Another OEM for Medion
+  { "Google Inc (for Medion)", 0x18d1, "MD99000 (P9514)", 0xb00a,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  // Reported by Frederik Himpe <fhimpe@telenet.be>
+  { "Google Inc (for LG Electronics)", 0x18d1, "P990/Optimus (Cyanogen)",
+      0xd109, DEVICE_FLAGS_ANDROID_BUGS },
+  { "Google Inc (for LG Electronics)", 0x18d1, "P990/Optimus", 0xd10a,
+      DEVICE_FLAGS_ANDROID_BUGS },
+
+
+  /*
+   * Media Keg
+   */
+  // Reported by Rajan Bella <rajanbella@yahoo.com>
+  { "Kenwood", 0x0b28, "Media Keg HD10GB7 Sport Player", 0x100c, DEVICE_FLAG_UNLOAD_DRIVER},
+
+  /*
+   * Micro-Star International (MSI)
+   */
+  // Reported by anonymous sourceforge user.
+  { "Micro-Star International", 0x0db0, "P610/Model MS-5557", 0x5572, DEVICE_FLAG_NONE },
+
+  /*
+   * FOMA
+   */
+  { "FOMA", 0x06d3, "D905i", 0x21ba, DEVICE_FLAG_NONE },
+
+  /*
+   * Haier
+   */
+  // Both reported by an anonymous SourceForge user
+  // This is the 30 GiB model
+  { "Haier", 0x1302, "Ibiza Rhapsody 1", 0x1016, DEVICE_FLAG_NONE },
+  // This is the 4/8 GiB model
+  { "Haier", 0x1302, "Ibiza Rhapsody 2", 0x1017, DEVICE_FLAG_NONE },
+
+  /*
+   * Panasonic
+   */
+  // Reported by dmizer
+  { "Panasonic", 0x04da, "P905i", 0x2145, DEVICE_FLAG_NONE },
+  // Reported by Taku
+  { "Panasonic", 0x04da, "P906i", 0x2158, DEVICE_FLAG_NONE },
+
+  /*
+   * Polaroid
+   */
+  { "Polaroid", 0x0546, "Freescape/MPU-433158", 0x2035, DEVICE_FLAG_NONE },
+
+  /*
+   * Pioneer
+   */
+  // Reported by Dan Allen <dan.j.allen@gmail.com>
+  { "Pioneer", 0x08e4, "XMP3", 0x0148, DEVICE_FLAG_NONE },
+
+  /*
+   * Slacker Inc.
+   * Put in all evilness flags because it looks fragile.
+   */
+  // Reported by Pug Fantus <pugfantus@users.sourceforge.net>
+  { "Slacker Inc.", 0x1bdc, "Slacker Portable Media Player", 0xfabf,
+    DEVICE_FLAG_BROKEN_BATTERY_LEVEL | DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST |
+    DEVICE_FLAG_BROKEN_SET_OBJECT_PROPLIST | DEVICE_FLAG_BROKEN_SEND_OBJECT_PROPLIST },
+
+  // Reported by anonymous user
+  { "Conceptronic", 0x1e53, "CMTD2", 0x0005, DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST },
+  // Reported by Demadridsur <demadridsur@gmail.com>
+  { "O2 Sistemas", 0x1e53, "ZoltarTV", 0x0006, DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST },
+  // Reported by da-beat <dabeat@gmail.com>
+  { "Wyplay", 0x1e53, "Wyplayer", 0x0007, DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST },
+
+  // Reported by Sense Hofstede <qense@users.sourceforge.net>
+  { "Perception Digital, Ltd", 0x0aa6, "Gigaware GX400", 0x9702, DEVICE_FLAG_NONE },
+
+  /*
+   * RIM's BlackBerry
+   */
+  // Reported by Nicolas VIVIEN <nicolas@vivien.fr>
+  { "RIM", 0x0fca, "BlackBerry Storm/9650", 0x8007, DEVICE_FLAG_UNLOAD_DRIVER |
+      DEVICE_FLAG_SWITCH_MODE_BLACKBERRY | DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST_ALL },
+
+  /*
+   * Nextar
+   */
+  { "Nextar", 0x0402, "MA715A-8R", 0x5668, DEVICE_FLAG_NONE },
+
+  /*
+   * Coby
+   */
+  { "Coby", 0x1e74, "COBY MP705", 0x6512, DEVICE_FLAG_NONE },
+
+#if 0
+  /*
+   * Apple devices, which are not MTP natively but can be made to speak MTP
+   * using PwnTunes (http://www.pwntunes.net/)
+   * CURRENTLY COMMENTED OUT:
+   * These will make the UDEV rules flag these as MTP devices even if
+   * PwnTunes is NOT installed. That is unacceptable, so a better solution
+   * that actually inspects if the device has PwnTunes/MTP support needs
+   * to be found, see:
+   * https://sourceforge.net/p/libmtp/bugs/759/
+   */
+  { "Apple", 0x05ac, "iPhone", 0x1290, DEVICE_FLAG_NONE },
+  { "Apple", 0x05ac, "iPod Touch 1st Gen", 0x1291, DEVICE_FLAG_NONE },
+  { "Apple", 0x05ac, "iPhone 3G", 0x1292, DEVICE_FLAG_NONE },
+  { "Apple", 0x05ac, "iPod Touch 2nd Gen", 0x1293, DEVICE_FLAG_NONE },
+  { "Apple", 0x05ac, "iPhone 3GS", 0x1294, DEVICE_FLAG_NONE },
+  { "Apple", 0x05ac, "0x1296", 0x1296, DEVICE_FLAG_NONE },
+  { "Apple", 0x05ac, "0x1297", 0x1297, DEVICE_FLAG_NONE },
+  { "Apple", 0x05ac, "0x1298", 0x1298, DEVICE_FLAG_NONE },
+  { "Apple", 0x05ac, "iPod Touch 3rd Gen", 0x1299, DEVICE_FLAG_NONE },
+  { "Apple", 0x05ac, "iPad", 0x129a, DEVICE_FLAG_NONE },
+#endif
+
+  // Reported by anonymous SourceForge user, also reported as
+  // Pantech Crux, claming to be:
+  // Manufacturer: Qualcomm
+  // Model: Windows Simulator
+  // Device version: Qualcomm MTP1.0
+  { "Curitel Communications, Inc.", 0x106c,
+      "Verizon Wireless Device", 0x3215, DEVICE_FLAG_NONE },
+  // Reported by: Jim Hanrahan <goshawkjim@users.sourceforge.net>
+  { "Pantech", 0x106c, "Crux", 0xf003, DEVICE_FLAG_NONE },
+
+  /*
+   * Asus
+   * Pattern of PIDs on Android devices seem to be:
+   * n+0 = MTP
+   * n+1 = MTP+ADB
+   * n+2 = ?
+   * n+3 = ?
+   * n+4 = PTP
+   */
+  // Reported by Glen Overby
+  { "Asus", 0x0b05, "TF300 Transformer (MTP)", 0x4c80,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  // Reported by jaile <jaile@users.sourceforge.net>
+  { "Asus", 0x0b05, "TF300 Transformer (MTP+ADB)", 0x4c81,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  // Repored by Florian Apolloner <f-apolloner@users.sourceforge.net>
+  { "Asus", 0x0b05, "TF700 Transformer (MTP)", 0x4c90,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "Asus", 0x0b05, "TF700 Transformer (MTP+ADB)", 0x4c91,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "Asus", 0x0b05, "TF701T Transformer Pad (MTP)", 0x4ca0,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "Asus", 0x0b05, "TF701T Transformer Pad (MTP+ADB)", 0x4ca1,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  /* https://sourceforge.net/p/libmtp/support-requests/135/ */
+  { "Asus", 0x0b05, "ME302KL MeMo Pad FHD10 (MTP)", 0x4cc0,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "Asus", 0x0b05, "ME302KL MeMo Pad FHD10 (MTP+ADB)", 0x4cc1,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "Asus", 0x0b05, "ME301T MeMo Pad Smart 10 (MTP)", 0x4cd0,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "Asus", 0x0b05, "ME301T MeMo Pad Smart 10 (MTP+ADB)", 0x4cd1,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "Asus", 0x0b05, "Asus Fonepad Note 6 (MTP)", 0x4ce0,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "Asus", 0x0b05, "Asus Fonepad Note 6 (MTP+ADB)", 0x4ce1,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "Asus", 0x0b05, "TF201 Transformer Prime (keyboard dock)", 0x4d00,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "Asus", 0x0b05, "TF201 Transformer Prime (tablet only)", 0x4d01,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  // 4d04 is the PTP mode, don't add it
+  { "Asus", 0x0b05, "SL101 (MTP)", 0x4e00,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "Asus", 0x0b05, "SL101 (MTP+ADB)", 0x4e01,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "Asus", 0x0b05, "TF101 Eeepad Transformer (MTP)", 0x4e0f,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "Asus", 0x0b05, "TF101 Eeepad Transformer (MTP+ADB)", 0x4e1f,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "Asus", 0x0b05, "Fonepad", 0x514f,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "Asus", 0x0b05, "PadFone (MTP)", 0x5200,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "Asus", 0x0b05, "PadFone (MTP+ADB)", 0x5201,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "Asus", 0x0b05, "ME302C MemoPad (MTP+?)", 0x520f,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "Asus", 0x0b05, "PadFone 2 (MTP)", 0x5210,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "Asus", 0x0b05, "PadFone 2 (MTP+ADB)", 0x5211,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "Asus", 0x0b05, "PadFone 2 (PTP)", 0x5214,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "Asus", 0x0b05, "ME302C MemoPad (MTP)", 0x521f,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  /* https://sourceforge.net/p/libmtp/bugs/1066/ */
+  { "Asus", 0x0b05, "PadFone Infinity (2nd ID) (MTP)", 0x5220,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "Asus", 0x0b05, "PadFone Infinity (2nd ID) (MTP+ADB)", 0x5221,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "Asus", 0x0b05, "PadFone Infinity (MTP)", 0x5230,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "Asus", 0x0b05, "PadFone Infinity (MTP+ADB)", 0x5231,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "Asus", 0x0b05, "Memo ME172V (MTP)", 0x5400,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  /* https://sourceforge.net/p/libmtp/bugs/1072/ */
+  { "Asus", 0x0b05, "Fonepad 7 LTE ME372CL (MTP)", 0x540f,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "Asus", 0x0b05, "Memo ME173X (MTP)", 0x5410,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "Asus", 0x0b05, "Memo ME173X (MTP+ADB)", 0x5411,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  /* https://sourceforge.net/p/libmtp/bugs/1072/ */
+  { "Asus", 0x0b05, "Fonepad 7 LTE ME372CL (MTP+ADB)", 0x541f,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "Asus", 0x0b05, "Memo K00F (MTP)", 0x5460,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "Asus", 0x0b05, "Memo Pad 8 (MTP)", 0x5466,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "Asus", 0x0b05, "Memo K00F (MTP+ADB)", 0x5468,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  /* https://sourceforge.net/p/libmtp/support-requests/158/ */
+  { "Asus", 0x0b05, "ZenFone 5 (MTP)", 0x5480,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  /* https://sourceforge.net/p/libmtp/bugs/1279/ */
+  { "Asus", 0x0b05, "ZenFone 5 (MTP+ADB)", 0x5481,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  /* https://sourceforge.net/p/libmtp/bugs/1236/ */
+  { "Asus", 0x0b05, "ZenFone 6 (MTP)", 0x5490,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "Asus", 0x0b05, "ZenFone 6 (MTP+ADB)", 0x5491,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  /* https://sourceforge.net/p/libmtp/bugs/1239/ */
+  { "Asus", 0x0b05, "K010 (MTP)", 0x5500,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  /* https://sourceforge.net/p/libmtp/bugs/1196/ */
+  { "Asus", 0x0b05, "MemoPad 7 (MTP+ADB)", 0x5506,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  /* https://sourceforge.net/p/libmtp/bugs/1069/ */
+  { "Asus", 0x0b05, "K00E (MTP+ADB)", 0x550f,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  /* https://sourceforge.net/p/libmtp/bugs/1244/ */
+  { "Asus", 0x0b05, "MemoPad 8 ME181 CX (MTP)", 0x5561,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  /* https://sourceforge.net/p/libmtp/bugs/1337/ */
+  { "Asus", 0x0b05, "TX201LA (MTP)", 0x561f,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  /* https://sourceforge.net/p/libmtp/bugs/1271/ */
+  { "Asus", 0x0b05, "ZenFone 4 (MTP)", 0x580f,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  /* https://sourceforge.net/p/libmtp/bugs/1179/ */
+  { "Asus", 0x0b05, "ZenFone 4 A400CG (MTP)", 0x581f,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  /* https://sourceforge.net/p/libmtp/bugs/1258/ */
+  { "Asus", 0x0b05, "A450CG (MTP)", 0x5a0f,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  /* https://sourceforge.net/p/libmtp/bugs/1350/ */
+  { "Asus", 0x0b05, "Zenfone 2 ZE550ML (MTP)", 0x5f02,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  /* https://sourceforge.net/p/libmtp/bugs/1232/ */
+  { "Asus", 0x0b05, "MemoPad 7 (ME572CL)", 0x7772,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  /* https://sourceforge.net/p/libmtp/bugs/1351/ */
+  { "Asus", 0x0b05, "Fonepad 7 (FE375CXG)", 0x7773,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  /* https://sourceforge.net/p/libmtp/bugs/1247/ */
+  { "Asus", 0x0b05, "ZenFone 5 A500KL (MTP+ADB)", 0x7781,
+      DEVICE_FLAGS_ANDROID_BUGS },
+
+
+  /*
+   * Lenovo
+   */
+  /* https://sourceforge.net/p/libmtp/support-requests/178/ */
+  { "Lenovo", 0x17ef, "P70-A", 0x0c02,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  // Reported by Richard Körber <shredzone@users.sourceforge.net>
+  { "Lenovo", 0x17ef, "K1", 0x740a,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  // Reported by anonymous sourceforge user
+  // Adding Android default bug flags since it appears to be an Android
+  { "Lenovo", 0x17ef, "ThinkPad Tablet", 0x741c,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  // Medion is using Lenovos manufacturer ID it seems.
+  // Reported by Thomas Goss <thomas.goss@linux.com>
+  { "Medion", 0x17ef, "Lifetab P9516", 0x7483,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  // Reported by: XChesser <XChesser@users.sourceforge.net>
+  { "Lenovo", 0x17ef, "P700", 0x7497,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  /* https://sourceforge.net/p/libmtp/bugs/1185/ */
+  { "Lenovo", 0x17ef, "A820", 0x7498,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  /* https://sourceforge.net/p/libmtp/bugs/1190/ */
+  { "Lenovo", 0x17ef, "P780", 0x74a6,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  // Reported by: anonymous sourceforge user
+  { "Lenovo", 0x17ef, "Lifetab S9512", 0x74cc,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  /* https://sourceforge.net/p/libmtp/support-requests/170/ */
+  { "Lenovo", 0x17ef, "S660", 0x74f8,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  // Reported by Brian J. Murrell
+  { "Lenovo", 0x17ef, "IdeaTab A2109A", 0x7542,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  /* https://sourceforge.net/p/libmtp/support-requests/166/ */
+  { "Lenovo", 0x17ef, "IdeaTab S2210a", 0x757d,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  /* https://sourceforge.net/p/libmtp/bugs/1123/ */
+  { "Lenovo", 0x17ef, "K900 (ID1)", 0x75b5,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  // Reported by rvelev@mail.bg
+  { "Lenovo", 0x17ef, "IdeaPad A3000 (ID1)", 0x75bc,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "Lenovo", 0x17ef, "IdeaPad A3000 (ID2)", 0x75be,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "Lenovo", 0x17ef, "Toga Tablet B6000-F", 0x76f2,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  /* https://sourceforge.net/p/libmtp/bugs/1122/ */
+  { "Lenovo", 0x17ef, "S930", 0x7718,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  /* https://sourceforge.net/p/libmtp/bugs/1250/ */
+  { "Lenovo", 0x17ef, "A5500-F", 0x772b,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "Lenovo", 0x17ef, "LifeTab E733X", 0x775a,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "Lenovo", 0x17ef, "IdeaTab S5000", 0x76e8,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  /* https://sourceforge.net/p/libmtp/bugs/1155/ */
+  { "Lenovo", 0x17ef, "Yoga Tablet 10 B8000-H", 0x76ff,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  /* https://sourceforge.net/p/libmtp/bugs/1291/ */
+  { "Lenovo", 0x17ef, "A3500-F", 0x7737,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  /* https://sourceforge.net/p/libmtp/support-requests/168/ */
+  { "Lenovo", 0x17ef, "Yoga Tablet 2 Pro", 0x77b1,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  /* https://sourceforge.net/p/libmtp/feature-requests/125/ */
+  { "Lenovo", 0x17ef, "Vibe Z2", 0x77ea,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  /* https://sourceforge.net/p/libmtp/bugs/1360/ */
+  { "Lenovo", 0x17ef, "K3 Note", 0x7883,
+      DEVICE_FLAGS_ANDROID_BUGS },
+
+  /*
+   * Huawei
+   * IDs used by Honor U8860,U8815,U9200,P2
+   */
+  { "Huawei", 0x12d1, "MTP device (ID1)", 0x1051,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "Huawei", 0x12d1, "MTP device (ID2)", 0x1052,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  /* https://sourceforge.net/p/libmtp/bugs/1361/ */
+  { "Huawei", 0x12d1, "Ascend P8 ", 0x1082,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "Huawei", 0x12d1, "Mediapad (mode 0)", 0x360f,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  // Reported by Bearsh <bearsh@users.sourceforge.net>
+  { "Huawei", 0x12d1, "Mediapad (mode 1)", 0x361f,
+      DEVICE_FLAGS_ANDROID_BUGS },
+
+  /*
+   * ZTE
+   * Android devices reported by junwang <lovewjlove@users.sourceforge.net>
+   */
+  { "ZTE", 0x19d2, "V55 ID 1", 0x0244, DEVICE_FLAGS_ANDROID_BUGS },
+  { "ZTE", 0x19d2, "V55 ID 2", 0x0245, DEVICE_FLAGS_ANDROID_BUGS },
+  { "ZTE", 0x19d2, "V790/Blade 3", 0x0306, DEVICE_FLAGS_ANDROID_BUGS },
+  { "ZTE", 0x19d2, "V880E", 0x0307, DEVICE_FLAGS_ANDROID_BUGS },
+  /* https://sourceforge.net/p/libmtp/bugs/672/ */
+  { "ZTE", 0x19d2, "Grand X In", 0x0343, DEVICE_FLAGS_ANDROID_BUGS },
+  { "ZTE", 0x19d2, "V985", 0x0383, DEVICE_FLAGS_ANDROID_BUGS },
+  /* https://sourceforge.net/p/libmtp/bugs/1328/ */
+  { "ZTE", 0x19d2, "V5", 0xffce, DEVICE_FLAGS_ANDROID_BUGS },
+
+  /*
+   * HTC (High Tech Computer Corp)
+   * Reporters:
+   * Steven Eastland <grassmonk@users.sourceforge.net>
+   * Kevin Cheng <kache@users.sf.net>
+   */
+  /* reported by Mikkel Oscar Lyderik <mikkeloscar@gmail.com> */
+  { "HTC", 0x0bb4, "HTC Desire 510 (MTP+ADB)", 0x05fd,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  /* https://sourceforge.net/p/libmtp/bugs/1221/ */
+  { "HTC", 0x0bb4, "One M8 Google Play Edition (MTP+ADB)", 0x060b,
+      DEVICE_FLAG_NONE },
+  /* https://sourceforge.net/p/libmtp/support-requests/153/ */
+  { "HTC", 0x0bb4, "HTC6515LVW/One Remix", 0x07d8,
+      DEVICE_FLAG_NONE },
+  /* https://sourceforge.net/p/libmtp/support-requests/141/ */
+  { "HTC", 0x0bb4, "HTC One (HTC6500LVW)", 0x07ae,
+      DEVICE_FLAG_NONE },
+  /* https://sourceforge.net/p/libmtp/support-requests/128/ */
+  { "HTC", 0x0bb4, "HTC One M8 (HTC6525LVW)", 0x07ca,
+      DEVICE_FLAG_NONE },
+  /* https://sourceforge.net/p/libmtp/bugs/1161/ */
+  { "HTC", 0x0bb4, "HTC One M8 (Verizon) (HTC6525LVW)", 0x07cb,
+      DEVICE_FLAG_NONE },
+  /* https://sourceforge.net/p/libmtp/bugs/1133/ */
+  { "HTC", 0x0bb4, "HTC One Remix (HTC6515LVW)", 0x07d9,
+      DEVICE_FLAG_NONE },
+  // Reported by Markus Heberling
+  { "HTC", 0x0bb4, "Windows Phone 8X ID1", 0x0ba1,
+      DEVICE_FLAG_NONE },
+  { "HTC", 0x0bb4, "Windows Phone 8X ID2", 0x0ba2,
+      DEVICE_FLAG_NONE },
+
+#if 1
+  /* after some review I commented it back in. There was apparently
+   * only one or two devices misbehaving (having this ID in mass storage mode),
+   * but more seem to use it regulary as MTP devices. Marcus 20150401 */
+  /*
+   * This had to be commented out - the same VID+PID is used also for
+   * other modes than MTP, so we need to let mtp-probe do its job on this
+   * device instead of adding it to the database.
+   * used by various devices, like Fairphone, Elephone P5000, etc
+   * https://sourceforge.net/p/libmtp/bugs/1290/
+   */
+  { "HTC", 0x0bb4, "Android Device ID1 (Zopo, HD2, Bird...)", 0x0c02,
+      DEVICE_FLAGS_ANDROID_BUGS },
+#endif
+  { "HTC", 0x0bb4, "EVO 4G LTE/One V (ID1)", 0x0c93,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "HTC", 0x0bb4, "EVO 4G LTE/One V (ID2)", 0x0ca8,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "HTC", 0x0bb4, "HTC One S (ID1)", 0x0cec,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "HTC", 0x0bb4, "One Mini (ID1)", 0x0dcd,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "HTC", 0x0bb4, "HTC One 802w (ID1)", 0x0dd2,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "HTC", 0x0bb4, "HTC Desire X", 0x0dd5,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "HTC", 0x0bb4, "HTC One (ID1)", 0x0dda,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "HTC", 0x0bb4, "HTC Butterfly X290d", 0x0de4,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "HTC", 0x0bb4, "HTC One (MTP+UMS+ADB)", 0x0dea,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "HTC", 0x0bb4, "HTC Evo 4G LTE (ID1)", 0x0df5,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "HTC", 0x0bb4, "HTC One S (ID2)", 0x0df8,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "HTC", 0x0bb4, "HTC One S (ID3)", 0x0df9,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "HTC", 0x0bb4, "HTC One X (ID1)", 0x0dfa,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "HTC", 0x0bb4, "HTC One X (ID2)", 0x0dfb,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "HTC", 0x0bb4, "HTC One X (ID3)", 0x0dfc,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "HTC", 0x0bb4, "HTC One X (ID4)", 0x0dfd,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "HTC", 0x0bb4, "HTC Butterfly (ID1)", 0x0dfe,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "HTC", 0x0bb4, "Droid DNA (MTP+UMS+ADB)", 0x0dff,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "HTC", 0x0bb4, "HTC Droid Incredible 4G LTE (MTP)", 0x0e31,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "HTC", 0x0bb4, "HTC Droid Incredible 4G LTE (MTP+ADB)", 0x0e32,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "HTC", 0x0bb4, "Droid DNA (MTP+UMS)", 0x0ebd,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  /* https://sourceforge.net/p/libmtp/bugs/1182/ */
+  { "HTC", 0x0bb4, "Desire 310 (MTP)", 0x0ec6,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "HTC", 0x0bb4, "HTC One (MTP+ADB+CDC)", 0x0f5f,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "HTC", 0x0bb4, "HTC One (MTP+CDC)", 0x0f60,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "HTC", 0x0bb4, "HTC One (MTP+ADB)", 0x0f63,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "HTC", 0x0bb4, "HTC One (MTP)", 0x0f64,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "HTC", 0x0bb4, "HTC One (MTP+ADB+?)", 0x0f87,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "HTC", 0x0bb4, "HTC One (ID3)", 0x0f91,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "HTC", 0x0bb4, "HTC One M8 (MTP)", 0x0f25,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "HTC", 0x0bb4, "HTC One M8 (MTP+ADB)", 0x061a,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "HTC", 0x0bb4, "HTC One M8 (MTP+UMS)", 0x0fb5,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "HTC", 0x0bb4, "HTC One M8 (MTP+ADB+UMS)", 0x0fb4,
+      DEVICE_FLAGS_ANDROID_BUGS },
+#if 1
+  /* after some review I commented it back in. There was apparently
+   * only one or two devices misbehaving (having this ID in mass storage mode),
+   * but more seem to use it regulary as MTP devices. Marcus 20150401 */
+  /*
+   * This had to be commented out - the same VID+PID is used also for
+   * other modes than MTP, so we need to let mtp-probe do its job on this
+   * device instead of adding it to the database.
+   *
+   * Apparently also used by a clone called Jiayu G2S
+   * with the MTK6577T chipset
+   * http://www.ejiayu.com/en/Product-19.html
+   * Wiko Cink Peax 2
+   */
+  { "HTC", 0x0bb4, "Android Device ID2 (Zopo, HD2...)", 0x2008,
+      DEVICE_FLAGS_ANDROID_BUGS },
+#endif
+  /* https://sourceforge.net/p/libmtp/bugs/1198/ */
+  { "HTC", 0x0bb4, "Motorola Razr D1", 0x2012,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  // These identify themselves as "cm_tenderloin", fun...
+  // Done by HTC for HP I guess.
+  { "HTC (for Hewlett-Packard)", 0x0bb4, "HP Touchpad (MTP)", 0x685c,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "HTC (for Hewlett-Packard)", 0x0bb4, "HP Touchpad (MTP+ADB)", 0x6860,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "HTC", 0x0bb4, "Windows Phone 8s ID1", 0xf0ca,
+      DEVICE_FLAG_NONE },
+
+  /*
+   * NEC
+   */
+  { "NEC", 0x0409, "FOMA N01A", 0x0242, DEVICE_FLAG_NONE },
+  { "NEC", 0x0409, "Casio C811", 0x0326, DEVICE_FLAG_NONE },
+  { "NEC", 0x0409, "Casio CA-201L", 0x0432, DEVICE_FLAG_NONE },
+
+  /*
+   * nVidia
+   */
+  // Found on Internet forum
+  { "nVidia", 0x0955, "CM9-Adam", 0x70a9,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  // Various pads such as Nabi2, Notion Ink Adam, Viewsonic G-Tablet
+  { "nVidia", 0x0955, "Various tablets (ID1)", 0x7100,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "nVidia", 0x0955, "Various tablets (ID2)", 0x7102,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "nVidia", 0x0955, "Shield (ID1)", 0xb400,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  /* https://sourceforge.net/p/libmtp/bugs/1087/ */
+  { "nVidia", 0x0955, "Tegra Note", 0xcf02,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  /* benpro82@gmail.com */
+  { "nVidia", 0x0955, "Shield (ID2)", 0xcf07,
+      DEVICE_FLAGS_ANDROID_BUGS },
+
+  /*
+   * Vizio
+   * Reported by:
+   * Michael Gurski <gurski@users.sourceforge.net>
+   */
+  /* https://sourceforge.net/p/libmtp/support-requests/138/ */
+  { "InFocus", 0x0489, "M810", 0xc025,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "Vizio", 0x0489, "Unknown 1", 0xc026,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "Vizio", 0x0489, "VTAB1008", 0xe040,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "Vizio (for Lenovo)", 0x0489, "LIFETAB S9714", 0xe111,
+      DEVICE_FLAGS_ANDROID_BUGS },
+
+
+  /*
+   * Amazon
+   */
+  { "Amazon", 0x1949, "Kindle Fire 2G (ID1)", 0x0005,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "Amazon", 0x1949, "Kindle Fire (ID1)", 0x0007,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "Amazon", 0x1949, "Kindle Fire (ID2)", 0x0008,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "Amazon", 0x1949, "Kindle Fire (ID3)", 0x000a,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  /* https://sourceforge.net/p/libmtp/bugs/1026/ */
+  { "Amazon", 0x1949, "Kindle Fire (ID6)", 0x000b,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "Amazon", 0x1949, "Kindle Fire (ID4)", 0x000c,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  /* https://sourceforge.net/p/libmtp/bugs/1015/ */
+  { "Amazon", 0x1949, "Kindle Fire (ID7)", 0x000d,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "Amazon", 0x1949, "Kindle Fire (ID5)", 0x0012,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  /* https://sourceforge.net/p/libmtp/bugs/1353/ */
+  { "Amazon", 0x1949, "Kindle Fire HD6", 0x00f2,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "Amazon", 0x1949, "Fire Phone", 0x0800,
+      DEVICE_FLAGS_ANDROID_BUGS },
+
+  /*
+   * Barnes&Noble
+   */
+  { "Barnes&Noble", 0x2080, "Nook HD+", 0x0005,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "Barnes&Noble", 0x2080, "Nook HD", 0x0006,
+      DEVICE_FLAGS_ANDROID_BUGS },
+
+  /*
+   * Viewpia, bq, YiFang
+   * Seems like some multi-branded OEM product line.
+   */
+  { "Various", 0x2207, "Viewpia DR/bq Kepler", 0x0001,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "YiFang", 0x2207, "BQ Tesla", 0x0006,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  /* https://sourceforge.net/p/libmtp/bugs/1354/ */
+  { "Various", 0x2207, "Viewpia DR/bq Kepler Debugging", 0x0011,
+      DEVICE_FLAGS_ANDROID_BUGS },
+
+  /*
+   * Kobo
+   */
+  /* https://sourceforge.net/p/libmtp/bugs/1208/ */
+  { "Kobo", 0x2237, "Arc 7 HD", 0xb108,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  // Reported by George Talusan
+  { "Kobo", 0x2237, "Arc (ID1)", 0xd108,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "Kobo", 0x2237, "Arc (ID2)", 0xd109,
+      DEVICE_FLAGS_ANDROID_BUGS },
+
+  /*
+   * Hisense
+   */
+  // Reported by Anonymous SourceForge users
+  { "Hisense", 0x109b, "E860 (ID1)", 0x9106, DEVICE_FLAGS_ANDROID_BUGS },
+  { "Hisense", 0x109b, "E860 (ID2)", 0x9109, DEVICE_FLAGS_ANDROID_BUGS },
+
+  /*
+   * Intel
+   * Also sold rebranded as Orange products
+   */
+  { "Intel", 0x8087, "Xolo 900/AZ210A", 0x09fb, DEVICE_FLAGS_ANDROID_BUGS },
+  /* https://sourceforge.net/p/libmtp/bugs/1256/ */
+  { "Intel", 0x8087, "Noblex T7A21", 0x0a16, DEVICE_FLAGS_ANDROID_BUGS },
+  /* https://sourceforge.net/p/libmtp/bugs/1252/ */
+  { "Intel", 0x8087, "Foxconn iView i700", 0x0a15, DEVICE_FLAGS_ANDROID_BUGS },
+  /* https://sourceforge.net/p/libmtp/bugs/1237/ */
+  { "Intel", 0x8087, "Telcast Air 3G", 0x0a5e, DEVICE_FLAGS_ANDROID_BUGS },
+  /* https://sourceforge.net/p/libmtp/bugs/1338/ */
+  { "Intel", 0x8087, "Chuwi vi8", 0x0a5f, DEVICE_FLAGS_ANDROID_BUGS },
+
+  /*
+   * Xiaomi
+   */
+  /* https://sourceforge.net/p/libmtp/bugs/1269/ */
+  { "Xiaomi", 0x2717, "Mi-3w (MTP)", 0x0360,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "Xiaomi", 0x2717, "Mi-3 (MTP)", 0x0368,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  /* https://sourceforge.net/p/libmtp/bugs/1149/ */
+  { "Xiaomi", 0x2717, "MiPad (MTP)", 0x0660,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "Xiaomi", 0x2717, "Hongmi (MTP+ADB)", 0x1240,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  /* https://sourceforge.net/p/libmtp/bugs/1095/ */
+  { "Xiaomi", 0x2717, "Hongmi (MTP)", 0x1248,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  /* https://sourceforge.net/p/libmtp/bugs/1295/ */
+  { "Redmi", 0x2717, "1S (MTP)", 0x1260,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  /* https://sourceforge.net/p/libmtp/bugs/1164/ */
+  { "Redmi", 0x2717, "HM 1S (MTP)", 0x1268,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  /* https://sourceforge.net/p/libmtp/discussion/535190/ */
+  { "Xiaomi", 0x2717, "HM NOTE 1LTEW MIUI (MTP)", 0x1368,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "Xiaomi", 0x2717, "Mi-2 (MTP+ADB)", 0x9039,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "Xiaomi", 0x2717, "Mi-2 (MTP)", 0xf003,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  /* https://sourceforge.net/p/libmtp/bugs/1339/ */
+  { "Xiaomi", 0x2717, "Mi-2s (MTP)", 0xff48,
+      DEVICE_FLAGS_ANDROID_BUGS },
+
+  /*
+   * XO Learning Tablet
+   * Also Trio Stealth G2 tablet it seems
+   */
+  { "Acromag Inc.", 0x16d5, "XO Learning Tablet (MTP+ADB)", 0x8005,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "Acromag Inc.", 0x16d5, "XO Learning Tablet (MTP)", 0x8006,
+      DEVICE_FLAGS_ANDROID_BUGS },
+
+  /*
+   * SHARP Corporation
+   */
+  { "SHARP Corporation", 0x0489, "SH930W", 0xc025,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "SHARP Corporation", 0x04dd, "SBM203SH", 0x9661,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "SHARP Corporation", 0x04dd, "SH-06E", 0x96ca,
+      DEVICE_FLAGS_ANDROID_BUGS },
+
+  /*
+   * T & A Mobile phones Alcatel and TCT
+   */
+  { "Alcatel", 0x1bbb, "One Touch 997D (MTP+ADB)", 0x0c02,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "Alcatel", 0x1bbb, "One Touch 997D (MTP)", 0x2008,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "Alcatel/TCT", 0x1bbb, "6010D/TCL S950", 0x0167,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "Alcatel", 0x1bbb, "6030a", 0x0168,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "Alcatel/Bouygues", 0x1bbb, "BS472", 0x904d,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  /* https://sourceforge.net/p/libmtp/bugs/1304/ */
+  { "Alcatel", 0x1bbb, "OneTouch 5042D (MTP)", 0xa00e,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  /* https://sourceforge.net/p/libmtp/feature-requests/114/ */
+  { "Alcatel", 0x1bbb, "OneTouch 6034R", 0xf003,
+      DEVICE_FLAGS_ANDROID_BUGS },
+
+  /*
+   * Kyocera
+   */
+  { "Kyocera", 0x0482, "Rise", 0x0571, DEVICE_FLAGS_ANDROID_BUGS },
+  /* https://sourceforge.net/p/libmtp/feature-requests/134/ */
+  { "Kyocera", 0x0482, "Torque Model E6715", 0x0059a, DEVICE_FLAGS_ANDROID_BUGS },
+  /* https://sourceforge.net/p/libmtp/discussion/535190/thread/6270f5ce/ */
+  { "Kyocera", 0x0482, "KYL22", 0x0810, DEVICE_FLAGS_ANDROID_BUGS },
+  /* https://sourceforge.net/p/libmtp/bugs/1345/ */
+  { "Kyocera", 0x0482, "DuraForce", 0x0979, DEVICE_FLAGS_ANDROID_BUGS },
+
+  /*
+   * HiSense
+   */
+  { "HiSense", 0x109b, "Sero 7 Pro", 0x9105,
+      DEVICE_FLAGS_ANDROID_BUGS },
+
+  /*
+   * Hewlett-Packard
+   */
+  { "Hewlett-Packard", 0x03f0, "Slate 7 4600", 0x5c1d,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "Hewlett-Packard", 0x03f0, "Slate 7 2800", 0x5d1d,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  /* https://sourceforge.net/p/libmtp/bugs/1366/ */
+  { "Hewlett-Packard", 0x03f0, "Slate 10 HD", 0x7e1d,
+      DEVICE_FLAGS_ANDROID_BUGS },
+
+  /*
+   * MediaTek Inc.
+   */
+  { "MediaTek Inc", 0x0e8d, "MT5xx and MT6xx SoCs", 0x0050,
+      DEVICE_FLAGS_ANDROID_BUGS },
+
+  /*
+   * Jolla
+   */
+  { "Jolla", 0x2931, "Sailfish (ID1)", 0x0a01,
+      DEVICE_FLAGS_ANDROID_BUGS },
+
+  /*
+   * TCL? Alcatel?
+   */
+  { "TCL", 0x0451, "Alcatel one touch 986+", 0xd108,
+      DEVICE_FLAGS_ANDROID_BUGS },
+
+  /*
+   * Garmin
+   */
+  { "Garmin", 0x091e, "Monterra", 0x2585,
+      DEVICE_FLAGS_ANDROID_BUGS },
+
+  /*
+   * Wacom
+   */
+  { "Wacom", 0x0531, "Cintiq Companion Hybrid (MTP+ADB)", 0x2001,
+      DEVICE_FLAGS_ANDROID_BUGS },
+
+  /*
+   * Kurio
+   */
+  { "Kurio", 0x1f3a, "7S", 0x1006,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  /* https://sourceforge.net/p/libmtp/bugs/1245/ */
+  { "DigiLand", 0x1f3a, "DL701Q", 0x0c02,
+      DEVICE_FLAGS_ANDROID_BUGS },
+
+  /* In update 4 the order of devices was changed for
+     better OS X / Windows suport and another device-id
+     got assigned for the MTP */
+  { "Jolla", 0x2931, "Sailfish (ID2)", 0x0a05,
+      DEVICE_FLAGS_ANDROID_BUGS },
+
+  /*
+   * bq
+   * https://sourceforge.net/p/libmtp/feature-requests/128/
+   */
+  { "bq", 0x2a47, "Krillin (MTP)", 0x2008,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  { "bq", 0x2a47, "Krillin (MTP+ADB)", 0x0c02,
+      DEVICE_FLAGS_ANDROID_BUGS },
+  /* https://sourceforge.net/p/libmtp/bugs/1311/ */
+  { "bq", 0x2a47, "Aquarius E5-4G", 0x7f10,
+      DEVICE_FLAGS_ANDROID_BUGS },
+
+  /* https://sourceforge.net/p/libmtp/bugs/1292/ */
+  { "Prestigio", 0x29e4, "5505 DUO ", 0x1103, DEVICE_FLAGS_ANDROID_BUGS },
+  /* https://sourceforge.net/p/libmtp/bugs/1243/ */
+  { "Prestigio", 0x29e4, "5504 DUO ", 0x1203, DEVICE_FLAGS_ANDROID_BUGS },
+
+  /* https://sourceforge.net/p/libmtp/bugs/1283/ */
+  { "Megafon", 0x201e, "MFLogin3T", 0x42ab, DEVICE_FLAGS_ANDROID_BUGS },
+
+  /* https://sourceforge.net/p/libmtp/bugs/1287/ */
+  { "Gensis", 0x040d, "GT-7305 ", 0x885c, DEVICE_FLAGS_ANDROID_BUGS },
+
+  /* https://sourceforge.net/p/libmtp/bugs/1207/ */
+  { "Oppo", 0x22d9, "Find 7 (ID 1)", 0x2765, DEVICE_FLAGS_ANDROID_BUGS },
+  /* https://sourceforge.net/p/libmtp/bugs/1277/ */
+  { "Oppo", 0x22d9, "X9006", 0x2773, DEVICE_FLAGS_ANDROID_BUGS },
+  /* https://sourceforge.net/p/libmtp/support-requests/129/ */
+  { "Oppo", 0x22d9, "Find 7 (ID 2)", 0x2774, DEVICE_FLAGS_ANDROID_BUGS },
+
+  /* https://sourceforge.net/p/libmtp/bugs/1273/ */
+  { "Gigabyte", 0x0414, "RCT6773W22 (MTP+ADB)", 0x0c02, DEVICE_FLAGS_ANDROID_BUGS },
+  { "Gigabyte", 0x0414, "RCT6773W22 (MTP)", 0x2008, DEVICE_FLAGS_ANDROID_BUGS },
+
+  /* https://sourceforge.net/p/libmtp/bugs/1264/ */
+  { "Meizu", 0x2a45, "MX Phone (MTP)", 0x2008, DEVICE_FLAGS_ANDROID_BUGS },
+  /* https://sourceforge.net/p/libmtp/bugs/1263/ */
+  { "Meizu", 0x2a45, "MX Phone (MTP+ADB)", 0x0c02, DEVICE_FLAGS_ANDROID_BUGS },
+
+  /* https://sourceforge.net/p/libmtp/bugs/1201/ */
+  { "Caterpillar", 0x04b7, "Cat S50", 0x88a9, DEVICE_FLAGS_ANDROID_BUGS },
+
+  /* https://sourceforge.net/p/libmtp/bugs/682/ */
+  { "Pegatron", 0x1d4d, "Chagall (ADB)", 0x5035, DEVICE_FLAGS_ANDROID_BUGS },
+  { "Pegatron", 0x1d4d, "Chagall", 0x5036, DEVICE_FLAGS_ANDROID_BUGS },
+  /* https://sourceforge.net/p/libmtp/feature-requests/115/ */
+  { "Pegatron", 0x1d4d, "Hudl 2", 0x504a, DEVICE_FLAGS_ANDROID_BUGS },
+
+  /* https://sourceforge.net/p/libmtp/bugs/1229/ */
+  { "Yota", 0x2916, "Phone 2", 0x914d, DEVICE_FLAGS_ANDROID_BUGS },
+  /* https://sourceforge.net/p/libmtp/bugs/1267/ */
+  { "Yota", 0x2916, "Phone 2 (ID2)", 0xf003, DEVICE_FLAGS_ANDROID_BUGS },
+
+  /* https://sourceforge.net/p/libmtp/bugs/1212/ */
+  { "Fly", 0x2970, "Evo Tech 4", 0x2008, DEVICE_FLAGS_ANDROID_BUGS },
+
+  /* https://sourceforge.net/p/libmtp/bugs/1303/ */
+  { "Megafon", 0x1271, "Login+", 0x2012, DEVICE_FLAGS_ANDROID_BUGS },
+
+  /* https://sourceforge.net/p/libmtp/bugs/1127/ */
+  { "Fly", 0x2970, "iq4415 era style 3", 0x0c02, DEVICE_FLAGS_ANDROID_BUGS },
+  /* https://sourceforge.net/p/libmtp/bugs/1082/ */
+  { "Fly", 0x1782, "iq449", 0x4001, DEVICE_FLAGS_ANDROID_BUGS },
+
+  /*
+  * YU Yureka.
+  */
+  { "YU Yureka", 0x1ebf, "Vodafone smart turbo 4", 0x7f29, DEVICE_FLAGS_ANDROID_BUGS },
+
+  /* https://sourceforge.net/p/libmtp/bugs/1314/ */
+  { "BenQ", 0x1d45, "F5", 0x459d, DEVICE_FLAGS_ANDROID_BUGS },
+
+  /* https://sourceforge.net/p/libmtp/bugs/1362/ */
+  { "TomTom", 0x1390, "Rider 40", 0x5455, DEVICE_FLAGS_ANDROID_BUGS },
+  /*
+   * Other strange stuff.
+   */
+  { "Isabella", 0x0b20, "Her Prototype", 0xddee, DEVICE_FLAG_NONE }
+
diff -urpN wireshark-3.2.1.orig/tools/ptp.h wireshark-3.2.1/tools/ptp.h
--- wireshark-3.2.1.orig/tools/ptp.h	1969-12-31 16:00:00.000000000 -0800
+++ wireshark-3.2.1/tools/ptp.h	2020-02-04 22:58:56.712432077 -0800
@@ -0,0 +1,3330 @@
+/* ptp.h
+ *
+ * Copyright (C) 2001 Mariusz Woloszyn <emsi@ipartners.pl>
+ * Copyright (C) 2003-2014 Marcus Meissner <marcus@jet.franken.de>
+ * Copyright (C) 2006-2008 Linus Walleij <triad@df.lth.se>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA  02110-1301  USA
+ */
+
+#ifndef __PTP_H__
+#define __PTP_H__
+
+#include <stdarg.h>
+#include <time.h>
+#if defined(HAVE_ICONV) && defined(HAVE_LANGINFO_H)
+#include <iconv.h>
+#endif
+#include "gphoto2-endian.h"
+#include "device-flags.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+/* PTP datalayer byteorder */
+
+#define PTP_DL_BE			0xF0
+#define	PTP_DL_LE			0x0F
+
+/* USB interface class */
+#ifndef USB_CLASS_PTP
+#define USB_CLASS_PTP			6
+#endif
+
+/* PTP request/response/event general PTP container (transport independent) */
+
+struct _PTPContainer {
+	uint16_t Code;
+	uint32_t SessionID;
+	uint32_t Transaction_ID;
+	/* params  may be of any type of size less or equal to uint32_t */
+	uint32_t Param1;
+	uint32_t Param2;
+	uint32_t Param3;
+	/* events can only have three parameters */
+	uint32_t Param4;
+	uint32_t Param5;
+	/* the number of meaningfull parameters */
+	uint8_t	 Nparam;
+};
+typedef struct _PTPContainer PTPContainer;
+
+/* PTP USB Bulk-Pipe container */
+/* USB bulk max packet length for high speed endpoints */
+/* The max packet is set to 512 bytes. The spec says
+ * "end of data transfers are signaled by short packets or NULL
+ * packets". It never says anything about 512, but current
+ * implementations seem to have chosen this value, which also
+ * happens to be the size of an USB 2.0 HS endpoint, even though
+ * this is not necessary.
+ *
+ * Previously we had this as 4096 for MTP devices. We have found
+ * and fixed the bugs that made this necessary and it can be 512 again.
+ *
+ * USB 3.0 has now 1024 byte EPs.
+ */
+#define PTP_USB_BULK_HS_MAX_PACKET_LEN_WRITE	512
+#define PTP_USB_BULK_HS_MAX_PACKET_LEN_READ   512
+#define PTP_USB_BULK_SS_MAX_PACKET_LEN_WRITE	1024
+#define PTP_USB_BULK_SS_MAX_PACKET_LEN_READ   1024
+#define PTP_USB_BULK_HDR_LEN		(2*sizeof(uint32_t)+2*sizeof(uint16_t))
+#define PTP_USB_BULK_PAYLOAD_LEN_WRITE	(PTP_USB_BULK_SS_MAX_PACKET_LEN_WRITE-PTP_USB_BULK_HDR_LEN)
+#define PTP_USB_BULK_PAYLOAD_LEN_READ	(PTP_USB_BULK_SS_MAX_PACKET_LEN_READ-PTP_USB_BULK_HDR_LEN)
+#define PTP_USB_BULK_REQ_LEN	(PTP_USB_BULK_HDR_LEN+5*sizeof(uint32_t))
+
+struct _PTPUSBBulkContainer {
+	uint32_t length;
+	uint16_t type;
+	uint16_t code;
+	uint32_t trans_id;
+	union {
+		struct {
+			uint32_t param1;
+			uint32_t param2;
+			uint32_t param3;
+			uint32_t param4;
+			uint32_t param5;
+		} params;
+       /* this must be set to the maximum of PTP_USB_BULK_PAYLOAD_LEN_WRITE 
+        * and PTP_USB_BULK_PAYLOAD_LEN_READ */
+		unsigned char data[PTP_USB_BULK_PAYLOAD_LEN_READ];
+	} payload;
+};
+typedef struct _PTPUSBBulkContainer PTPUSBBulkContainer;
+
+/* PTP USB Asynchronous Event Interrupt Data Format */
+struct _PTPUSBEventContainer {
+	uint32_t length;
+	uint16_t type;
+	uint16_t code;
+	uint32_t trans_id;
+	uint32_t param1;
+	uint32_t param2;
+	uint32_t param3;
+};
+typedef struct _PTPUSBEventContainer PTPUSBEventContainer;
+
+struct _PTPCanon_directtransfer_entry {
+	uint32_t	oid;
+	char		*str;
+};
+typedef struct _PTPCanon_directtransfer_entry PTPCanon_directtransfer_entry;
+
+/* USB container types */
+
+#define PTP_USB_CONTAINER_UNDEFINED		0x0000
+#define PTP_USB_CONTAINER_COMMAND		0x0001
+#define PTP_USB_CONTAINER_DATA			0x0002
+#define PTP_USB_CONTAINER_RESPONSE		0x0003
+#define PTP_USB_CONTAINER_EVENT			0x0004
+
+/* PTP/IP definitions */
+#define PTPIP_INIT_COMMAND_REQUEST	1
+#define PTPIP_INIT_COMMAND_ACK		2
+#define PTPIP_INIT_EVENT_REQUEST	3
+#define PTPIP_INIT_EVENT_ACK		4
+#define PTPIP_INIT_FAIL			5
+#define PTPIP_CMD_REQUEST		6
+#define PTPIP_CMD_RESPONSE		7
+#define PTPIP_EVENT			8
+#define PTPIP_START_DATA_PACKET		9
+#define PTPIP_DATA_PACKET		10
+#define PTPIP_CANCEL_TRANSACTION	11
+#define PTPIP_END_DATA_PACKET		12
+#define PTPIP_PING			13
+#define PTPIP_PONG			14
+
+struct _PTPIPHeader {
+	uint32_t	length;
+	uint32_t	type;
+};
+typedef struct _PTPIPHeader PTPIPHeader;
+
+/* Vendor IDs */
+#define PTP_VENDOR_EASTMAN_KODAK	0x00000001
+#define PTP_VENDOR_SEIKO_EPSON		0x00000002
+#define PTP_VENDOR_AGILENT		0x00000003
+#define PTP_VENDOR_POLAROID		0x00000004
+#define PTP_VENDOR_AGFA_GEVAERT		0x00000005
+#define PTP_VENDOR_MICROSOFT		0x00000006
+#define PTP_VENDOR_EQUINOX		0x00000007
+#define PTP_VENDOR_VIEWQUEST		0x00000008
+#define PTP_VENDOR_STMICROELECTRONICS	0x00000009
+#define PTP_VENDOR_NIKON		0x0000000A
+#define PTP_VENDOR_CANON		0x0000000B
+#define PTP_VENDOR_FOTONATION		0x0000000C
+#define PTP_VENDOR_PENTAX		0x0000000D
+#define PTP_VENDOR_FUJI			0x0000000E
+/* not from standards papers, but from traces: */
+#define PTP_VENDOR_SONY			0x00000011 /* observed in the A900 */
+#define PTP_VENDOR_SAMSUNG		0x0000001a /* observed in the Samsung NX1000 */
+/* Vendor extension ID used for MTP (occasionaly, usualy 6 is used) */
+#define PTP_VENDOR_MTP			0xffffffff  
+
+/* gphoto overrides */
+#define PTP_VENDOR_GP_OLYMPUS		0xfffffffe
+
+/* Operation Codes */
+
+/* PTP v1.0 operation codes */
+#define PTP_OC_Undefined                0x1000
+#define PTP_OC_GetDeviceInfo            0x1001
+#define PTP_OC_OpenSession              0x1002
+#define PTP_OC_CloseSession             0x1003
+#define PTP_OC_GetStorageIDs            0x1004
+#define PTP_OC_GetStorageInfo           0x1005
+#define PTP_OC_GetNumObjects            0x1006
+#define PTP_OC_GetObjectHandles         0x1007
+#define PTP_OC_GetObjectInfo            0x1008
+#define PTP_OC_GetObject                0x1009
+#define PTP_OC_GetThumb                 0x100A
+#define PTP_OC_DeleteObject             0x100B
+#define PTP_OC_SendObjectInfo           0x100C
+#define PTP_OC_SendObject               0x100D
+#define PTP_OC_InitiateCapture          0x100E
+#define PTP_OC_FormatStore              0x100F
+#define PTP_OC_ResetDevice              0x1010
+#define PTP_OC_SelfTest                 0x1011
+#define PTP_OC_SetObjectProtection      0x1012
+#define PTP_OC_PowerDown                0x1013
+#define PTP_OC_GetDevicePropDesc        0x1014
+#define PTP_OC_GetDevicePropValue       0x1015
+#define PTP_OC_SetDevicePropValue       0x1016
+#define PTP_OC_ResetDevicePropValue     0x1017
+#define PTP_OC_TerminateOpenCapture     0x1018
+#define PTP_OC_MoveObject               0x1019
+#define PTP_OC_CopyObject               0x101A
+#define PTP_OC_GetPartialObject         0x101B
+#define PTP_OC_InitiateOpenCapture      0x101C
+/* PTP v1.1 operation codes */
+#define PTP_OC_StartEnumHandles		0x101D
+#define PTP_OC_EnumHandles		0x101E
+#define PTP_OC_StopEnumHandles		0x101F
+#define PTP_OC_GetVendorExtensionMaps	0x1020
+#define PTP_OC_GetVendorDeviceInfo	0x1021
+#define PTP_OC_GetResizedImageObject	0x1022
+#define PTP_OC_GetFilesystemManifest	0x1023
+#define PTP_OC_GetStreamInfo		0x1024
+#define PTP_OC_GetStream		0x1025
+
+/* Eastman Kodak extension Operation Codes */
+#define PTP_OC_EK_GetSerial		0x9003
+#define PTP_OC_EK_SetSerial		0x9004
+#define PTP_OC_EK_SendFileObjectInfo	0x9005
+#define PTP_OC_EK_SendFileObject	0x9006
+#define PTP_OC_EK_SetText		0x9008
+
+/* Canon extension Operation Codes */
+#define PTP_OC_CANON_GetPartialObjectInfo	0x9001
+/* 9002 - sends 2 uint32, nothing back  */
+#define PTP_OC_CANON_SetObjectArchive		0x9002
+#define PTP_OC_CANON_KeepDeviceOn		0x9003
+#define PTP_OC_CANON_LockDeviceUI		0x9004
+#define PTP_OC_CANON_UnlockDeviceUI		0x9005
+#define PTP_OC_CANON_GetObjectHandleByName	0x9006
+/* no 9007 observed yet */
+#define PTP_OC_CANON_InitiateReleaseControl	0x9008
+#define PTP_OC_CANON_TerminateReleaseControl	0x9009
+#define PTP_OC_CANON_TerminatePlaybackMode	0x900A
+#define PTP_OC_CANON_ViewfinderOn		0x900B
+#define PTP_OC_CANON_ViewfinderOff		0x900C
+#define PTP_OC_CANON_DoAeAfAwb			0x900D
+
+/* 900e - send nothing, gets 5 uint16t in 32bit entities back in 20byte datablob */
+#define PTP_OC_CANON_GetCustomizeSpec		0x900E
+#define PTP_OC_CANON_GetCustomizeItemInfo	0x900F
+#define PTP_OC_CANON_GetCustomizeData		0x9010
+#define PTP_OC_CANON_SetCustomizeData		0x9011
+#define PTP_OC_CANON_GetCaptureStatus		0x9012
+#define PTP_OC_CANON_CheckEvent			0x9013
+#define PTP_OC_CANON_FocusLock			0x9014
+#define PTP_OC_CANON_FocusUnlock		0x9015
+#define PTP_OC_CANON_GetLocalReleaseParam	0x9016
+#define PTP_OC_CANON_SetLocalReleaseParam	0x9017
+#define PTP_OC_CANON_AskAboutPcEvf		0x9018
+#define PTP_OC_CANON_SendPartialObject		0x9019
+#define PTP_OC_CANON_InitiateCaptureInMemory	0x901A
+#define PTP_OC_CANON_GetPartialObjectEx		0x901B
+#define PTP_OC_CANON_SetObjectTime		0x901C
+#define PTP_OC_CANON_GetViewfinderImage		0x901D
+#define PTP_OC_CANON_GetObjectAttributes	0x901E
+#define PTP_OC_CANON_ChangeUSBProtocol		0x901F
+#define PTP_OC_CANON_GetChanges			0x9020
+#define PTP_OC_CANON_GetObjectInfoEx		0x9021
+#define PTP_OC_CANON_InitiateDirectTransfer	0x9022
+#define PTP_OC_CANON_TerminateDirectTransfer 	0x9023
+#define PTP_OC_CANON_SendObjectInfoByPath 	0x9024
+#define PTP_OC_CANON_SendObjectByPath 		0x9025
+#define PTP_OC_CANON_InitiateDirectTansferEx	0x9026
+#define PTP_OC_CANON_GetAncillaryObjectHandles	0x9027
+#define PTP_OC_CANON_GetTreeInfo 		0x9028
+#define PTP_OC_CANON_GetTreeSize 		0x9029
+#define PTP_OC_CANON_NotifyProgress 		0x902A
+#define PTP_OC_CANON_NotifyCancelAccepted	0x902B
+/* 902c: no parms, read 3 uint32 in data, no response parms */
+#define PTP_OC_CANON_902C			0x902C
+#define PTP_OC_CANON_GetDirectory		0x902D
+#define PTP_OC_CANON_902E			0x902E
+
+#define PTP_OC_CANON_SetPairingInfo		0x9030
+#define PTP_OC_CANON_GetPairingInfo		0x9031
+#define PTP_OC_CANON_DeletePairingInfo		0x9032
+#define PTP_OC_CANON_GetMACAddress		0x9033
+/* 9034: 1 param, no parms returned */
+#define PTP_OC_CANON_SetDisplayMonitor		0x9034
+#define PTP_OC_CANON_PairingComplete		0x9035
+#define PTP_OC_CANON_GetWirelessMAXChannel	0x9036
+
+#define PTP_OC_CANON_GetWebServiceSpec		0x9068
+#define PTP_OC_CANON_GetWebServiceData		0x9069
+#define PTP_OC_CANON_SetWebServiceData		0x906B
+#define PTP_OC_CANON_GetRootCertificateSpec	0x906C
+#define PTP_OC_CANON_GetRootCertificateData	0x906D
+#define PTP_OC_CANON_SetRootCertificateData	0x906F
+
+/* 9101: no args, 8 byte data (01 00 00 00 00 00 00 00), no resp data. */
+#define PTP_OC_CANON_EOS_GetStorageIDs		0x9101
+/* 9102: 1 arg (0)
+ * 0x28 bytes of data:
+    00000000: 34 00 00 00 02 00 02 91 0a 00 00 00 04 00 03 00
+    00000010: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
+    00000020: 00 00 ff ff ff ff 03 43 00 46 00 00 00 03 41 00
+    00000030: 3a 00 00 00
+ * no resp args
+ */
+#define PTP_OC_CANON_EOS_GetStorageInfo		0x9102
+#define PTP_OC_CANON_EOS_GetObjectInfo		0x9103
+#define PTP_OC_CANON_EOS_GetObject		0x9104
+#define PTP_OC_CANON_EOS_DeleteObject		0x9105
+#define PTP_OC_CANON_EOS_FormatStore		0x9106
+#define PTP_OC_CANON_EOS_GetPartialObject	0x9107
+#define PTP_OC_CANON_EOS_GetDeviceInfoEx	0x9108
+
+/* sample1:
+ * 3 cmdargs: 1,0xffffffff,00 00 10 00;
+ * data:
+    00000000: 48 00 00 00 02 00 09 91 12 00 00 00 01 00 00 00
+    00000010: 38 00 00 00 00 00 00 30 01 00 00 00 01 30 00 00
+    00000020: 01 00 00 00 10 00 00 00 00 00 00 00 00 00 00 20
+    00000030: 00 00 00 30 44 43 49 4d 00 00 00 00 00 00 00 00	DCIM
+    00000040: 00 00 00 00 cc c3 01 46
+ * 2 respargs: 0x0, 0x3c
+ * 
+ * sample2:
+ *
+    00000000: 18 00 00 00 01 00 09 91 15 00 00 00 01 00 00 00
+    00000010: 00 00 00 30 00 00 10 00
+
+    00000000: 48 00 00 00 02 00 09 91 15 00 00 00 01 00 00 00
+    00000010: 38 00 00 00 00 00 9c 33 01 00 00 00 01 30 00 00
+    00000020: 01 00 00 00 10 00 00 00 00 00 00 00 00 00 00 30
+    00000030: 00 00 9c 33 32 33 31 43 41 4e 4f 4e 00 00 00 00	 231CANON
+    00000040: 00 00 00 00 cc c3 01 46
+
+ */
+#define PTP_OC_CANON_EOS_GetObjectInfoEx	0x9109
+#define PTP_OC_CANON_EOS_GetThumbEx		0x910A
+#define PTP_OC_CANON_EOS_SendPartialObject	0x910B
+#define PTP_OC_CANON_EOS_SetObjectAttributes	0x910C
+#define PTP_OC_CANON_EOS_GetObjectTime		0x910D
+#define PTP_OC_CANON_EOS_SetObjectTime		0x910E
+
+/* 910f: no args, no data, 1 response arg (0). */
+#define PTP_OC_CANON_EOS_RemoteRelease		0x910F
+/* Marcus: looks more like "Set DeviceProperty" in the trace. 
+ *
+ * no cmd args
+ * data phase (0xc, 0xd11c, 0x1)
+ * no resp args 
+ */
+#define PTP_OC_CANON_EOS_SetDevicePropValueEx	0x9110
+#define PTP_OC_CANON_EOS_GetRemoteMode		0x9113
+/* 9114: 1 arg (0x1), no data, no resp data. */
+#define PTP_OC_CANON_EOS_SetRemoteMode		0x9114
+/* 9115: 1 arg (0x1), no data, no resp data. */
+#define PTP_OC_CANON_EOS_SetEventMode		0x9115
+/* 9116: no args, data phase, no resp data. */
+#define PTP_OC_CANON_EOS_GetEvent		0x9116
+#define PTP_OC_CANON_EOS_TransferComplete	0x9117
+#define PTP_OC_CANON_EOS_CancelTransfer		0x9118
+#define PTP_OC_CANON_EOS_ResetTransfer		0x9119
+
+/* 911a: 3 args (0xfffffff7, 0x00001000, 0x00000001), no data, no resp data. */
+/* 911a: 3 args (0x001dfc60, 0x00001000, 0x00000001), no data, no resp data. */
+#define PTP_OC_CANON_EOS_PCHDDCapacity		0x911A
+
+/* 911b: no cmd args, no data, no resp args */
+#define PTP_OC_CANON_EOS_SetUILock		0x911B
+/* 911c: no cmd args, no data, no resp args */
+#define PTP_OC_CANON_EOS_ResetUILock		0x911C
+#define PTP_OC_CANON_EOS_KeepDeviceOn		0x911D
+#define PTP_OC_CANON_EOS_SetNullPacketMode	0x911E
+#define PTP_OC_CANON_EOS_UpdateFirmware		0x911F
+#define PTP_OC_CANON_EOS_TransferCompleteDT	0x9120
+#define PTP_OC_CANON_EOS_CancelTransferDT	0x9121
+#define PTP_OC_CANON_EOS_SetWftProfile		0x9122
+#define PTP_OC_CANON_EOS_GetWftProfile		0x9123
+#define PTP_OC_CANON_EOS_SetProfileToWft	0x9124
+#define PTP_OC_CANON_EOS_BulbStart		0x9125
+#define PTP_OC_CANON_EOS_BulbEnd		0x9126
+#define PTP_OC_CANON_EOS_RequestDevicePropValue	0x9127
+
+/* 0x9128 args (0x1/0x2, 0x0), no data, no resp args */
+#define PTP_OC_CANON_EOS_RemoteReleaseOn	0x9128
+/* 0x9129 args (0x1/0x2), no data, no resp args */
+#define PTP_OC_CANON_EOS_RemoteReleaseOff	0x9129
+
+#define PTP_OC_CANON_EOS_RegistBackgroundImage	0x912A
+#define PTP_OC_CANON_EOS_ChangePhotoStudioMode	0x912B
+#define PTP_OC_CANON_EOS_GetPartialObjectEx	0x912C
+#define PTP_OC_CANON_EOS_ResetMirrorLockupState	0x9130
+#define PTP_OC_CANON_EOS_PopupBuiltinFlash	0x9131
+#define PTP_OC_CANON_EOS_EndGetPartialObjectEx	0x9132
+#define PTP_OC_CANON_EOS_MovieSelectSWOn	0x9133
+#define PTP_OC_CANON_EOS_MovieSelectSWOff	0x9134
+#define PTP_OC_CANON_EOS_GetCTGInfo		0x9135
+#define PTP_OC_CANON_EOS_GetLensAdjust		0x9136
+#define PTP_OC_CANON_EOS_SetLensAdjust		0x9137
+#define PTP_OC_CANON_EOS_GetMusicInfo		0x9138
+/* 3 paramaeters, no data, OFC, size, unknown */
+#define PTP_OC_CANON_EOS_CreateHandle		0x9139
+#define PTP_OC_CANON_EOS_SendPartialObjectEx	0x913A
+#define PTP_OC_CANON_EOS_EndSendPartialObjectEx	0x913B
+#define PTP_OC_CANON_EOS_SetCTGInfo		0x913C
+#define PTP_OC_CANON_EOS_SetRequestOLCInfoGroup	0x913D
+#define PTP_OC_CANON_EOS_SetRequestRollingPitchingLevel	0x913E
+#define PTP_OC_CANON_EOS_GetCameraSupport	0x913F
+#define PTP_OC_CANON_EOS_SetRating		0x9140 /* 2 args */
+#define PTP_OC_CANON_EOS_RequestInnerDevelopStart	0x9141 /* 2 args: 1 type, 1 object? */
+#define PTP_OC_CANON_EOS_RequestInnerDevelopParamChange	0x9142
+#define PTP_OC_CANON_EOS_RequestInnerDevelopEnd		0x9143
+#define PTP_OC_CANON_EOS_GpsLoggingDataMode		0x9144 /* 1 arg */
+#define PTP_OC_CANON_EOS_GetGpsLogCurrentHandle		0x9145
+
+#define PTP_OC_CANON_EOS_InitiateViewfinder	0x9151
+#define PTP_OC_CANON_EOS_TerminateViewfinder	0x9152
+/* EOS M2 wlan: 2 params, 0x00200000 0x01000000 */
+#define PTP_OC_CANON_EOS_GetViewFinderData	0x9153
+#define PTP_OC_CANON_EOS_DoAf			0x9154
+#define PTP_OC_CANON_EOS_DriveLens		0x9155
+#define PTP_OC_CANON_EOS_DepthOfFieldPreview	0x9156 /* 1 arg */
+#define PTP_OC_CANON_EOS_ClickWB		0x9157 /* 2 args: x,y */
+#define PTP_OC_CANON_EOS_Zoom			0x9158 /* 1 arg */
+#define PTP_OC_CANON_EOS_ZoomPosition		0x9159 /* 2 args: x,y */
+#define PTP_OC_CANON_EOS_SetLiveAfFrame		0x915A
+#define PTP_OC_CANON_EOS_TouchAfPosition	0x915B /* 3 args: type,x,y */
+#define PTP_OC_CANON_EOS_SetLvPcFlavoreditMode	0x915C /* 1 arg */
+#define PTP_OC_CANON_EOS_SetLvPcFlavoreditParam	0x915D /* 1 arg */
+#define PTP_OC_CANON_EOS_AfCancel		0x9160
+#define PTP_OC_CANON_EOS_SetDefaultCameraSetting		0x91BE
+#define PTP_OC_CANON_EOS_GetAEData		0x91BF
+#define PTP_OC_CANON_EOS_NotifyNetworkError	0x91E8
+#define PTP_OC_CANON_EOS_AdapterTransferProgress	0x91E9
+#define PTP_OC_CANON_EOS_TransferComplete2	0x91F0
+#define PTP_OC_CANON_EOS_CancelTransfer2	0x91F1
+#define PTP_OC_CANON_EOS_FAPIMessageTX		0x91FE
+#define PTP_OC_CANON_EOS_FAPIMessageRX		0x91FF
+
+/* Nikon extension Operation Codes */
+#define PTP_OC_NIKON_GetProfileAllData	0x9006
+#define PTP_OC_NIKON_SendProfileData	0x9007
+#define PTP_OC_NIKON_DeleteProfile	0x9008
+#define PTP_OC_NIKON_SetProfileData	0x9009
+#define PTP_OC_NIKON_AdvancedTransfer	0x9010
+#define PTP_OC_NIKON_GetFileInfoInBlock	0x9011
+#define PTP_OC_NIKON_Capture		0x90C0	/* 1 param,   no data */
+#define PTP_OC_NIKON_AfDrive		0x90C1	/* no params, no data */
+#define PTP_OC_NIKON_SetControlMode	0x90C2	/* 1 param,  no data */
+#define PTP_OC_NIKON_DelImageSDRAM	0x90C3	/* 1 param,  no data */
+#define PTP_OC_NIKON_GetLargeThumb	0x90C4
+#define PTP_OC_NIKON_CurveDownload	0x90C5	/* 1 param,   data in */
+#define PTP_OC_NIKON_CurveUpload	0x90C6	/* 1 param,   data out */
+#define PTP_OC_NIKON_CheckEvent		0x90C7	/* no params, data in */
+#define PTP_OC_NIKON_DeviceReady	0x90C8	/* no params, no data */
+#define PTP_OC_NIKON_SetPreWBData	0x90C9	/* 3 params,  data out */
+#define PTP_OC_NIKON_GetVendorPropCodes	0x90CA	/* 0 params, data in */
+#define PTP_OC_NIKON_AfCaptureSDRAM	0x90CB	/* no params, no data */
+#define PTP_OC_NIKON_GetPictCtrlData	0x90CC	/* 2 params, data in */
+#define PTP_OC_NIKON_SetPictCtrlData	0x90CD	/* 2 params, data out */
+#define PTP_OC_NIKON_DelCstPicCtrl	0x90CE	/* 1 param, no data */
+#define PTP_OC_NIKON_GetPicCtrlCapability	0x90CF	/* 1 param, data in */
+
+/* Nikon Liveview stuff */
+#define PTP_OC_NIKON_GetPreviewImg	0x9200
+#define PTP_OC_NIKON_StartLiveView	0x9201	/* no params */
+#define PTP_OC_NIKON_EndLiveView	0x9202	/* no params */
+#define PTP_OC_NIKON_GetLiveViewImg	0x9203	/* no params, data in */
+#define PTP_OC_NIKON_MfDrive		0x9204	/* 2 params */
+#define PTP_OC_NIKON_ChangeAfArea	0x9205	/* 2 params */
+#define PTP_OC_NIKON_AfDriveCancel	0x9206	/* no params */
+/* 2 params:
+ * 0xffffffff == No AF before,  0xfffffffe == AF before capture
+ * sdram=1, card=0
+ */
+#define PTP_OC_NIKON_InitiateCaptureRecInMedia	0x9207	/* 1 params */
+
+#define PTP_OC_NIKON_GetVendorStorageIDs	0x9209	/* no params, data in */
+
+#define PTP_OC_NIKON_StartMovieRecInCard	0x920a	/* no params, no data */
+#define PTP_OC_NIKON_EndMovieRec		0x920b	/* no params, no data */
+
+#define PTP_OC_NIKON_TerminateCapture		0x920c	/* 2 params */
+
+#define PTP_OC_NIKON_GetDevicePTPIPInfo	0x90E0
+
+#define PTP_OC_NIKON_GetPartialObjectHiSpeed	0x9400	/* 3 params, data in */
+
+/* From Nikon V1 Trace */
+#define PTP_OC_NIKON_GetDevicePropEx		0x9504	/* gets device prop dataa */
+
+/* Casio EX-F1 (from http://code.google.com/p/exf1ctrl/ ) */
+#define PTP_OC_CASIO_STILL_START	0x9001
+#define PTP_OC_CASIO_STILL_STOP		0x9002
+
+#define PTP_OC_CASIO_FOCUS		0x9007
+#define PTP_OC_CASIO_CF_PRESS		0x9009
+#define PTP_OC_CASIO_CF_RELEASE		0x900A
+#define PTP_OC_CASIO_GET_OBJECT_INFO	0x900C
+
+#define PTP_OC_CASIO_SHUTTER		0x9024
+#define PTP_OC_CASIO_GET_STILL_HANDLES	0x9027
+#define PTP_OC_CASIO_STILL_RESET	0x9028
+#define PTP_OC_CASIO_HALF_PRESS		0x9029
+#define PTP_OC_CASIO_HALF_RELEASE	0x902A
+#define PTP_OC_CASIO_CS_PRESS		0x902B
+#define PTP_OC_CASIO_CS_RELEASE		0x902C
+
+#define PTP_OC_CASIO_ZOOM		0x902D
+#define PTP_OC_CASIO_CZ_PRESS		0x902E
+#define PTP_OC_CASIO_CZ_RELEASE		0x902F
+
+#define PTP_OC_CASIO_MOVIE_START	0x9041
+#define PTP_OC_CASIO_MOVIE_STOP		0x9042
+#define PTP_OC_CASIO_MOVIE_PRESS	0x9043
+#define PTP_OC_CASIO_MOVIE_RELEASE	0x9044
+#define PTP_OC_CASIO_GET_MOVIE_HANDLES	0x9045
+#define PTP_OC_CASIO_MOVIE_RESET	0x9046
+
+#define PTP_OC_CASIO_GET_OBJECT		0x9025
+#define PTP_OC_CASIO_GET_THUMBNAIL	0x9026
+
+/* Sony stuff */
+/* 9201:
+ *  3 params: 1,0,0 ; IN: data 8 bytes all 0
+ * or:
+ *  3 params: 2,0,0 ; IN: data 8 bytes all 0 
+ * or
+ *  3 params: 3,0,0,: IN: data 8 butes all 0
+ */
+#define PTP_OC_SONY_SDIOConnect			0x9201
+/* 9202: 1 param, 0xc8; IN data: 
+ * 16 bit: 0xc8
+ * ptp array 32 bit: index, 16 bit values of propcodes  */
+#define PTP_OC_SONY_GetSDIOGetExtDeviceInfo	0x9202
+
+#define PTP_OC_SONY_GetDevicePropdesc		0x9203
+#define PTP_OC_SONY_GetDevicePropertyValue	0x9204
+/* 1 param, 16bit propcode, SEND DATA: propvalue */
+#define PTP_OC_SONY_SetControlDeviceA		0x9205
+#define PTP_OC_SONY_GetControlDeviceDesc	0x9206
+/* 1 param, 16bit propcode, SEND DATA: propvalue */
+#define PTP_OC_SONY_SetControlDeviceB		0x9207
+/* get all device property data at once */
+#define PTP_OC_SONY_GetAllDevicePropData	0x9209	/* gets a 4126 byte blob of device props ?*/
+
+/* Microsoft / MTP extension codes */
+
+#define PTP_OC_MTP_GetObjectPropsSupported	0x9801
+#define PTP_OC_MTP_GetObjectPropDesc		0x9802
+#define PTP_OC_MTP_GetObjectPropValue		0x9803
+#define PTP_OC_MTP_SetObjectPropValue		0x9804
+#define PTP_OC_MTP_GetObjPropList		0x9805
+#define PTP_OC_MTP_SetObjPropList		0x9806
+#define PTP_OC_MTP_GetInterdependendPropdesc	0x9807
+#define PTP_OC_MTP_SendObjectPropList		0x9808
+#define PTP_OC_MTP_GetObjectReferences		0x9810
+#define PTP_OC_MTP_SetObjectReferences		0x9811
+#define PTP_OC_MTP_UpdateDeviceFirmware		0x9812
+#define PTP_OC_MTP_Skip				0x9820
+
+/*
+ * Windows Media Digital Rights Management for Portable Devices 
+ * Extension Codes (microsoft.com/WMDRMPD: 10.1)
+ */
+#define PTP_OC_MTP_WMDRMPD_GetSecureTimeChallenge	0x9101
+#define PTP_OC_MTP_WMDRMPD_GetSecureTimeResponse	0x9102
+#define PTP_OC_MTP_WMDRMPD_SetLicenseResponse	0x9103
+#define PTP_OC_MTP_WMDRMPD_GetSyncList		0x9104
+#define PTP_OC_MTP_WMDRMPD_SendMeterChallengeQuery	0x9105
+#define PTP_OC_MTP_WMDRMPD_GetMeterChallenge	0x9106
+#define PTP_OC_MTP_WMDRMPD_SetMeterResponse		0x9107
+#define PTP_OC_MTP_WMDRMPD_CleanDataStore		0x9108
+#define PTP_OC_MTP_WMDRMPD_GetLicenseState		0x9109
+#define PTP_OC_MTP_WMDRMPD_SendWMDRMPDCommand	0x910A
+#define PTP_OC_MTP_WMDRMPD_SendWMDRMPDRequest	0x910B
+
+/* 
+ * Windows Media Digital Rights Management for Portable Devices 
+ * Extension Codes (microsoft.com/WMDRMPD: 10.1)
+ * Below are operations that have no public documented identifier 
+ * associated with them "Vendor-defined Command Code"
+ */
+#define PTP_OC_MTP_WMDRMPD_SendWMDRMPDAppRequest	0x9212
+#define PTP_OC_MTP_WMDRMPD_GetWMDRMPDAppResponse	0x9213
+#define PTP_OC_MTP_WMDRMPD_EnableTrustedFilesOperations	0x9214
+#define PTP_OC_MTP_WMDRMPD_DisableTrustedFilesOperations 0x9215
+#define PTP_OC_MTP_WMDRMPD_EndTrustedAppSession		0x9216
+/* ^^^ guess ^^^ */
+
+/*
+ * Microsoft Advanced Audio/Video Transfer 
+ * Extensions (microsoft.com/AAVT: 1.0)
+ */
+#define PTP_OC_MTP_AAVT_OpenMediaSession		0x9170
+#define PTP_OC_MTP_AAVT_CloseMediaSession		0x9171
+#define PTP_OC_MTP_AAVT_GetNextDataBlock		0x9172
+#define PTP_OC_MTP_AAVT_SetCurrentTimePosition		0x9173
+
+/*
+ * Windows Media Digital Rights Management for Network Devices 
+ * Extensions (microsoft.com/WMDRMND: 1.0) MTP/IP?
+ */
+#define PTP_OC_MTP_WMDRMND_SendRegistrationRequest	0x9180
+#define PTP_OC_MTP_WMDRMND_GetRegistrationResponse	0x9181
+#define PTP_OC_MTP_WMDRMND_GetProximityChallenge	0x9182
+#define PTP_OC_MTP_WMDRMND_SendProximityResponse	0x9183
+#define PTP_OC_MTP_WMDRMND_SendWMDRMNDLicenseRequest	0x9184
+#define PTP_OC_MTP_WMDRMND_GetWMDRMNDLicenseResponse	0x9185
+
+/* 
+ * Windows Media Player Portiable Devices 
+ * Extension Codes (microsoft.com/WMPPD: 11.1)
+ */
+#define PTP_OC_MTP_WMPPD_ReportAddedDeletedItems	0x9201
+#define PTP_OC_MTP_WMPPD_ReportAcquiredItems 	        0x9202
+#define PTP_OC_MTP_WMPPD_PlaylistObjectPref		0x9203
+
+/*
+ * Undocumented Zune Operation Codes 
+ * maybe related to WMPPD extension set?
+ */
+#define PTP_OC_MTP_ZUNE_GETUNDEFINED001		        0x9204
+
+/* WiFi Provisioning MTP Extension Codes (microsoft.com/WPDWCN: 1.0) */
+#define PTP_OC_MTP_WPDWCN_ProcessWFCObject		0x9122
+
+
+/* Olympus E series commands */
+#define PTP_OC_OLYMPUS_Capture				0x9101
+#define PTP_OC_OLYMPUS_SelfCleaning			0x9103
+#define PTP_OC_OLYMPUS_SetRGBGain			0x9106
+#define PTP_OC_OLYMPUS_SetPresetMode			0x9107
+#define PTP_OC_OLYMPUS_SetWBBiasAll			0x9108
+#define PTP_OC_OLYMPUS_GetCameraControlMode		0x910a
+#define PTP_OC_OLYMPUS_SetCameraControlMode		0x910b
+#define PTP_OC_OLYMPUS_SetWBRGBGain			0x910c
+#define PTP_OC_OLYMPUS_GetDeviceInfo			0x9301
+#define PTP_OC_OLYMPUS_OpenSession			0x9302
+#define PTP_OC_OLYMPUS_SetDateTime			0x9402
+#define PTP_OC_OLYMPUS_GetDateTime			0x9482
+#define PTP_OC_OLYMPUS_SetCameraID			0x9501
+#define PTP_OC_OLYMPUS_GetCameraID			0x9581
+
+/* Android Random I/O Extensions Codes */
+#define PTP_OC_ANDROID_GetPartialObject64		0x95C1
+#define PTP_OC_ANDROID_SendPartialObject		0x95C2
+#define PTP_OC_ANDROID_TruncateObject			0x95C3
+#define PTP_OC_ANDROID_BeginEditObject			0x95C4
+#define PTP_OC_ANDROID_EndEditObject			0x95C5
+
+/* Leica opcodes, from Lightroom tether plugin */
+#define PTP_OC_LEICA_SetCameraSettings			0x9001
+#define PTP_OC_LEICA_GetCameraSettings			0x9002
+#define PTP_OC_LEICA_GetLensParameter			0x9003
+/* probably 2 arguments.
+ * generic: releaseStage, stepSize
+ * Release(releasestage) = (releasestage,0)
+ * Release() = (0,0)
+ * AEStart() = (1,0)
+ * Autofocusrelease() = (2,0)
+ * AutofocusPush() = (1,0) ... same as AEStart?
+ * KeepCameraActive() = (0xe,0)
+ */
+#define PTP_OC_LEICA_Release				0x9004
+#define PTP_OC_LEICA_OpenLESession			0x9005
+#define PTP_OC_LEICA_CloseLESession			0x9006
+#define PTP_OC_LEICA_RequestObjectTransferReady		0x9007
+
+/* Proprietary vendor extension operations mask */
+#define PTP_OC_EXTENSION_MASK           0xF000
+#define PTP_OC_EXTENSION                0x9000
+
+/* Response Codes */
+
+/* PTP v1.0 response codes */
+#define PTP_RC_Undefined                0x2000
+#define PTP_RC_OK                       0x2001
+#define PTP_RC_GeneralError             0x2002
+#define PTP_RC_SessionNotOpen           0x2003
+#define PTP_RC_InvalidTransactionID     0x2004
+#define PTP_RC_OperationNotSupported    0x2005
+#define PTP_RC_ParameterNotSupported    0x2006
+#define PTP_RC_IncompleteTransfer       0x2007
+#define PTP_RC_InvalidStorageId         0x2008
+#define PTP_RC_InvalidObjectHandle      0x2009
+#define PTP_RC_DevicePropNotSupported   0x200A
+#define PTP_RC_InvalidObjectFormatCode  0x200B
+#define PTP_RC_StoreFull                0x200C
+#define PTP_RC_ObjectWriteProtected     0x200D
+#define PTP_RC_StoreReadOnly            0x200E
+#define PTP_RC_AccessDenied             0x200F
+#define PTP_RC_NoThumbnailPresent       0x2010
+#define PTP_RC_SelfTestFailed           0x2011
+#define PTP_RC_PartialDeletion          0x2012
+#define PTP_RC_StoreNotAvailable        0x2013
+#define PTP_RC_SpecificationByFormatUnsupported         0x2014
+#define PTP_RC_NoValidObjectInfo        0x2015
+#define PTP_RC_InvalidCodeFormat        0x2016
+#define PTP_RC_UnknownVendorCode        0x2017
+#define PTP_RC_CaptureAlreadyTerminated 0x2018
+#define PTP_RC_DeviceBusy               0x2019
+#define PTP_RC_InvalidParentObject      0x201A
+#define PTP_RC_InvalidDevicePropFormat  0x201B
+#define PTP_RC_InvalidDevicePropValue   0x201C
+#define PTP_RC_InvalidParameter         0x201D
+#define PTP_RC_SessionAlreadyOpened     0x201E
+#define PTP_RC_TransactionCanceled      0x201F
+#define PTP_RC_SpecificationOfDestinationUnsupported            0x2020
+/* PTP v1.1 response codes */
+#define PTP_RC_InvalidEnumHandle	0x2021
+#define PTP_RC_NoStreamEnabled		0x2022
+#define PTP_RC_InvalidDataSet		0x2023
+
+/* Eastman Kodak extension Response Codes */
+#define PTP_RC_EK_FilenameRequired	0xA001
+#define PTP_RC_EK_FilenameConflicts	0xA002
+#define PTP_RC_EK_FilenameInvalid	0xA003
+
+/* Nikon specific response codes */
+#define PTP_RC_NIKON_HardwareError		0xA001
+#define PTP_RC_NIKON_OutOfFocus			0xA002
+#define PTP_RC_NIKON_ChangeCameraModeFailed	0xA003
+#define PTP_RC_NIKON_InvalidStatus		0xA004
+#define PTP_RC_NIKON_SetPropertyNotSupported	0xA005
+#define PTP_RC_NIKON_WbResetError		0xA006
+#define PTP_RC_NIKON_DustReferenceError		0xA007
+#define PTP_RC_NIKON_ShutterSpeedBulb		0xA008
+#define PTP_RC_NIKON_MirrorUpSequence		0xA009
+#define PTP_RC_NIKON_CameraModeNotAdjustFNumber	0xA00A
+#define PTP_RC_NIKON_NotLiveView		0xA00B
+#define PTP_RC_NIKON_MfDriveStepEnd		0xA00C
+#define PTP_RC_NIKON_MfDriveStepInsufficiency	0xA00E
+#define PTP_RC_NIKON_AdvancedTransferCancel	0xA022
+
+/* Canon specific response codes */
+#define PTP_RC_CANON_UNKNOWN_COMMAND		0xA001
+#define PTP_RC_CANON_OPERATION_REFUSED		0xA005
+#define PTP_RC_CANON_LENS_COVER			0xA006
+#define PTP_RC_CANON_BATTERY_LOW		0xA101
+#define PTP_RC_CANON_NOT_READY			0xA102
+
+#define PTP_RC_CANON_A009			0xA009
+
+/* Microsoft/MTP specific codes */
+#define PTP_RC_MTP_Undefined			0xA800
+#define PTP_RC_MTP_Invalid_ObjectPropCode	0xA801
+#define PTP_RC_MTP_Invalid_ObjectProp_Format	0xA802
+#define PTP_RC_MTP_Invalid_ObjectProp_Value	0xA803
+#define PTP_RC_MTP_Invalid_ObjectReference	0xA804
+#define PTP_RC_MTP_Invalid_Dataset		0xA806
+#define PTP_RC_MTP_Specification_By_Group_Unsupported		0xA807
+#define PTP_RC_MTP_Specification_By_Depth_Unsupported		0xA808
+#define PTP_RC_MTP_Object_Too_Large		0xA809
+#define PTP_RC_MTP_ObjectProp_Not_Supported	0xA80A
+
+/* Microsoft Advanced Audio/Video Transfer response codes 
+(microsoft.com/AAVT 1.0) */
+#define PTP_RC_MTP_Invalid_Media_Session_ID	0xA170	
+#define PTP_RC_MTP_Media_Session_Limit_Reached	0xA171
+#define PTP_RC_MTP_No_More_Data			0xA172
+
+/* WiFi Provisioning MTP Extension Error Codes (microsoft.com/WPDWCN: 1.0) */
+#define PTP_RC_MTP_Invalid_WFC_Syntax		0xA121
+#define PTP_RC_MTP_WFC_Version_Not_Supported	0xA122
+
+/* libptp2 extended ERROR codes */
+#define PTP_ERROR_TIMEOUT		0x02FA
+#define PTP_ERROR_CANCEL		0x02FB
+#define PTP_ERROR_BADPARAM		0x02FC
+#define PTP_ERROR_RESP_EXPECTED		0x02FD
+#define PTP_ERROR_DATA_EXPECTED		0x02FE
+#define PTP_ERROR_IO			0x02FF
+
+/* PTP Event Codes */
+
+#define PTP_EC_Undefined		0x4000
+#define PTP_EC_CancelTransaction	0x4001
+#define PTP_EC_ObjectAdded		0x4002
+#define PTP_EC_ObjectRemoved		0x4003
+#define PTP_EC_StoreAdded		0x4004
+#define PTP_EC_StoreRemoved		0x4005
+#define PTP_EC_DevicePropChanged	0x4006
+#define PTP_EC_ObjectInfoChanged	0x4007
+#define PTP_EC_DeviceInfoChanged	0x4008
+#define PTP_EC_RequestObjectTransfer	0x4009
+#define PTP_EC_StoreFull		0x400A
+#define PTP_EC_DeviceReset		0x400B
+#define PTP_EC_StorageInfoChanged	0x400C
+#define PTP_EC_CaptureComplete		0x400D
+#define PTP_EC_UnreportedStatus		0x400E
+
+/* Canon extension Event Codes */
+#define PTP_EC_CANON_ExtendedErrorcode		0xC005	/* ? */
+#define PTP_EC_CANON_ObjectInfoChanged		0xC008
+#define PTP_EC_CANON_RequestObjectTransfer	0xC009
+#define PTP_EC_CANON_ShutterButtonPressed0	0xC00B
+#define PTP_EC_CANON_CameraModeChanged		0xC00C
+#define PTP_EC_CANON_ShutterButtonPressed1	0xC00E
+
+#define PTP_EC_CANON_StartDirectTransfer	0xC011
+#define PTP_EC_CANON_StopDirectTransfer		0xC013
+
+/* Canon EOS events */
+#define PTP_EC_CANON_EOS_RequestGetEvent		0xc101
+#define PTP_EC_CANON_EOS_ObjectAddedEx			0xc181
+#define PTP_EC_CANON_EOS_ObjectRemoved			0xc182
+#define PTP_EC_CANON_EOS_RequestGetObjectInfoEx		0xc183
+#define PTP_EC_CANON_EOS_StorageStatusChanged		0xc184
+#define PTP_EC_CANON_EOS_StorageInfoChanged		0xc185
+#define PTP_EC_CANON_EOS_RequestObjectTransfer		0xc186
+#define PTP_EC_CANON_EOS_ObjectInfoChangedEx		0xc187
+#define PTP_EC_CANON_EOS_ObjectContentChanged		0xc188
+#define PTP_EC_CANON_EOS_PropValueChanged		0xc189
+#define PTP_EC_CANON_EOS_AvailListChanged		0xc18a
+#define PTP_EC_CANON_EOS_CameraStatusChanged		0xc18b
+#define PTP_EC_CANON_EOS_WillSoonShutdown		0xc18d
+#define PTP_EC_CANON_EOS_ShutdownTimerUpdated		0xc18e
+#define PTP_EC_CANON_EOS_RequestCancelTransfer		0xc18f
+#define PTP_EC_CANON_EOS_RequestObjectTransferDT	0xc190
+#define PTP_EC_CANON_EOS_RequestCancelTransferDT	0xc191
+#define PTP_EC_CANON_EOS_StoreAdded			0xc192
+#define PTP_EC_CANON_EOS_StoreRemoved			0xc193
+#define PTP_EC_CANON_EOS_BulbExposureTime		0xc194
+#define PTP_EC_CANON_EOS_RecordingTime			0xc195
+#define PTP_EC_CANON_EOS_RequestObjectTransferTS	0xC1a2
+#define PTP_EC_CANON_EOS_AfResult			0xc1a3
+#define PTP_EC_CANON_EOS_CTGInfoCheckComplete		0xc1a4
+#define PTP_EC_CANON_EOS_OLCInfoChanged			0xc1a5
+#define PTP_EC_CANON_EOS_RequestObjectTransferFTP	0xc1f1
+
+/* Nikon extension Event Codes */
+
+/* Nikon extension Event Codes */
+#define PTP_EC_Nikon_ObjectAddedInSDRAM		0xC101
+#define PTP_EC_Nikon_CaptureCompleteRecInSdram	0xC102
+/* Gets 1 parameter, objectid pointing to DPOF object */
+#define PTP_EC_Nikon_AdvancedTransfer		0xC103
+#define PTP_EC_Nikon_PreviewImageAdded		0xC104
+
+/* Olympus E series */
+#define PTP_EC_Olympus_PropertyChanged		0xC102
+#define PTP_EC_Olympus_CaptureComplete		0xC103
+
+/* Sony */
+#define PTP_EC_Sony_ObjectAdded			0xC201
+/* c202 ... unclear. also called with object id? */
+#define PTP_EC_Sony_PropertyChanged		0xC203
+
+/* MTP Event codes */
+#define PTP_EC_MTP_ObjectPropChanged		0xC801
+#define PTP_EC_MTP_ObjectPropDescChanged	0xC802
+#define PTP_EC_MTP_ObjectReferencesChanged	0xC803
+
+/* constants for GetObjectHandles */
+#define PTP_GOH_ALL_STORAGE 0xffffffff
+#define PTP_GOH_ALL_FORMATS 0x00000000
+#define PTP_GOH_ALL_ASSOCS  0x00000000
+#define PTP_GOH_ROOT_PARENT 0xffffffff
+
+/* PTP device info structure (returned by GetDevInfo) */
+
+struct _PTPDeviceInfo {
+	uint16_t StandardVersion;
+	uint32_t VendorExtensionID;
+	uint16_t VendorExtensionVersion;
+	char	*VendorExtensionDesc;
+	uint16_t FunctionalMode;
+	uint32_t OperationsSupported_len;
+	uint16_t *OperationsSupported;
+	uint32_t EventsSupported_len;
+	uint16_t *EventsSupported;
+	uint32_t DevicePropertiesSupported_len;
+	uint16_t *DevicePropertiesSupported;
+	uint32_t CaptureFormats_len;
+	uint16_t *CaptureFormats;
+	uint32_t ImageFormats_len;
+	uint16_t *ImageFormats;
+	char	*Manufacturer;
+	char	*Model;
+	char	*DeviceVersion;
+	char	*SerialNumber;
+};
+typedef struct _PTPDeviceInfo PTPDeviceInfo;
+
+/* PTP storageIDs structute (returned by GetStorageIDs) */
+
+struct _PTPStorageIDs {
+	uint32_t n;
+	uint32_t *Storage;
+};
+typedef struct _PTPStorageIDs PTPStorageIDs;
+
+/* PTP StorageInfo structure (returned by GetStorageInfo) */
+struct _PTPStorageInfo {
+	uint16_t StorageType;
+	uint16_t FilesystemType;
+	uint16_t AccessCapability;
+	uint64_t MaxCapability;
+	uint64_t FreeSpaceInBytes;
+	uint32_t FreeSpaceInImages;
+	char 	*StorageDescription;
+	char	*VolumeLabel;
+};
+typedef struct _PTPStorageInfo PTPStorageInfo;
+
+/* PTP objecthandles structure (returned by GetObjectHandles) */
+
+struct _PTPObjectHandles {
+	uint32_t n;
+	uint32_t *Handler;
+};
+typedef struct _PTPObjectHandles PTPObjectHandles;
+
+#define PTP_HANDLER_SPECIAL	0xffffffff
+#define PTP_HANDLER_ROOT	0x00000000
+
+
+/* PTP objectinfo structure (returned by GetObjectInfo) */
+
+struct _PTPObjectInfo {
+	uint32_t StorageID;
+	uint16_t ObjectFormat;
+	uint16_t ProtectionStatus;
+	/* In the regular objectinfo this is 32bit,
+	 * but we keep the general object size here
+	 * that also arrives via other methods and so
+	 * use 64bit */
+	uint64_t ObjectCompressedSize;
+	uint16_t ThumbFormat;
+	uint32_t ThumbCompressedSize;
+	uint32_t ThumbPixWidth;
+	uint32_t ThumbPixHeight;
+	uint32_t ImagePixWidth;
+	uint32_t ImagePixHeight;
+	uint32_t ImageBitDepth;
+	uint32_t ParentObject;
+	uint16_t AssociationType;
+	uint32_t AssociationDesc;
+	uint32_t SequenceNumber;
+	char 	*Filename;
+	time_t	CaptureDate;
+	time_t	ModificationDate;
+	char	*Keywords;
+};
+typedef struct _PTPObjectInfo PTPObjectInfo;
+
+/* max ptp string length INCLUDING terminating null character */
+
+#define PTP_MAXSTRLEN				255
+
+/* PTP Object Format Codes */
+
+/* ancillary formats */
+#define PTP_OFC_Undefined			0x3000
+#define PTP_OFC_Defined				0x3800
+#define PTP_OFC_Association			0x3001
+#define PTP_OFC_Script				0x3002
+#define PTP_OFC_Executable			0x3003
+#define PTP_OFC_Text				0x3004
+#define PTP_OFC_HTML				0x3005
+#define PTP_OFC_DPOF				0x3006
+#define PTP_OFC_AIFF	 			0x3007
+#define PTP_OFC_WAV				0x3008
+#define PTP_OFC_MP3				0x3009
+#define PTP_OFC_AVI				0x300A
+#define PTP_OFC_MPEG				0x300B
+#define PTP_OFC_ASF				0x300C
+#define PTP_OFC_QT				0x300D /* guessing */
+/* image formats */
+#define PTP_OFC_EXIF_JPEG			0x3801
+#define PTP_OFC_TIFF_EP				0x3802
+#define PTP_OFC_FlashPix			0x3803
+#define PTP_OFC_BMP				0x3804
+#define PTP_OFC_CIFF				0x3805
+#define PTP_OFC_Undefined_0x3806		0x3806
+#define PTP_OFC_GIF				0x3807
+#define PTP_OFC_JFIF				0x3808
+#define PTP_OFC_PCD				0x3809
+#define PTP_OFC_PICT				0x380A
+#define PTP_OFC_PNG				0x380B
+#define PTP_OFC_Undefined_0x380C		0x380C
+#define PTP_OFC_TIFF				0x380D
+#define PTP_OFC_TIFF_IT				0x380E
+#define PTP_OFC_JP2				0x380F
+#define PTP_OFC_JPX				0x3810
+/* ptp v1.1 has only DNG new */
+#define PTP_OFC_DNG				0x3811
+/* Eastman Kodak extension ancillary format */
+#define PTP_OFC_EK_M3U				0xb002
+/* Canon extension */
+#define PTP_OFC_CANON_CRW			0xb101
+#define PTP_OFC_CANON_CRW3			0xb103
+#define PTP_OFC_CANON_MOV			0xb104
+#define PTP_OFC_CANON_MOV2			0xb105
+/* CHDK specific raw mode */
+#define PTP_OFC_CANON_CHDK_CRW			0xb1ff
+/* Sony */
+#define PTP_OFC_SONY_RAW			0xb101
+/* MTP extensions */
+#define PTP_OFC_MTP_MediaCard			0xb211
+#define PTP_OFC_MTP_MediaCardGroup		0xb212
+#define PTP_OFC_MTP_Encounter			0xb213
+#define PTP_OFC_MTP_EncounterBox		0xb214
+#define PTP_OFC_MTP_M4A				0xb215
+#define PTP_OFC_MTP_ZUNEUNDEFINED		0xb217 /* Unknown file type */
+#define PTP_OFC_MTP_Firmware			0xb802
+#define PTP_OFC_MTP_WindowsImageFormat		0xb881
+#define PTP_OFC_MTP_UndefinedAudio		0xb900
+#define PTP_OFC_MTP_WMA				0xb901
+#define PTP_OFC_MTP_OGG				0xb902
+#define PTP_OFC_MTP_AAC				0xb903
+#define PTP_OFC_MTP_AudibleCodec		0xb904
+#define PTP_OFC_MTP_FLAC			0xb906
+#define PTP_OFC_MTP_SamsungPlaylist		0xb909
+#define PTP_OFC_MTP_UndefinedVideo		0xb980
+#define PTP_OFC_MTP_WMV				0xb981
+#define PTP_OFC_MTP_MP4				0xb982
+#define PTP_OFC_MTP_MP2				0xb983
+#define PTP_OFC_MTP_3GP				0xb984
+#define PTP_OFC_MTP_UndefinedCollection		0xba00
+#define PTP_OFC_MTP_AbstractMultimediaAlbum	0xba01
+#define PTP_OFC_MTP_AbstractImageAlbum		0xba02
+#define PTP_OFC_MTP_AbstractAudioAlbum		0xba03
+#define PTP_OFC_MTP_AbstractVideoAlbum		0xba04
+#define PTP_OFC_MTP_AbstractAudioVideoPlaylist	0xba05
+#define PTP_OFC_MTP_AbstractContactGroup	0xba06
+#define PTP_OFC_MTP_AbstractMessageFolder	0xba07
+#define PTP_OFC_MTP_AbstractChapteredProduction	0xba08
+#define PTP_OFC_MTP_AbstractAudioPlaylist	0xba09
+#define PTP_OFC_MTP_AbstractVideoPlaylist	0xba0a
+#define PTP_OFC_MTP_AbstractMediacast		0xba0b
+#define PTP_OFC_MTP_WPLPlaylist			0xba10
+#define PTP_OFC_MTP_M3UPlaylist			0xba11
+#define PTP_OFC_MTP_MPLPlaylist			0xba12
+#define PTP_OFC_MTP_ASXPlaylist			0xba13
+#define PTP_OFC_MTP_PLSPlaylist			0xba14
+#define PTP_OFC_MTP_UndefinedDocument		0xba80
+#define PTP_OFC_MTP_AbstractDocument		0xba81
+#define PTP_OFC_MTP_XMLDocument			0xba82
+#define PTP_OFC_MTP_MSWordDocument		0xba83
+#define PTP_OFC_MTP_MHTCompiledHTMLDocument	0xba84
+#define PTP_OFC_MTP_MSExcelSpreadsheetXLS	0xba85
+#define PTP_OFC_MTP_MSPowerpointPresentationPPT	0xba86
+#define PTP_OFC_MTP_UndefinedMessage		0xbb00
+#define PTP_OFC_MTP_AbstractMessage		0xbb01
+#define PTP_OFC_MTP_UndefinedContact		0xbb80
+#define PTP_OFC_MTP_AbstractContact		0xbb81
+#define PTP_OFC_MTP_vCard2			0xbb82
+#define PTP_OFC_MTP_vCard3			0xbb83
+#define PTP_OFC_MTP_UndefinedCalendarItem	0xbe00
+#define PTP_OFC_MTP_AbstractCalendarItem	0xbe01
+#define PTP_OFC_MTP_vCalendar1			0xbe02
+#define PTP_OFC_MTP_vCalendar2			0xbe03
+#define PTP_OFC_MTP_UndefinedWindowsExecutable	0xbe80
+#define PTP_OFC_MTP_MediaCast			0xbe81
+#define PTP_OFC_MTP_Section			0xbe82
+
+/* PTP Association Types */
+#define PTP_AT_Undefined			0x0000
+#define PTP_AT_GenericFolder			0x0001
+#define PTP_AT_Album				0x0002
+#define PTP_AT_TimeSequence			0x0003
+#define PTP_AT_HorizontalPanoramic		0x0004
+#define PTP_AT_VerticalPanoramic		0x0005
+#define PTP_AT_2DPanoramic			0x0006
+#define PTP_AT_AncillaryData			0x0007
+
+/* PTP Protection Status */
+
+#define PTP_PS_NoProtection			0x0000
+#define PTP_PS_ReadOnly				0x0001
+#define PTP_PS_MTP_ReadOnlyData			0x8002
+#define PTP_PS_MTP_NonTransferableData		0x8003
+
+/* PTP Storage Types */
+
+#define PTP_ST_Undefined			0x0000
+#define PTP_ST_FixedROM				0x0001
+#define PTP_ST_RemovableROM			0x0002
+#define PTP_ST_FixedRAM				0x0003
+#define PTP_ST_RemovableRAM			0x0004
+
+/* PTP FilesystemType Values */
+
+#define PTP_FST_Undefined			0x0000
+#define PTP_FST_GenericFlat			0x0001
+#define PTP_FST_GenericHierarchical		0x0002
+#define PTP_FST_DCF				0x0003
+
+/* PTP StorageInfo AccessCapability Values */
+
+#define PTP_AC_ReadWrite			0x0000
+#define PTP_AC_ReadOnly				0x0001
+#define PTP_AC_ReadOnly_with_Object_Deletion	0x0002
+
+/* Property Describing Dataset, Range Form */
+
+union _PTPPropertyValue {
+	char		*str;	/* common string, malloced */
+	uint8_t		u8;
+	int8_t		i8;
+	uint16_t	u16;
+	int16_t		i16;
+	uint32_t	u32;
+	int32_t		i32;
+	uint64_t	u64;
+	int64_t		i64;
+	/* XXXX: 128 bit signed and unsigned missing */
+	struct array {
+		uint32_t	count;
+		union _PTPPropertyValue	*v;	/* malloced, count elements */
+	} a;
+};
+
+typedef union _PTPPropertyValue PTPPropertyValue;
+
+/* Metadata lists for MTP operations */
+struct _MTPProperties {
+	uint16_t 	 	property;
+	uint16_t 	 	datatype;
+	uint32_t 	 	ObjectHandle;
+	PTPPropertyValue 	propval;
+};
+typedef struct _MTPProperties MTPProperties;
+
+struct _PTPPropDescRangeForm {
+	PTPPropertyValue 	MinimumValue;
+	PTPPropertyValue 	MaximumValue;
+	PTPPropertyValue 	StepSize;
+};
+typedef struct _PTPPropDescRangeForm PTPPropDescRangeForm;
+
+/* Property Describing Dataset, Enum Form */
+
+struct _PTPPropDescEnumForm {
+	uint16_t		NumberOfValues;
+	PTPPropertyValue	*SupportedValue;	/* malloced */
+};
+typedef struct _PTPPropDescEnumForm PTPPropDescEnumForm;
+
+/* Device Property Describing Dataset (DevicePropDesc) */
+
+struct _PTPDevicePropDesc {
+	uint16_t		DevicePropertyCode;
+	uint16_t		DataType;
+	uint8_t			GetSet;
+	PTPPropertyValue	FactoryDefaultValue;
+	PTPPropertyValue	CurrentValue;
+	uint8_t			FormFlag;
+	union	{
+		PTPPropDescEnumForm	Enum;
+		PTPPropDescRangeForm	Range;
+	} FORM;
+};
+typedef struct _PTPDevicePropDesc PTPDevicePropDesc;
+
+/* Object Property Describing Dataset (DevicePropDesc) */
+
+struct _PTPObjectPropDesc {
+	uint16_t		ObjectPropertyCode;
+	uint16_t		DataType;
+	uint8_t			GetSet;
+	PTPPropertyValue	FactoryDefaultValue;
+	uint32_t		GroupCode;
+	uint8_t			FormFlag;
+	union	{
+		PTPPropDescEnumForm	Enum;
+		PTPPropDescRangeForm	Range;
+	} FORM;
+};
+typedef struct _PTPObjectPropDesc PTPObjectPropDesc;
+
+/* Canon filesystem's folder entry Dataset */
+
+#define PTP_CANON_FilenameBufferLen	13
+#define PTP_CANON_FolderEntryLen	28
+
+struct _PTPCANONFolderEntry {
+	uint32_t	ObjectHandle;
+	uint16_t	ObjectFormatCode;
+	uint8_t		Flags;
+	uint32_t	ObjectSize;
+	time_t		Time;
+	char		Filename[PTP_CANON_FilenameBufferLen];
+
+	uint32_t	StorageID;
+};
+typedef struct _PTPCANONFolderEntry PTPCANONFolderEntry;
+
+/* Nikon Tone Curve Data */
+
+#define PTP_NIKON_MaxCurvePoints 19
+
+struct _PTPNIKONCoordinatePair {
+	uint8_t		X;
+	uint8_t		Y;
+};
+
+typedef struct _PTPNIKONCoordinatePair PTPNIKONCoordinatePair;
+
+struct _PTPNTCCoordinatePair {
+	uint8_t		X;
+	uint8_t		Y;
+};
+
+typedef struct _PTPNTCCoordinatePair PTPNTCCoordinatePair;
+
+struct _PTPNIKONCurveData {
+	char 			static_preamble[6];
+	uint8_t			XAxisStartPoint;
+	uint8_t			XAxisEndPoint;
+	uint8_t			YAxisStartPoint;
+	uint8_t			YAxisEndPoint;
+	uint8_t			MidPointIntegerPart;
+	uint8_t			MidPointDecimalPart;
+	uint8_t			NCoordinates;
+	PTPNIKONCoordinatePair	CurveCoordinates[PTP_NIKON_MaxCurvePoints];
+};
+
+typedef struct _PTPNIKONCurveData PTPNIKONCurveData;
+
+struct _PTPEKTextParams {
+	char	*title;
+	char	*line[5];
+};
+typedef struct _PTPEKTextParams PTPEKTextParams;
+
+/* Nikon Wifi profiles */
+
+struct _PTPNIKONWifiProfile {
+	/* Values valid both when reading and writing profiles */
+	char      profile_name[17];
+	uint8_t   device_type;
+	uint8_t   icon_type;
+	char      essid[33];
+
+	/* Values only valid when reading. Some of these are in the write packet,
+	 * but are set automatically, like id, display_order and creation_date. */
+	uint8_t   id;
+	uint8_t   valid;
+	uint8_t   display_order;
+	char      creation_date[16];
+	char      lastusage_date[16];
+	
+	/* Values only valid when writing */
+	uint32_t  ip_address;
+	uint8_t   subnet_mask; /* first zero bit position, e.g. 24 for 255.255.255.0 */
+	uint32_t  gateway_address;
+	uint8_t   address_mode; /* 0 - Manual, 2-3 -  DHCP ad-hoc/managed*/
+	uint8_t   access_mode; /* 0 - Managed, 1 - Adhoc */
+	uint8_t   wifi_channel; /* 1-11 */
+	uint8_t   authentification; /* 0 - Open, 1 - Shared, 2 - WPA-PSK */
+	uint8_t   encryption; /* 0 - None, 1 - WEP 64bit, 2 - WEP 128bit (not supported: 3 - TKIP) */
+	uint8_t   key[64];
+	uint8_t   key_nr;
+/*	char      guid[16]; */
+};
+
+typedef struct _PTPNIKONWifiProfile PTPNIKONWifiProfile;
+
+#define PTP_CANON_EOS_CHANGES_TYPE_UNKNOWN		0
+#define PTP_CANON_EOS_CHANGES_TYPE_OBJECTINFO		1
+#define PTP_CANON_EOS_CHANGES_TYPE_OBJECTTRANSFER	2
+#define PTP_CANON_EOS_CHANGES_TYPE_PROPERTY		3
+#define PTP_CANON_EOS_CHANGES_TYPE_CAMERASTATUS		4
+#define PTP_CANON_EOS_CHANGES_TYPE_FOCUSINFO		5
+#define PTP_CANON_EOS_CHANGES_TYPE_FOCUSMASK		6
+
+struct _PTPCanon_New_Object {
+	uint32_t	oid;
+	PTPObjectInfo	oi;
+};
+
+struct _PTPCanon_changes_entry {
+	int	type;
+	union {
+		struct _PTPCanon_New_Object	object;	/* TYPE_OBJECTINFO */
+		char				*info;
+		uint16_t			propid;
+		int				status;
+	} u;
+};
+typedef struct _PTPCanon_changes_entry PTPCanon_changes_entry;
+
+typedef struct _PTPCanon_Property {
+	uint32_t		size;
+	uint32_t		proptype;
+	unsigned char		*data;
+
+	/* fill out for queries */
+	PTPDevicePropDesc	dpd;
+} PTPCanon_Property;
+
+typedef struct _PTPCanonEOSDeviceInfo {
+	/* length */
+	uint32_t EventsSupported_len;
+	uint32_t *EventsSupported;
+
+	uint32_t DevicePropertiesSupported_len;
+	uint32_t *DevicePropertiesSupported;
+
+	uint32_t unk_len;
+	uint32_t *unk;
+} PTPCanonEOSDeviceInfo;
+
+/* DataType Codes */
+
+#define PTP_DTC_UNDEF		0x0000
+#define PTP_DTC_INT8		0x0001
+#define PTP_DTC_UINT8		0x0002
+#define PTP_DTC_INT16		0x0003
+#define PTP_DTC_UINT16		0x0004
+#define PTP_DTC_INT32		0x0005
+#define PTP_DTC_UINT32		0x0006
+#define PTP_DTC_INT64		0x0007
+#define PTP_DTC_UINT64		0x0008
+#define PTP_DTC_INT128		0x0009
+#define PTP_DTC_UINT128		0x000A
+
+#define PTP_DTC_ARRAY_MASK	0x4000
+
+#define PTP_DTC_AINT8		(PTP_DTC_ARRAY_MASK | PTP_DTC_INT8)
+#define PTP_DTC_AUINT8		(PTP_DTC_ARRAY_MASK | PTP_DTC_UINT8)
+#define PTP_DTC_AINT16		(PTP_DTC_ARRAY_MASK | PTP_DTC_INT16)
+#define PTP_DTC_AUINT16		(PTP_DTC_ARRAY_MASK | PTP_DTC_UINT16)
+#define PTP_DTC_AINT32		(PTP_DTC_ARRAY_MASK | PTP_DTC_INT32)
+#define PTP_DTC_AUINT32		(PTP_DTC_ARRAY_MASK | PTP_DTC_UINT32)
+#define PTP_DTC_AINT64		(PTP_DTC_ARRAY_MASK | PTP_DTC_INT64)
+#define PTP_DTC_AUINT64		(PTP_DTC_ARRAY_MASK | PTP_DTC_UINT64)
+#define PTP_DTC_AINT128		(PTP_DTC_ARRAY_MASK | PTP_DTC_INT128)
+#define PTP_DTC_AUINT128	(PTP_DTC_ARRAY_MASK | PTP_DTC_UINT128)
+
+#define PTP_DTC_STR		0xFFFF
+
+/* Device Properties Codes */
+
+/* PTP v1.0 property codes */
+#define PTP_DPC_Undefined		0x5000
+#define PTP_DPC_BatteryLevel		0x5001
+#define PTP_DPC_FunctionalMode		0x5002
+#define PTP_DPC_ImageSize		0x5003
+#define PTP_DPC_CompressionSetting	0x5004
+#define PTP_DPC_WhiteBalance		0x5005
+#define PTP_DPC_RGBGain			0x5006
+#define PTP_DPC_FNumber			0x5007
+#define PTP_DPC_FocalLength		0x5008
+#define PTP_DPC_FocusDistance		0x5009
+#define PTP_DPC_FocusMode		0x500A
+#define PTP_DPC_ExposureMeteringMode	0x500B
+#define PTP_DPC_FlashMode		0x500C
+#define PTP_DPC_ExposureTime		0x500D
+#define PTP_DPC_ExposureProgramMode	0x500E
+#define PTP_DPC_ExposureIndex		0x500F
+#define PTP_DPC_ExposureBiasCompensation	0x5010
+#define PTP_DPC_DateTime		0x5011
+#define PTP_DPC_CaptureDelay		0x5012
+#define PTP_DPC_StillCaptureMode	0x5013
+#define PTP_DPC_Contrast		0x5014
+#define PTP_DPC_Sharpness		0x5015
+#define PTP_DPC_DigitalZoom		0x5016
+#define PTP_DPC_EffectMode		0x5017
+#define PTP_DPC_BurstNumber		0x5018
+#define PTP_DPC_BurstInterval		0x5019
+#define PTP_DPC_TimelapseNumber		0x501A
+#define PTP_DPC_TimelapseInterval	0x501B
+#define PTP_DPC_FocusMeteringMode	0x501C
+#define PTP_DPC_UploadURL		0x501D
+#define PTP_DPC_Artist			0x501E
+#define PTP_DPC_CopyrightInfo		0x501F
+/* PTP v1.1 property codes */
+#define PTP_DPC_SupportedStreams	0x5020
+#define PTP_DPC_EnabledStreams		0x5021
+#define PTP_DPC_VideoFormat		0x5022
+#define PTP_DPC_VideoResolution		0x5023
+#define PTP_DPC_VideoQuality		0x5024
+#define PTP_DPC_VideoFrameRate		0x5025
+#define PTP_DPC_VideoContrast		0x5026
+#define PTP_DPC_VideoBrightness		0x5027
+#define PTP_DPC_AudioFormat		0x5028
+#define PTP_DPC_AudioBitrate		0x5029
+#define PTP_DPC_AudioSamplingRate	0x502A
+#define PTP_DPC_AudioBitPerSample	0x502B
+#define PTP_DPC_AudioVolume		0x502C
+
+/* Proprietary vendor extension device property mask */
+#define PTP_DPC_EXTENSION_MASK		0xF000
+#define PTP_DPC_EXTENSION		0xD000
+
+/* Zune extension device property codes */
+#define PTP_DPC_MTP_ZUNE_UNKNOWN1	0xD181
+#define PTP_DPC_MTP_ZUNE_UNKNOWN2	0xD132
+#define PTP_DPC_MTP_ZUNE_UNKNOWN3	0xD215
+#define PTP_DPC_MTP_ZUNE_UNKNOWN4	0xD216
+
+/* Eastman Kodak extension device property codes */
+#define PTP_DPC_EK_ColorTemperature	0xD001
+#define PTP_DPC_EK_DateTimeStampFormat	0xD002
+#define PTP_DPC_EK_BeepMode		0xD003
+#define PTP_DPC_EK_VideoOut		0xD004
+#define PTP_DPC_EK_PowerSaving		0xD005
+#define PTP_DPC_EK_UI_Language		0xD006
+
+/* Canon extension device property codes */
+#define PTP_DPC_CANON_BeepMode		0xD001
+#define PTP_DPC_CANON_BatteryKind	0xD002
+#define PTP_DPC_CANON_BatteryStatus	0xD003
+#define PTP_DPC_CANON_UILockType	0xD004
+#define PTP_DPC_CANON_CameraMode	0xD005
+#define PTP_DPC_CANON_ImageQuality	0xD006
+#define PTP_DPC_CANON_FullViewFileFormat 0xD007
+#define PTP_DPC_CANON_ImageSize		0xD008
+#define PTP_DPC_CANON_SelfTime		0xD009
+#define PTP_DPC_CANON_FlashMode		0xD00A
+#define PTP_DPC_CANON_Beep		0xD00B
+#define PTP_DPC_CANON_ShootingMode	0xD00C
+#define PTP_DPC_CANON_ImageMode		0xD00D
+#define PTP_DPC_CANON_DriveMode		0xD00E
+#define PTP_DPC_CANON_EZoom		0xD00F
+#define PTP_DPC_CANON_MeteringMode	0xD010
+#define PTP_DPC_CANON_AFDistance	0xD011
+#define PTP_DPC_CANON_FocusingPoint	0xD012
+#define PTP_DPC_CANON_WhiteBalance	0xD013
+#define PTP_DPC_CANON_SlowShutterSetting	0xD014
+#define PTP_DPC_CANON_AFMode		0xD015
+#define PTP_DPC_CANON_ImageStabilization	0xD016
+#define PTP_DPC_CANON_Contrast		0xD017
+#define PTP_DPC_CANON_ColorGain		0xD018
+#define PTP_DPC_CANON_Sharpness		0xD019
+#define PTP_DPC_CANON_Sensitivity	0xD01A
+#define PTP_DPC_CANON_ParameterSet	0xD01B
+#define PTP_DPC_CANON_ISOSpeed		0xD01C
+#define PTP_DPC_CANON_Aperture		0xD01D
+#define PTP_DPC_CANON_ShutterSpeed	0xD01E
+#define PTP_DPC_CANON_ExpCompensation	0xD01F
+#define PTP_DPC_CANON_FlashCompensation	0xD020
+#define PTP_DPC_CANON_AEBExposureCompensation	0xD021
+#define PTP_DPC_CANON_AvOpen		0xD023
+#define PTP_DPC_CANON_AvMax		0xD024
+#define PTP_DPC_CANON_FocalLength	0xD025
+#define PTP_DPC_CANON_FocalLengthTele	0xD026
+#define PTP_DPC_CANON_FocalLengthWide	0xD027
+#define PTP_DPC_CANON_FocalLengthDenominator	0xD028
+#define PTP_DPC_CANON_CaptureTransferMode	0xD029
+#define CANON_TRANSFER_ENTIRE_IMAGE_TO_PC	0x0002
+#define CANON_TRANSFER_SAVE_THUMBNAIL_TO_DEVICE	0x0004
+#define CANON_TRANSFER_SAVE_IMAGE_TO_DEVICE	0x0008
+/* we use those values: */
+#define CANON_TRANSFER_MEMORY		(2|1)
+#define CANON_TRANSFER_CARD		(8|4|1)
+
+#define PTP_DPC_CANON_Zoom		0xD02A
+#define PTP_DPC_CANON_NamePrefix	0xD02B
+#define PTP_DPC_CANON_SizeQualityMode	0xD02C
+#define PTP_DPC_CANON_SupportedThumbSize	0xD02D
+#define PTP_DPC_CANON_SizeOfOutputDataFromCamera	0xD02E
+#define PTP_DPC_CANON_SizeOfInputDataToCamera		0xD02F
+#define PTP_DPC_CANON_RemoteAPIVersion	0xD030
+#define PTP_DPC_CANON_FirmwareVersion	0xD031
+#define PTP_DPC_CANON_CameraModel	0xD032
+#define PTP_DPC_CANON_CameraOwner	0xD033
+#define PTP_DPC_CANON_UnixTime		0xD034
+#define PTP_DPC_CANON_CameraBodyID	0xD035
+#define PTP_DPC_CANON_CameraOutput	0xD036
+#define PTP_DPC_CANON_DispAv		0xD037
+#define PTP_DPC_CANON_AvOpenApex	0xD038
+#define PTP_DPC_CANON_DZoomMagnification	0xD039
+#define PTP_DPC_CANON_MlSpotPos		0xD03A
+#define PTP_DPC_CANON_DispAvMax		0xD03B
+#define PTP_DPC_CANON_AvMaxApex		0xD03C
+#define PTP_DPC_CANON_EZoomStartPosition		0xD03D
+#define PTP_DPC_CANON_FocalLengthOfTele	0xD03E
+#define PTP_DPC_CANON_EZoomSizeOfTele	0xD03F
+#define PTP_DPC_CANON_PhotoEffect	0xD040
+#define PTP_DPC_CANON_AssistLight	0xD041
+#define PTP_DPC_CANON_FlashQuantityCount	0xD042
+#define PTP_DPC_CANON_RotationAngle	0xD043
+#define PTP_DPC_CANON_RotationScene	0xD044
+#define PTP_DPC_CANON_EventEmulateMode	0xD045
+#define PTP_DPC_CANON_DPOFVersion	0xD046
+#define PTP_DPC_CANON_TypeOfSupportedSlideShow	0xD047
+#define PTP_DPC_CANON_AverageFilesizes	0xD048
+#define PTP_DPC_CANON_ModelID		0xD049
+
+/* From EOS 400D trace. */
+#define PTP_DPC_CANON_EOS_Aperture		0xD101
+#define PTP_DPC_CANON_EOS_ShutterSpeed		0xD102
+#define PTP_DPC_CANON_EOS_ISOSpeed		0xD103
+#define PTP_DPC_CANON_EOS_ExpCompensation	0xD104
+#define PTP_DPC_CANON_EOS_AutoExposureMode	0xD105
+#define PTP_DPC_CANON_EOS_DriveMode		0xD106
+#define PTP_DPC_CANON_EOS_MeteringMode		0xD107
+#define PTP_DPC_CANON_EOS_FocusMode		0xD108
+#define PTP_DPC_CANON_EOS_WhiteBalance		0xD109
+#define PTP_DPC_CANON_EOS_ColorTemperature	0xD10A
+#define PTP_DPC_CANON_EOS_WhiteBalanceAdjustA	0xD10B
+#define PTP_DPC_CANON_EOS_WhiteBalanceAdjustB	0xD10C
+#define PTP_DPC_CANON_EOS_WhiteBalanceXA	0xD10D
+#define PTP_DPC_CANON_EOS_WhiteBalanceXB	0xD10E
+#define PTP_DPC_CANON_EOS_ColorSpace		0xD10F
+#define PTP_DPC_CANON_EOS_PictureStyle		0xD110
+#define PTP_DPC_CANON_EOS_BatteryPower		0xD111
+#define PTP_DPC_CANON_EOS_BatterySelect		0xD112
+#define PTP_DPC_CANON_EOS_CameraTime		0xD113
+#define PTP_DPC_CANON_EOS_AutoPowerOff		0xD114
+#define PTP_DPC_CANON_EOS_Owner			0xD115
+#define PTP_DPC_CANON_EOS_ModelID		0xD116
+#define PTP_DPC_CANON_EOS_PTPExtensionVersion	0xD119
+#define PTP_DPC_CANON_EOS_DPOFVersion		0xD11A
+#define PTP_DPC_CANON_EOS_AvailableShots	0xD11B
+#define PTP_CANON_EOS_CAPTUREDEST_HD		4
+#define PTP_DPC_CANON_EOS_CaptureDestination	0xD11C
+#define PTP_DPC_CANON_EOS_BracketMode		0xD11D
+#define PTP_DPC_CANON_EOS_CurrentStorage	0xD11E
+#define PTP_DPC_CANON_EOS_CurrentFolder		0xD11F
+#define PTP_DPC_CANON_EOS_ImageFormat		0xD120	/* file setting */
+#define PTP_DPC_CANON_EOS_ImageFormatCF		0xD121	/* file setting CF */
+#define PTP_DPC_CANON_EOS_ImageFormatSD		0xD122	/* file setting SD */
+#define PTP_DPC_CANON_EOS_ImageFormatExtHD	0xD123	/* file setting exthd */
+#define PTP_DPC_CANON_EOS_CompressionS		0xD130
+#define PTP_DPC_CANON_EOS_CompressionM1		0xD131
+#define PTP_DPC_CANON_EOS_CompressionM2		0xD132
+#define PTP_DPC_CANON_EOS_CompressionL		0xD133
+#define PTP_DPC_CANON_EOS_AEModeDial		0xD138
+#define PTP_DPC_CANON_EOS_AEModeCustom		0xD139
+#define PTP_DPC_CANON_EOS_MirrorUpSetting	0xD13A
+#define PTP_DPC_CANON_EOS_HighlightTonePriority	0xD13B
+#define PTP_DPC_CANON_EOS_AFSelectFocusArea	0xD13C
+#define PTP_DPC_CANON_EOS_HDRSetting		0xD13D
+#define PTP_DPC_CANON_EOS_PCWhiteBalance1	0xD140
+#define PTP_DPC_CANON_EOS_PCWhiteBalance2	0xD141
+#define PTP_DPC_CANON_EOS_PCWhiteBalance3	0xD142
+#define PTP_DPC_CANON_EOS_PCWhiteBalance4	0xD143
+#define PTP_DPC_CANON_EOS_PCWhiteBalance5	0xD144
+#define PTP_DPC_CANON_EOS_MWhiteBalance		0xD145
+#define PTP_DPC_CANON_EOS_MWhiteBalanceEx	0xD146
+#define PTP_DPC_CANON_EOS_UnknownPropD14D	0xD14D  /*found in Canon EOS 5D M3*/
+#define PTP_DPC_CANON_EOS_PictureStyleStandard	0xD150
+#define PTP_DPC_CANON_EOS_PictureStylePortrait	0xD151
+#define PTP_DPC_CANON_EOS_PictureStyleLandscape	0xD152
+#define PTP_DPC_CANON_EOS_PictureStyleNeutral	0xD153
+#define PTP_DPC_CANON_EOS_PictureStyleFaithful	0xD154
+#define PTP_DPC_CANON_EOS_PictureStyleBlackWhite	0xD155
+#define PTP_DPC_CANON_EOS_PictureStyleAuto	0xD156
+#define PTP_DPC_CANON_EOS_PictureStyleUserSet1	0xD160
+#define PTP_DPC_CANON_EOS_PictureStyleUserSet2	0xD161
+#define PTP_DPC_CANON_EOS_PictureStyleUserSet3	0xD162
+#define PTP_DPC_CANON_EOS_PictureStyleParam1	0xD170
+#define PTP_DPC_CANON_EOS_PictureStyleParam2	0xD171
+#define PTP_DPC_CANON_EOS_PictureStyleParam3	0xD172
+#define PTP_DPC_CANON_EOS_HighISOSettingNoiseReduction	0xD178
+#define PTP_DPC_CANON_EOS_MovieServoAF		0xD179
+#define PTP_DPC_CANON_EOS_ContinuousAFValid	0xD17A
+#define PTP_DPC_CANON_EOS_Attenuator		0xD17B
+#define PTP_DPC_CANON_EOS_UTCTime		0xD17C
+#define PTP_DPC_CANON_EOS_Timezone		0xD17D
+#define PTP_DPC_CANON_EOS_Summertime		0xD17E
+#define PTP_DPC_CANON_EOS_FlavorLUTParams	0xD17F
+#define PTP_DPC_CANON_EOS_CustomFunc1		0xD180
+#define PTP_DPC_CANON_EOS_CustomFunc2		0xD181
+#define PTP_DPC_CANON_EOS_CustomFunc3		0xD182
+#define PTP_DPC_CANON_EOS_CustomFunc4		0xD183
+#define PTP_DPC_CANON_EOS_CustomFunc5		0xD184
+#define PTP_DPC_CANON_EOS_CustomFunc6		0xD185
+#define PTP_DPC_CANON_EOS_CustomFunc7		0xD186
+#define PTP_DPC_CANON_EOS_CustomFunc8		0xD187
+#define PTP_DPC_CANON_EOS_CustomFunc9		0xD188
+#define PTP_DPC_CANON_EOS_CustomFunc10		0xD189
+#define PTP_DPC_CANON_EOS_CustomFunc11		0xD18a
+#define PTP_DPC_CANON_EOS_CustomFunc12		0xD18b
+#define PTP_DPC_CANON_EOS_CustomFunc13		0xD18c
+#define PTP_DPC_CANON_EOS_CustomFunc14		0xD18d
+#define PTP_DPC_CANON_EOS_CustomFunc15		0xD18e
+#define PTP_DPC_CANON_EOS_CustomFunc16		0xD18f
+#define PTP_DPC_CANON_EOS_CustomFunc17		0xD190
+#define PTP_DPC_CANON_EOS_CustomFunc18		0xD191
+#define PTP_DPC_CANON_EOS_CustomFunc19		0xD192
+#define PTP_DPC_CANON_EOS_CustomFunc19		0xD192
+#define PTP_DPC_CANON_EOS_InnerDevelop		0xD193
+#define PTP_DPC_CANON_EOS_MultiAspect		0xD194
+#define PTP_DPC_CANON_EOS_MovieSoundRecord	0xD195
+#define PTP_DPC_CANON_EOS_MovieRecordVolume	0xD196
+#define PTP_DPC_CANON_EOS_WindCut		0xD197
+#define PTP_DPC_CANON_EOS_ExtenderType		0xD198
+#define PTP_DPC_CANON_EOS_OLCInfoVersion	0xD199
+#define PTP_DPC_CANON_EOS_UnknownPropD19A	0xD19A /*found in Canon EOS 5D M3*/
+#define PTP_DPC_CANON_EOS_UnknownPropD19C	0xD19C /*found in Canon EOS 5D M3*/
+#define PTP_DPC_CANON_EOS_UnknownPropD19D	0xD19D /*found in Canon EOS 5D M3*/
+#define PTP_DPC_CANON_EOS_CustomFuncEx		0xD1a0
+#define PTP_DPC_CANON_EOS_MyMenu		0xD1a1
+#define PTP_DPC_CANON_EOS_MyMenuList		0xD1a2
+#define PTP_DPC_CANON_EOS_WftStatus		0xD1a3
+#define PTP_DPC_CANON_EOS_WftInputTransmission	0xD1a4
+#define PTP_DPC_CANON_EOS_HDDirectoryStructure	0xD1a5
+#define PTP_DPC_CANON_EOS_BatteryInfo		0xD1a6
+#define PTP_DPC_CANON_EOS_AdapterInfo		0xD1a7
+#define PTP_DPC_CANON_EOS_LensStatus		0xD1a8
+#define PTP_DPC_CANON_EOS_QuickReviewTime	0xD1a9
+#define PTP_DPC_CANON_EOS_CardExtension		0xD1aa
+#define PTP_DPC_CANON_EOS_TempStatus		0xD1ab
+#define PTP_DPC_CANON_EOS_ShutterCounter	0xD1ac
+#define PTP_DPC_CANON_EOS_SpecialOption		0xD1ad
+#define PTP_DPC_CANON_EOS_PhotoStudioMode	0xD1ae
+#define PTP_DPC_CANON_EOS_SerialNumber		0xD1af
+#define PTP_DPC_CANON_EOS_EVFOutputDevice	0xD1b0
+#define PTP_DPC_CANON_EOS_EVFMode		0xD1b1
+#define PTP_DPC_CANON_EOS_DepthOfFieldPreview	0xD1b2
+#define PTP_DPC_CANON_EOS_EVFSharpness		0xD1b3
+#define PTP_DPC_CANON_EOS_EVFWBMode		0xD1b4
+#define PTP_DPC_CANON_EOS_EVFClickWBCoeffs	0xD1b5
+#define PTP_DPC_CANON_EOS_EVFColorTemp		0xD1b6
+#define PTP_DPC_CANON_EOS_ExposureSimMode	0xD1b7
+#define PTP_DPC_CANON_EOS_EVFRecordStatus	0xD1b8
+#define PTP_DPC_CANON_EOS_LvAfSystem		0xD1ba
+#define PTP_DPC_CANON_EOS_MovSize		0xD1bb
+#define PTP_DPC_CANON_EOS_LvViewTypeSelect	0xD1bc
+#define PTP_DPC_CANON_EOS_MirrorDownStatus	0xD1bd
+#define PTP_DPC_CANON_EOS_MovieParam		0xD1be
+#define PTP_DPC_CANON_EOS_MirrorLockupState	0xD1bf
+#define PTP_DPC_CANON_EOS_FlashChargingState	0xD1C0
+#define PTP_DPC_CANON_EOS_AloMode		0xD1C1
+#define PTP_DPC_CANON_EOS_FixedMovie		0xD1C2
+#define PTP_DPC_CANON_EOS_OneShotRawOn		0xD1C3
+#define PTP_DPC_CANON_EOS_ErrorForDisplay	0xD1C4
+#define PTP_DPC_CANON_EOS_AEModeMovie		0xD1C5
+#define PTP_DPC_CANON_EOS_BuiltinStroboMode	0xD1C6
+#define PTP_DPC_CANON_EOS_StroboDispState	0xD1C7
+#define PTP_DPC_CANON_EOS_StroboETTL2Metering	0xD1C8
+#define PTP_DPC_CANON_EOS_ContinousAFMode	0xD1C9
+#define PTP_DPC_CANON_EOS_MovieParam2		0xD1CA
+#define PTP_DPC_CANON_EOS_StroboSettingExpComposition		0xD1CB
+#define PTP_DPC_CANON_EOS_MovieParam3		0xD1CC
+#define PTP_DPC_CANON_EOS_LVMedicalRotate	0xD1CF
+#define PTP_DPC_CANON_EOS_Artist		0xD1d0
+#define PTP_DPC_CANON_EOS_Copyright		0xD1d1
+#define PTP_DPC_CANON_EOS_BracketValue		0xD1d2
+#define PTP_DPC_CANON_EOS_FocusInfoEx		0xD1d3
+#define PTP_DPC_CANON_EOS_DepthOfField		0xD1d4
+#define PTP_DPC_CANON_EOS_Brightness		0xD1d5
+#define PTP_DPC_CANON_EOS_LensAdjustParams	0xD1d6
+#define PTP_DPC_CANON_EOS_EFComp		0xD1d7
+#define PTP_DPC_CANON_EOS_LensName		0xD1d8
+#define PTP_DPC_CANON_EOS_AEB			0xD1d9
+#define PTP_DPC_CANON_EOS_StroboSetting		0xD1da
+#define PTP_DPC_CANON_EOS_StroboWirelessSetting	0xD1db
+#define PTP_DPC_CANON_EOS_StroboFiring		0xD1dc
+#define PTP_DPC_CANON_EOS_LensID		0xD1dd
+#define PTP_DPC_CANON_EOS_LCDBrightness		0xD1de
+#define PTP_DPC_CANON_EOS_CADarkBright		0xD1df
+
+/* Nikon extension device property codes */
+#define PTP_DPC_NIKON_ShootingBank			0xD010
+#define PTP_DPC_NIKON_ShootingBankNameA 		0xD011
+#define PTP_DPC_NIKON_ShootingBankNameB			0xD012
+#define PTP_DPC_NIKON_ShootingBankNameC			0xD013
+#define PTP_DPC_NIKON_ShootingBankNameD			0xD014
+#define PTP_DPC_NIKON_ResetBank0			0xD015
+#define PTP_DPC_NIKON_RawCompression			0xD016
+#define PTP_DPC_NIKON_WhiteBalanceAutoBias		0xD017
+#define PTP_DPC_NIKON_WhiteBalanceTungstenBias		0xD018
+#define PTP_DPC_NIKON_WhiteBalanceFluorescentBias	0xD019
+#define PTP_DPC_NIKON_WhiteBalanceDaylightBias		0xD01A
+#define PTP_DPC_NIKON_WhiteBalanceFlashBias		0xD01B
+#define PTP_DPC_NIKON_WhiteBalanceCloudyBias		0xD01C
+#define PTP_DPC_NIKON_WhiteBalanceShadeBias		0xD01D
+#define PTP_DPC_NIKON_WhiteBalanceColorTemperature	0xD01E
+#define PTP_DPC_NIKON_WhiteBalancePresetNo		0xD01F
+#define PTP_DPC_NIKON_WhiteBalancePresetName0		0xD020
+#define PTP_DPC_NIKON_WhiteBalancePresetName1		0xD021
+#define PTP_DPC_NIKON_WhiteBalancePresetName2		0xD022
+#define PTP_DPC_NIKON_WhiteBalancePresetName3		0xD023
+#define PTP_DPC_NIKON_WhiteBalancePresetName4		0xD024
+#define PTP_DPC_NIKON_WhiteBalancePresetVal0		0xD025
+#define PTP_DPC_NIKON_WhiteBalancePresetVal1		0xD026
+#define PTP_DPC_NIKON_WhiteBalancePresetVal2		0xD027
+#define PTP_DPC_NIKON_WhiteBalancePresetVal3		0xD028
+#define PTP_DPC_NIKON_WhiteBalancePresetVal4		0xD029
+#define PTP_DPC_NIKON_ImageSharpening			0xD02A
+#define PTP_DPC_NIKON_ToneCompensation			0xD02B
+#define PTP_DPC_NIKON_ColorModel			0xD02C
+#define PTP_DPC_NIKON_HueAdjustment			0xD02D
+#define PTP_DPC_NIKON_NonCPULensDataFocalLength		0xD02E	/* Set FMM Manual */
+#define PTP_DPC_NIKON_NonCPULensDataMaximumAperture	0xD02F	/* Set F0 Manual */
+#define PTP_DPC_NIKON_ShootingMode			0xD030
+#define PTP_DPC_NIKON_JPEG_Compression_Policy		0xD031
+#define PTP_DPC_NIKON_ColorSpace			0xD032
+#define PTP_DPC_NIKON_AutoDXCrop			0xD033
+#define PTP_DPC_NIKON_FlickerReduction			0xD034
+#define PTP_DPC_NIKON_RemoteMode			0xD035
+#define PTP_DPC_NIKON_VideoMode				0xD036
+#define PTP_DPC_NIKON_EffectMode			0xD037
+#define PTP_DPC_NIKON_1_Mode				0xD038
+#define PTP_DPC_NIKON_CSMMenuBankSelect			0xD040
+#define PTP_DPC_NIKON_MenuBankNameA			0xD041
+#define PTP_DPC_NIKON_MenuBankNameB			0xD042
+#define PTP_DPC_NIKON_MenuBankNameC			0xD043
+#define PTP_DPC_NIKON_MenuBankNameD			0xD044
+#define PTP_DPC_NIKON_ResetBank				0xD045
+#define PTP_DPC_NIKON_A1AFCModePriority			0xD048
+#define PTP_DPC_NIKON_A2AFSModePriority			0xD049
+#define PTP_DPC_NIKON_A3GroupDynamicAF			0xD04A
+#define PTP_DPC_NIKON_A4AFActivation			0xD04B
+#define PTP_DPC_NIKON_FocusAreaIllumManualFocus		0xD04C
+#define PTP_DPC_NIKON_FocusAreaIllumContinuous		0xD04D
+#define PTP_DPC_NIKON_FocusAreaIllumWhenSelected 	0xD04E
+#define PTP_DPC_NIKON_FocusAreaWrap			0xD04F /* area sel */
+#define PTP_DPC_NIKON_VerticalAFON			0xD050
+#define PTP_DPC_NIKON_AFLockOn				0xD051
+#define PTP_DPC_NIKON_FocusAreaZone			0xD052
+#define PTP_DPC_NIKON_EnableCopyright			0xD053
+#define PTP_DPC_NIKON_ISOAuto				0xD054
+#define PTP_DPC_NIKON_EVISOStep				0xD055
+#define PTP_DPC_NIKON_EVStep				0xD056 /* EV Step SS FN */
+#define PTP_DPC_NIKON_EVStepExposureComp		0xD057
+#define PTP_DPC_NIKON_ExposureCompensation		0xD058
+#define PTP_DPC_NIKON_CenterWeightArea			0xD059
+#define PTP_DPC_NIKON_ExposureBaseMatrix		0xD05A
+#define PTP_DPC_NIKON_ExposureBaseCenter		0xD05B
+#define PTP_DPC_NIKON_ExposureBaseSpot			0xD05C
+#define PTP_DPC_NIKON_LiveViewAFArea			0xD05D /* FIXME: AfAtLiveview? */
+#define PTP_DPC_NIKON_AELockMode			0xD05E
+#define PTP_DPC_NIKON_AELAFLMode			0xD05F
+#define PTP_DPC_NIKON_LiveViewAFFocus			0xD061
+#define PTP_DPC_NIKON_MeterOff				0xD062
+#define PTP_DPC_NIKON_SelfTimer				0xD063
+#define PTP_DPC_NIKON_MonitorOff			0xD064
+#define PTP_DPC_NIKON_ImgConfTime			0xD065
+#define PTP_DPC_NIKON_AutoOffTimers			0xD066
+#define PTP_DPC_NIKON_AngleLevel			0xD067
+#define PTP_DPC_NIKON_D1ShootingSpeed			0xD068 /* continous speed low */
+#define PTP_DPC_NIKON_D2MaximumShots			0xD069
+#define PTP_DPC_NIKON_ExposureDelayMode			0xD06A
+#define PTP_DPC_NIKON_LongExposureNoiseReduction	0xD06B
+#define PTP_DPC_NIKON_FileNumberSequence		0xD06C
+#define PTP_DPC_NIKON_ControlPanelFinderRearControl	0xD06D
+#define PTP_DPC_NIKON_ControlPanelFinderViewfinder	0xD06E
+#define PTP_DPC_NIKON_D7Illumination			0xD06F
+#define PTP_DPC_NIKON_NrHighISO				0xD070
+#define PTP_DPC_NIKON_SHSET_CH_GUID_DISP		0xD071
+#define PTP_DPC_NIKON_ArtistName			0xD072
+#define PTP_DPC_NIKON_CopyrightInfo			0xD073
+#define PTP_DPC_NIKON_FlashSyncSpeed			0xD074
+#define PTP_DPC_NIKON_FlashShutterSpeed			0xD075	/* SB Low Limit */
+#define PTP_DPC_NIKON_E3AAFlashMode			0xD076
+#define PTP_DPC_NIKON_E4ModelingFlash			0xD077
+#define PTP_DPC_NIKON_BracketSet			0xD078	/* Bracket Type? */
+#define PTP_DPC_NIKON_E6ManualModeBracketing		0xD079	/* Bracket Factor? */
+#define PTP_DPC_NIKON_BracketOrder			0xD07A
+#define PTP_DPC_NIKON_E8AutoBracketSelection		0xD07B	/* Bracket Method? */
+#define PTP_DPC_NIKON_BracketingSet			0xD07C
+#define PTP_DPC_NIKON_F1CenterButtonShootingMode	0xD080
+#define PTP_DPC_NIKON_CenterButtonPlaybackMode		0xD081
+#define PTP_DPC_NIKON_F2Multiselector			0xD082
+#define PTP_DPC_NIKON_F3PhotoInfoPlayback		0xD083	/* MultiSelector Dir */
+#define PTP_DPC_NIKON_F4AssignFuncButton		0xD084  /* CMD Dial Rotate */
+#define PTP_DPC_NIKON_F5CustomizeCommDials		0xD085  /* CMD Dial Change */
+#define PTP_DPC_NIKON_ReverseCommandDial		0xD086  /* CMD Dial FN Set */
+#define PTP_DPC_NIKON_ApertureSetting			0xD087  /* CMD Dial Active */
+#define PTP_DPC_NIKON_MenusAndPlayback			0xD088  /* CMD Dial Active */
+#define PTP_DPC_NIKON_F6ButtonsAndDials			0xD089  /* Universal Mode? */
+#define PTP_DPC_NIKON_NoCFCard				0xD08A	/* Enable Shutter? */
+#define PTP_DPC_NIKON_CenterButtonZoomRatio		0xD08B
+#define PTP_DPC_NIKON_FunctionButton2			0xD08C
+#define PTP_DPC_NIKON_AFAreaPoint			0xD08D
+#define PTP_DPC_NIKON_NormalAFOn			0xD08E
+#define PTP_DPC_NIKON_CleanImageSensor			0xD08F
+#define PTP_DPC_NIKON_ImageCommentString		0xD090
+#define PTP_DPC_NIKON_ImageCommentEnable		0xD091
+#define PTP_DPC_NIKON_ImageRotation			0xD092
+#define PTP_DPC_NIKON_ManualSetLensNo			0xD093
+#define PTP_DPC_NIKON_MovScreenSize			0xD0A0
+#define PTP_DPC_NIKON_MovVoice				0xD0A1
+#define PTP_DPC_NIKON_MovMicrophone			0xD0A2
+#define PTP_DPC_NIKON_MovFileSlot			0xD0A3
+#define PTP_DPC_NIKON_MovRecProhibitCondition		0xD0A4
+#define PTP_DPC_NIKON_ManualMovieSetting		0xD0A6
+#define PTP_DPC_NIKON_MovQuality			0xD0A7
+#define PTP_DPC_NIKON_LiveViewScreenDisplaySetting	0xD0B2
+#define PTP_DPC_NIKON_MonitorOffDelay			0xD0B3
+#define PTP_DPC_NIKON_Bracketing			0xD0C0
+#define PTP_DPC_NIKON_AutoExposureBracketStep		0xD0C1
+#define PTP_DPC_NIKON_AutoExposureBracketProgram	0xD0C2
+#define PTP_DPC_NIKON_AutoExposureBracketCount		0xD0C3
+#define PTP_DPC_NIKON_WhiteBalanceBracketStep		0xD0C4
+#define PTP_DPC_NIKON_WhiteBalanceBracketProgram	0xD0C5
+#define PTP_DPC_NIKON_LensID				0xD0E0
+#define PTP_DPC_NIKON_LensSort				0xD0E1
+#define PTP_DPC_NIKON_LensType				0xD0E2
+#define PTP_DPC_NIKON_FocalLengthMin			0xD0E3
+#define PTP_DPC_NIKON_FocalLengthMax			0xD0E4
+#define PTP_DPC_NIKON_MaxApAtMinFocalLength		0xD0E5
+#define PTP_DPC_NIKON_MaxApAtMaxFocalLength		0xD0E6
+#define PTP_DPC_NIKON_FinderISODisp			0xD0F0
+#define PTP_DPC_NIKON_AutoOffPhoto			0xD0F2
+#define PTP_DPC_NIKON_AutoOffMenu			0xD0F3
+#define PTP_DPC_NIKON_AutoOffInfo			0xD0F4
+#define PTP_DPC_NIKON_SelfTimerShootNum			0xD0F5
+#define PTP_DPC_NIKON_VignetteCtrl			0xD0F7
+#define PTP_DPC_NIKON_AutoDistortionControl		0xD0F8
+#define PTP_DPC_NIKON_SceneMode				0xD0F9
+#define PTP_DPC_NIKON_SceneMode2			0xD0FD
+#define PTP_DPC_NIKON_SelfTimerInterval			0xD0FE
+#define PTP_DPC_NIKON_ExposureTime			0xD100	/* Shutter Speed */
+#define PTP_DPC_NIKON_ACPower				0xD101
+#define PTP_DPC_NIKON_WarningStatus			0xD102
+#define PTP_DPC_NIKON_MaximumShots			0xD103 /* remain shots (in RAM buffer?) */
+#define PTP_DPC_NIKON_AFLockStatus			0xD104
+#define PTP_DPC_NIKON_AELockStatus			0xD105
+#define PTP_DPC_NIKON_FVLockStatus			0xD106
+#define PTP_DPC_NIKON_AutofocusLCDTopMode2		0xD107
+#define PTP_DPC_NIKON_AutofocusArea			0xD108
+#define PTP_DPC_NIKON_FlexibleProgram			0xD109
+#define PTP_DPC_NIKON_LightMeter			0xD10A	/* Exposure Status */
+#define PTP_DPC_NIKON_RecordingMedia			0xD10B	/* Card or SDRAM */
+#define PTP_DPC_NIKON_USBSpeed				0xD10C
+#define PTP_DPC_NIKON_CCDNumber				0xD10D
+#define PTP_DPC_NIKON_CameraOrientation			0xD10E
+#define PTP_DPC_NIKON_GroupPtnType			0xD10F
+#define PTP_DPC_NIKON_FNumberLock			0xD110
+#define PTP_DPC_NIKON_ExposureApertureLock		0xD111	/* shutterspeed lock*/
+#define PTP_DPC_NIKON_TVLockSetting			0xD112
+#define PTP_DPC_NIKON_AVLockSetting			0xD113
+#define PTP_DPC_NIKON_IllumSetting			0xD114
+#define PTP_DPC_NIKON_FocusPointBright			0xD115
+#define PTP_DPC_NIKON_ExternalFlashAttached		0xD120
+#define PTP_DPC_NIKON_ExternalFlashStatus		0xD121
+#define PTP_DPC_NIKON_ExternalFlashSort			0xD122
+#define PTP_DPC_NIKON_ExternalFlashMode			0xD123
+#define PTP_DPC_NIKON_ExternalFlashCompensation		0xD124
+#define PTP_DPC_NIKON_NewExternalFlashMode		0xD125
+#define PTP_DPC_NIKON_FlashExposureCompensation		0xD126
+#define PTP_DPC_NIKON_HDRMode				0xD130
+#define PTP_DPC_NIKON_HDRHighDynamic			0xD131
+#define PTP_DPC_NIKON_HDRSmoothing			0xD132
+#define PTP_DPC_NIKON_OptimizeImage			0xD140
+#define PTP_DPC_NIKON_Saturation			0xD142
+#define PTP_DPC_NIKON_BW_FillerEffect			0xD143
+#define PTP_DPC_NIKON_BW_Sharpness			0xD144
+#define PTP_DPC_NIKON_BW_Contrast			0xD145
+#define PTP_DPC_NIKON_BW_Setting_Type			0xD146
+#define PTP_DPC_NIKON_Slot2SaveMode			0xD148
+#define PTP_DPC_NIKON_RawBitMode			0xD149
+#define PTP_DPC_NIKON_ActiveDLighting			0xD14E /* was PTP_DPC_NIKON_ISOAutoTime */
+#define PTP_DPC_NIKON_FlourescentType			0xD14F
+#define PTP_DPC_NIKON_TuneColourTemperature		0xD150
+#define PTP_DPC_NIKON_TunePreset0			0xD151
+#define PTP_DPC_NIKON_TunePreset1			0xD152
+#define PTP_DPC_NIKON_TunePreset2			0xD153
+#define PTP_DPC_NIKON_TunePreset3			0xD154
+#define PTP_DPC_NIKON_TunePreset4			0xD155
+#define PTP_DPC_NIKON_BeepOff				0xD160
+#define PTP_DPC_NIKON_AutofocusMode			0xD161
+#define PTP_DPC_NIKON_AFAssist				0xD163
+#define PTP_DPC_NIKON_PADVPMode				0xD164	/* iso auto time */
+#define PTP_DPC_NIKON_ImageReview			0xD165
+#define PTP_DPC_NIKON_AFAreaIllumination		0xD166
+#define PTP_DPC_NIKON_FlashMode				0xD167
+#define PTP_DPC_NIKON_FlashCommanderMode		0xD168
+#define PTP_DPC_NIKON_FlashSign				0xD169
+#define PTP_DPC_NIKON_ISO_Auto				0xD16A
+#define PTP_DPC_NIKON_RemoteTimeout			0xD16B
+#define PTP_DPC_NIKON_GridDisplay			0xD16C
+#define PTP_DPC_NIKON_FlashModeManualPower		0xD16D
+#define PTP_DPC_NIKON_FlashModeCommanderPower		0xD16E
+#define PTP_DPC_NIKON_AutoFP				0xD16F
+#define PTP_DPC_NIKON_DateImprintSetting		0xD170
+#define PTP_DPC_NIKON_DateCounterSelect			0xD171
+#define PTP_DPC_NIKON_DateCountData			0xD172
+#define PTP_DPC_NIKON_DateCountDisplaySetting		0xD173
+#define PTP_DPC_NIKON_RangeFinderSetting		0xD174
+#define PTP_DPC_NIKON_CSMMenu				0xD180
+#define PTP_DPC_NIKON_WarningDisplay			0xD181
+#define PTP_DPC_NIKON_BatteryCellKind			0xD182
+#define PTP_DPC_NIKON_ISOAutoHiLimit			0xD183
+#define PTP_DPC_NIKON_DynamicAFArea			0xD184
+#define PTP_DPC_NIKON_ContinuousSpeedHigh		0xD186
+#define PTP_DPC_NIKON_InfoDispSetting			0xD187
+#define PTP_DPC_NIKON_PreviewButton			0xD189
+#define PTP_DPC_NIKON_PreviewButton2			0xD18A
+#define PTP_DPC_NIKON_AEAFLockButton2			0xD18B
+#define PTP_DPC_NIKON_IndicatorDisp			0xD18D
+#define PTP_DPC_NIKON_CellKindPriority			0xD18E
+#define PTP_DPC_NIKON_BracketingFramesAndSteps		0xD190
+#define PTP_DPC_NIKON_LiveViewMode			0xD1A0
+#define PTP_DPC_NIKON_LiveViewDriveMode			0xD1A1
+#define PTP_DPC_NIKON_LiveViewStatus			0xD1A2
+#define PTP_DPC_NIKON_LiveViewImageZoomRatio		0xD1A3
+#define PTP_DPC_NIKON_LiveViewProhibitCondition		0xD1A4
+#define PTP_DPC_NIKON_MovieShutterSpeed			0xD1A8
+#define PTP_DPC_NIKON_MovieFNumber			0xD1A9
+#define PTP_DPC_NIKON_MovieISO				0xD1AA
+#define PTP_DPC_NIKON_LiveViewMovieMode			0xD1AC /* ? */
+#define PTP_DPC_NIKON_ExposureDisplayStatus		0xD1B0
+#define PTP_DPC_NIKON_ExposureIndicateStatus		0xD1B1
+#define PTP_DPC_NIKON_InfoDispErrStatus			0xD1B2
+#define PTP_DPC_NIKON_ExposureIndicateLightup		0xD1B3
+#define PTP_DPC_NIKON_FlashOpen				0xD1C0
+#define PTP_DPC_NIKON_FlashCharged			0xD1C1
+#define PTP_DPC_NIKON_FlashMRepeatValue			0xD1D0
+#define PTP_DPC_NIKON_FlashMRepeatCount			0xD1D1
+#define PTP_DPC_NIKON_FlashMRepeatInterval		0xD1D2
+#define PTP_DPC_NIKON_FlashCommandChannel		0xD1D3
+#define PTP_DPC_NIKON_FlashCommandSelfMode		0xD1D4
+#define PTP_DPC_NIKON_FlashCommandSelfCompensation	0xD1D5
+#define PTP_DPC_NIKON_FlashCommandSelfValue		0xD1D6
+#define PTP_DPC_NIKON_FlashCommandAMode			0xD1D7
+#define PTP_DPC_NIKON_FlashCommandACompensation		0xD1D8
+#define PTP_DPC_NIKON_FlashCommandAValue		0xD1D9
+#define PTP_DPC_NIKON_FlashCommandBMode			0xD1DA
+#define PTP_DPC_NIKON_FlashCommandBCompensation		0xD1DB
+#define PTP_DPC_NIKON_FlashCommandBValue		0xD1DC
+#define PTP_DPC_NIKON_ApplicationMode			0xD1F0
+#define PTP_DPC_NIKON_ActiveSlot			0xD1F2
+#define PTP_DPC_NIKON_ActivePicCtrlItem			0xD200
+#define PTP_DPC_NIKON_ChangePicCtrlItem			0xD201
+#define PTP_DPC_NIKON_MovieNrHighISO			0xD236
+
+
+/* Nikon V1 (or WU adapter?) Trace */
+/* d241 - gets string "Nikon_WU2_0090B5123C61" */
+#define PTP_DPC_NIKON_D241				0xD241
+/* d244 - gets a single byte 0x00 */
+#define PTP_DPC_NIKON_D244				0xD244
+/* d247 - gets 3 bytes 0x01 0x00 0x00 */
+#define PTP_DPC_NIKON_D247				0xD247
+/* S9700 */
+#define PTP_DPC_NIKON_GUID				0xD24F
+/* d250 - gets a string "0000123C61" */
+#define PTP_DPC_NIKON_D250				0xD250
+/* d251 - gets a 0x0100000d */
+#define PTP_DPC_NIKON_D251				0xD251
+
+/* this is irregular, as it should be -0x5000 or 0xD000 based */
+#define PTP_DPC_NIKON_1_ISO				0xF002
+#define PTP_DPC_NIKON_1_ImageCompression		0xF009
+#define PTP_DPC_NIKON_1_ImageSize			0xF00A
+#define PTP_DPC_NIKON_1_WhiteBalance			0xF00C
+#define PTP_DPC_NIKON_1_LongExposureNoiseReduction	0xF00D
+#define PTP_DPC_NIKON_1_HiISONoiseReduction		0xF00E
+#define PTP_DPC_NIKON_1_ActiveDLighting			0xF00F
+#define PTP_DPC_NIKON_1_MovQuality			0xF01C
+
+/* Fuji specific */
+#define PTP_DPC_FUJI_ColorTemperature			0xD017
+#define PTP_DPC_FUJI_Quality				0xD018
+#define PTP_DPC_FUJI_ReleaseMode			0xD201
+#define PTP_DPC_FUJI_FocusAreas				0xD206
+#define PTP_DPC_FUJI_AELock				0xD213
+#define PTP_DPC_FUJI_Aperture				0xD218
+#define PTP_DPC_FUJI_ShutterSpeed			0xD219
+
+/* Microsoft/MTP specific */
+#define PTP_DPC_MTP_SecureTime				0xD101
+#define PTP_DPC_MTP_DeviceCertificate			0xD102
+#define PTP_DPC_MTP_RevocationInfo			0xD103
+#define PTP_DPC_MTP_SynchronizationPartner		0xD401
+#define PTP_DPC_MTP_DeviceFriendlyName			0xD402
+#define PTP_DPC_MTP_VolumeLevel				0xD403
+#define PTP_DPC_MTP_DeviceIcon				0xD405
+#define PTP_DPC_MTP_SessionInitiatorInfo		0xD406
+#define PTP_DPC_MTP_PerceivedDeviceType			0xD407
+#define PTP_DPC_MTP_PlaybackRate                        0xD410
+#define PTP_DPC_MTP_PlaybackObject                      0xD411
+#define PTP_DPC_MTP_PlaybackContainerIndex              0xD412
+#define PTP_DPC_MTP_PlaybackPosition                    0xD413
+#define PTP_DPC_MTP_PlaysForSureID                      0xD131
+
+/* Zune specific property codes */
+#define PTP_DPC_MTP_Zune_UnknownVersion			0xD181
+
+/* Olympus */
+#define PTP_DPC_OLYMPUS_ResolutionMode			0xD102
+#define PTP_DPC_OLYMPUS_FocusPriority			0xD103
+#define PTP_DPC_OLYMPUS_DriveMode			0xD104
+#define PTP_DPC_OLYMPUS_DateTimeFormat			0xD105
+#define PTP_DPC_OLYMPUS_ExposureBiasStep		0xD106
+#define PTP_DPC_OLYMPUS_WBMode				0xD107
+#define PTP_DPC_OLYMPUS_OneTouchWB			0xD108
+#define PTP_DPC_OLYMPUS_ManualWB			0xD109
+#define PTP_DPC_OLYMPUS_ManualWBRBBias			0xD10A
+#define PTP_DPC_OLYMPUS_CustomWB			0xD10B
+#define PTP_DPC_OLYMPUS_CustomWBValue			0xD10C
+#define PTP_DPC_OLYMPUS_ExposureTimeEx			0xD10D
+#define PTP_DPC_OLYMPUS_BulbMode			0xD10E
+#define PTP_DPC_OLYMPUS_AntiMirrorMode			0xD10F
+#define PTP_DPC_OLYMPUS_AEBracketingFrame		0xD110
+#define PTP_DPC_OLYMPUS_AEBracketingStep		0xD111
+#define PTP_DPC_OLYMPUS_WBBracketingFrame		0xD112
+#define PTP_DPC_OLYMPUS_WBBracketingRBFrame		0xD112 /* dup ? */
+#define PTP_DPC_OLYMPUS_WBBracketingRBRange		0xD113
+#define PTP_DPC_OLYMPUS_WBBracketingGMFrame		0xD114
+#define PTP_DPC_OLYMPUS_WBBracketingGMRange		0xD115
+#define PTP_DPC_OLYMPUS_FLBracketingFrame		0xD118
+#define PTP_DPC_OLYMPUS_FLBracketingStep		0xD119
+#define PTP_DPC_OLYMPUS_FlashBiasCompensation		0xD11A
+#define PTP_DPC_OLYMPUS_ManualFocusMode			0xD11B
+#define PTP_DPC_OLYMPUS_RawSaveMode			0xD11D
+#define PTP_DPC_OLYMPUS_AUXLightMode			0xD11E
+#define PTP_DPC_OLYMPUS_LensSinkMode			0xD11F
+#define PTP_DPC_OLYMPUS_BeepStatus			0xD120
+#define PTP_DPC_OLYMPUS_ColorSpace			0xD122
+#define PTP_DPC_OLYMPUS_ColorMatching			0xD123
+#define PTP_DPC_OLYMPUS_Saturation			0xD124
+#define PTP_DPC_OLYMPUS_NoiseReductionPattern		0xD126
+#define PTP_DPC_OLYMPUS_NoiseReductionRandom		0xD127
+#define PTP_DPC_OLYMPUS_ShadingMode			0xD129
+#define PTP_DPC_OLYMPUS_ISOBoostMode			0xD12A
+#define PTP_DPC_OLYMPUS_ExposureIndexBiasStep		0xD12B
+#define PTP_DPC_OLYMPUS_FilterEffect			0xD12C
+#define PTP_DPC_OLYMPUS_ColorTune			0xD12D
+#define PTP_DPC_OLYMPUS_Language			0xD12E
+#define PTP_DPC_OLYMPUS_LanguageCode			0xD12F
+#define PTP_DPC_OLYMPUS_RecviewMode			0xD130
+#define PTP_DPC_OLYMPUS_SleepTime			0xD131
+#define PTP_DPC_OLYMPUS_ManualWBGMBias			0xD132
+#define PTP_DPC_OLYMPUS_AELAFLMode			0xD135
+#define PTP_DPC_OLYMPUS_AELButtonStatus			0xD136
+#define PTP_DPC_OLYMPUS_CompressionSettingEx		0xD137
+#define PTP_DPC_OLYMPUS_ToneMode			0xD139
+#define PTP_DPC_OLYMPUS_GradationMode			0xD13A
+#define PTP_DPC_OLYMPUS_DevelopMode			0xD13B
+#define PTP_DPC_OLYMPUS_ExtendInnerFlashMode		0xD13C
+#define PTP_DPC_OLYMPUS_OutputDeviceMode		0xD13D
+#define PTP_DPC_OLYMPUS_LiveViewMode			0xD13E
+#define PTP_DPC_OLYMPUS_LCDBacklight			0xD140
+#define PTP_DPC_OLYMPUS_CustomDevelop			0xD141
+#define PTP_DPC_OLYMPUS_GradationAutoBias		0xD142
+#define PTP_DPC_OLYMPUS_FlashRCMode			0xD143
+#define PTP_DPC_OLYMPUS_FlashRCGroupValue		0xD144
+#define PTP_DPC_OLYMPUS_FlashRCChannelValue		0xD145
+#define PTP_DPC_OLYMPUS_FlashRCFPMode			0xD146
+#define PTP_DPC_OLYMPUS_FlashRCPhotoChromicMode		0xD147
+#define PTP_DPC_OLYMPUS_FlashRCPhotoChromicBias		0xD148
+#define PTP_DPC_OLYMPUS_FlashRCPhotoChromicManualBias	0xD149
+#define PTP_DPC_OLYMPUS_FlashRCQuantityLightLevel	0xD14A
+#define PTP_DPC_OLYMPUS_FocusMeteringValue		0xD14B
+#define PTP_DPC_OLYMPUS_ISOBracketingFrame		0xD14C
+#define PTP_DPC_OLYMPUS_ISOBracketingStep		0xD14D
+#define PTP_DPC_OLYMPUS_BulbMFMode			0xD14E
+#define PTP_DPC_OLYMPUS_BurstFPSValue			0xD14F
+#define PTP_DPC_OLYMPUS_ISOAutoBaseValue		0xD150
+#define PTP_DPC_OLYMPUS_ISOAutoMaxValue			0xD151
+#define PTP_DPC_OLYMPUS_BulbLimiterValue		0xD152
+#define PTP_DPC_OLYMPUS_DPIMode				0xD153
+#define PTP_DPC_OLYMPUS_DPICustomValue			0xD154
+#define PTP_DPC_OLYMPUS_ResolutionValueSetting		0xD155
+#define PTP_DPC_OLYMPUS_AFTargetSize			0xD157
+#define PTP_DPC_OLYMPUS_LightSensorMode			0xD158
+#define PTP_DPC_OLYMPUS_AEBracket			0xD159
+#define PTP_DPC_OLYMPUS_WBRBBracket			0xD15A
+#define PTP_DPC_OLYMPUS_WBGMBracket			0xD15B
+#define PTP_DPC_OLYMPUS_FlashBracket			0xD15C
+#define PTP_DPC_OLYMPUS_ISOBracket			0xD15D
+#define PTP_DPC_OLYMPUS_MyModeStatus			0xD15E
+
+/* Sony A900 */
+#define PTP_DPC_SONY_DPCCompensation			0xD200
+#define PTP_DPC_SONY_DRangeOptimize			0xD201
+#define PTP_DPC_SONY_ImageSize				0xD203
+#define PTP_DPC_SONY_ShutterSpeed			0xD20D
+#define PTP_DPC_SONY_ColorTemp				0xD20F
+#define PTP_DPC_SONY_CCFilter				0xD210
+#define PTP_DPC_SONY_AspectRatio			0xD211
+#define PTP_DPC_SONY_ExposeIndex			0xD216
+#define PTP_DPC_SONY_PictureEffect			0xD21B
+#define PTP_DPC_SONY_ABFilter				0xD21C
+#define PTP_DPC_SONY_ISO				0xD21E /* ? */
+/* also seen: D2C3 D2C4 */
+/* semi control opcodes */
+#define PTP_DPC_SONY_Movie				0xD2C8 /* ? */
+#define PTP_DPC_SONY_StillImage				0xD2C7 /* ? */
+
+
+
+/* Casio EX-F1 */
+#define PTP_DPC_CASIO_MONITOR		0xD001 
+#define PTP_DPC_CASIO_STORAGE		0xD002 //Not reported by DeviceInfo?
+#define PTP_DPC_CASIO_UNKNOWN_1		0xD004
+#define PTP_DPC_CASIO_UNKNOWN_2		0xD005
+#define PTP_DPC_CASIO_UNKNOWN_3		0xD007
+#define PTP_DPC_CASIO_RECORD_LIGHT	0xD008
+#define PTP_DPC_CASIO_UNKNOWN_4		0xD009
+#define PTP_DPC_CASIO_UNKNOWN_5		0xD00A
+#define PTP_DPC_CASIO_MOVIE_MODE	0xD00B
+#define PTP_DPC_CASIO_HD_SETTING	0xD00C
+#define PTP_DPC_CASIO_HS_SETTING	0xD00D
+#define PTP_DPC_CASIO_CS_HIGH_SPEED	0xD00F
+#define PTP_DPC_CASIO_CS_UPPER_LIMIT	0xD010
+#define PTP_DPC_CASIO_CS_SHOT		0xD011
+#define PTP_DPC_CASIO_UNKNOWN_6		0xD012
+#define PTP_DPC_CASIO_UNKNOWN_7		0xD013
+#define PTP_DPC_CASIO_UNKNOWN_8		0xD015
+#define PTP_DPC_CASIO_UNKNOWN_9		0xD017
+#define PTP_DPC_CASIO_UNKNOWN_10	0xD018
+#define PTP_DPC_CASIO_UNKNOWN_11	0xD019
+#define PTP_DPC_CASIO_UNKNOWN_12	0xD01A
+#define PTP_DPC_CASIO_UNKNOWN_13	0xD01B
+#define PTP_DPC_CASIO_UNKNOWN_14	0xD01C
+#define PTP_DPC_CASIO_UNKNOWN_15	0xD01D
+#define PTP_DPC_CASIO_UNKNOWN_16	0xD020
+#define PTP_DPC_CASIO_UNKNOWN_17	0xD030
+#define PTP_DPC_CASIO_UNKNOWN_18	0xD080
+
+/* MTP specific Object Properties */
+#define PTP_OPC_StorageID				0xDC01
+#define PTP_OPC_ObjectFormat				0xDC02
+#define PTP_OPC_ProtectionStatus			0xDC03
+#define PTP_OPC_ObjectSize				0xDC04
+#define PTP_OPC_AssociationType				0xDC05
+#define PTP_OPC_AssociationDesc				0xDC06
+#define PTP_OPC_ObjectFileName				0xDC07
+#define PTP_OPC_DateCreated				0xDC08
+#define PTP_OPC_DateModified				0xDC09
+#define PTP_OPC_Keywords				0xDC0A
+#define PTP_OPC_ParentObject				0xDC0B
+#define PTP_OPC_AllowedFolderContents			0xDC0C
+#define PTP_OPC_Hidden					0xDC0D
+#define PTP_OPC_SystemObject				0xDC0E
+#define PTP_OPC_PersistantUniqueObjectIdentifier	0xDC41
+#define PTP_OPC_SyncID					0xDC42
+#define PTP_OPC_PropertyBag				0xDC43
+#define PTP_OPC_Name					0xDC44
+#define PTP_OPC_CreatedBy				0xDC45
+#define PTP_OPC_Artist					0xDC46
+#define PTP_OPC_DateAuthored				0xDC47
+#define PTP_OPC_Description				0xDC48
+#define PTP_OPC_URLReference				0xDC49
+#define PTP_OPC_LanguageLocale				0xDC4A
+#define PTP_OPC_CopyrightInformation			0xDC4B
+#define PTP_OPC_Source					0xDC4C
+#define PTP_OPC_OriginLocation				0xDC4D
+#define PTP_OPC_DateAdded				0xDC4E
+#define PTP_OPC_NonConsumable				0xDC4F
+#define PTP_OPC_CorruptOrUnplayable			0xDC50
+#define PTP_OPC_ProducerSerialNumber			0xDC51
+#define PTP_OPC_RepresentativeSampleFormat		0xDC81
+#define PTP_OPC_RepresentativeSampleSize		0xDC82
+#define PTP_OPC_RepresentativeSampleHeight		0xDC83
+#define PTP_OPC_RepresentativeSampleWidth		0xDC84
+#define PTP_OPC_RepresentativeSampleDuration		0xDC85
+#define PTP_OPC_RepresentativeSampleData		0xDC86
+#define PTP_OPC_Width					0xDC87
+#define PTP_OPC_Height					0xDC88
+#define PTP_OPC_Duration				0xDC89
+#define PTP_OPC_Rating					0xDC8A
+#define PTP_OPC_Track					0xDC8B
+#define PTP_OPC_Genre					0xDC8C
+#define PTP_OPC_Credits					0xDC8D
+#define PTP_OPC_Lyrics					0xDC8E
+#define PTP_OPC_SubscriptionContentID			0xDC8F
+#define PTP_OPC_ProducedBy				0xDC90
+#define PTP_OPC_UseCount				0xDC91
+#define PTP_OPC_SkipCount				0xDC92
+#define PTP_OPC_LastAccessed				0xDC93
+#define PTP_OPC_ParentalRating				0xDC94
+#define PTP_OPC_MetaGenre				0xDC95
+#define PTP_OPC_Composer				0xDC96
+#define PTP_OPC_EffectiveRating				0xDC97
+#define PTP_OPC_Subtitle				0xDC98
+#define PTP_OPC_OriginalReleaseDate			0xDC99
+#define PTP_OPC_AlbumName				0xDC9A
+#define PTP_OPC_AlbumArtist				0xDC9B
+#define PTP_OPC_Mood					0xDC9C
+#define PTP_OPC_DRMStatus				0xDC9D
+#define PTP_OPC_SubDescription				0xDC9E
+#define PTP_OPC_IsCropped				0xDCD1
+#define PTP_OPC_IsColorCorrected			0xDCD2
+#define PTP_OPC_ImageBitDepth				0xDCD3
+#define PTP_OPC_Fnumber					0xDCD4
+#define PTP_OPC_ExposureTime				0xDCD5
+#define PTP_OPC_ExposureIndex				0xDCD6
+#define PTP_OPC_DisplayName				0xDCE0
+#define PTP_OPC_BodyText				0xDCE1
+#define PTP_OPC_Subject					0xDCE2
+#define PTP_OPC_Priority				0xDCE3
+#define PTP_OPC_GivenName				0xDD00
+#define PTP_OPC_MiddleNames				0xDD01
+#define PTP_OPC_FamilyName				0xDD02
+#define PTP_OPC_Prefix					0xDD03
+#define PTP_OPC_Suffix					0xDD04
+#define PTP_OPC_PhoneticGivenName			0xDD05
+#define PTP_OPC_PhoneticFamilyName			0xDD06
+#define PTP_OPC_EmailPrimary				0xDD07
+#define PTP_OPC_EmailPersonal1				0xDD08
+#define PTP_OPC_EmailPersonal2				0xDD09
+#define PTP_OPC_EmailBusiness1				0xDD0A
+#define PTP_OPC_EmailBusiness2				0xDD0B
+#define PTP_OPC_EmailOthers				0xDD0C
+#define PTP_OPC_PhoneNumberPrimary			0xDD0D
+#define PTP_OPC_PhoneNumberPersonal			0xDD0E
+#define PTP_OPC_PhoneNumberPersonal2			0xDD0F
+#define PTP_OPC_PhoneNumberBusiness			0xDD10
+#define PTP_OPC_PhoneNumberBusiness2			0xDD11
+#define PTP_OPC_PhoneNumberMobile			0xDD12
+#define PTP_OPC_PhoneNumberMobile2			0xDD13
+#define PTP_OPC_FaxNumberPrimary			0xDD14
+#define PTP_OPC_FaxNumberPersonal			0xDD15
+#define PTP_OPC_FaxNumberBusiness			0xDD16
+#define PTP_OPC_PagerNumber				0xDD17
+#define PTP_OPC_PhoneNumberOthers			0xDD18
+#define PTP_OPC_PrimaryWebAddress			0xDD19
+#define PTP_OPC_PersonalWebAddress			0xDD1A
+#define PTP_OPC_BusinessWebAddress			0xDD1B
+#define PTP_OPC_InstantMessengerAddress			0xDD1C
+#define PTP_OPC_InstantMessengerAddress2		0xDD1D
+#define PTP_OPC_InstantMessengerAddress3		0xDD1E
+#define PTP_OPC_PostalAddressPersonalFull		0xDD1F
+#define PTP_OPC_PostalAddressPersonalFullLine1		0xDD20
+#define PTP_OPC_PostalAddressPersonalFullLine2		0xDD21
+#define PTP_OPC_PostalAddressPersonalFullCity		0xDD22
+#define PTP_OPC_PostalAddressPersonalFullRegion		0xDD23
+#define PTP_OPC_PostalAddressPersonalFullPostalCode	0xDD24
+#define PTP_OPC_PostalAddressPersonalFullCountry	0xDD25
+#define PTP_OPC_PostalAddressBusinessFull		0xDD26
+#define PTP_OPC_PostalAddressBusinessLine1		0xDD27
+#define PTP_OPC_PostalAddressBusinessLine2		0xDD28
+#define PTP_OPC_PostalAddressBusinessCity		0xDD29
+#define PTP_OPC_PostalAddressBusinessRegion		0xDD2A
+#define PTP_OPC_PostalAddressBusinessPostalCode		0xDD2B
+#define PTP_OPC_PostalAddressBusinessCountry		0xDD2C
+#define PTP_OPC_PostalAddressOtherFull			0xDD2D
+#define PTP_OPC_PostalAddressOtherLine1			0xDD2E
+#define PTP_OPC_PostalAddressOtherLine2			0xDD2F
+#define PTP_OPC_PostalAddressOtherCity			0xDD30
+#define PTP_OPC_PostalAddressOtherRegion		0xDD31
+#define PTP_OPC_PostalAddressOtherPostalCode		0xDD32
+#define PTP_OPC_PostalAddressOtherCountry		0xDD33
+#define PTP_OPC_OrganizationName			0xDD34
+#define PTP_OPC_PhoneticOrganizationName		0xDD35
+#define PTP_OPC_Role					0xDD36
+#define PTP_OPC_Birthdate				0xDD37
+#define PTP_OPC_MessageTo				0xDD40
+#define PTP_OPC_MessageCC				0xDD41
+#define PTP_OPC_MessageBCC				0xDD42
+#define PTP_OPC_MessageRead				0xDD43
+#define PTP_OPC_MessageReceivedTime			0xDD44
+#define PTP_OPC_MessageSender				0xDD45
+#define PTP_OPC_ActivityBeginTime			0xDD50
+#define PTP_OPC_ActivityEndTime				0xDD51
+#define PTP_OPC_ActivityLocation			0xDD52
+#define PTP_OPC_ActivityRequiredAttendees		0xDD54
+#define PTP_OPC_ActivityOptionalAttendees		0xDD55
+#define PTP_OPC_ActivityResources			0xDD56
+#define PTP_OPC_ActivityAccepted			0xDD57
+#define PTP_OPC_Owner					0xDD5D
+#define PTP_OPC_Editor					0xDD5E
+#define PTP_OPC_Webmaster				0xDD5F
+#define PTP_OPC_URLSource				0xDD60
+#define PTP_OPC_URLDestination				0xDD61
+#define PTP_OPC_TimeBookmark				0xDD62
+#define PTP_OPC_ObjectBookmark				0xDD63
+#define PTP_OPC_ByteBookmark				0xDD64
+#define PTP_OPC_LastBuildDate				0xDD70
+#define PTP_OPC_TimetoLive				0xDD71
+#define PTP_OPC_MediaGUID				0xDD72
+#define PTP_OPC_TotalBitRate				0xDE91
+#define PTP_OPC_BitRateType				0xDE92
+#define PTP_OPC_SampleRate				0xDE93
+#define PTP_OPC_NumberOfChannels			0xDE94
+#define PTP_OPC_AudioBitDepth				0xDE95
+#define PTP_OPC_ScanDepth				0xDE97
+#define PTP_OPC_AudioWAVECodec				0xDE99
+#define PTP_OPC_AudioBitRate				0xDE9A
+#define PTP_OPC_VideoFourCCCodec			0xDE9B
+#define PTP_OPC_VideoBitRate				0xDE9C
+#define PTP_OPC_FramesPerThousandSeconds		0xDE9D
+#define PTP_OPC_KeyFrameDistance			0xDE9E
+#define PTP_OPC_BufferSize				0xDE9F
+#define PTP_OPC_EncodingQuality				0xDEA0
+#define PTP_OPC_EncodingProfile				0xDEA1
+#define PTP_OPC_BuyFlag					0xD901
+
+/* WiFi Provisioning MTP Extension property codes */
+#define PTP_OPC_WirelessConfigurationFile		0xB104
+
+/* Device Property Form Flag */
+
+#define PTP_DPFF_None			0x00
+#define PTP_DPFF_Range			0x01
+#define PTP_DPFF_Enumeration		0x02
+
+/* Object Property Codes used by MTP (first 3 are same as DPFF codes) */
+#define PTP_OPFF_None			0x00
+#define PTP_OPFF_Range			0x01
+#define PTP_OPFF_Enumeration		0x02
+#define PTP_OPFF_DateTime		0x03
+#define PTP_OPFF_FixedLengthArray	0x04
+#define PTP_OPFF_RegularExpression	0x05
+#define PTP_OPFF_ByteArray		0x06
+#define PTP_OPFF_LongString		0xFF
+
+/* Device Property GetSet type */
+#define PTP_DPGS_Get			0x00
+#define PTP_DPGS_GetSet			0x01
+
+/* Glue stuff starts here */
+
+typedef struct _PTPParams PTPParams;
+
+
+typedef uint16_t (* PTPDataGetFunc)	(PTPParams* params, void*priv,
+					unsigned long wantlen,
+	                                unsigned char *data, unsigned long *gotlen);
+
+typedef uint16_t (* PTPDataPutFunc)	(PTPParams* params, void*priv,
+					unsigned long sendlen,
+	                                unsigned char *data);
+typedef struct _PTPDataHandler {
+	PTPDataGetFunc		getfunc;
+	PTPDataPutFunc		putfunc;
+	void			*priv;
+} PTPDataHandler;
+
+/*
+ * This functions take PTP oriented arguments and send them over an
+ * appropriate data layer doing byteorder conversion accordingly.
+ */
+typedef uint16_t (* PTPIOSendReq)	(PTPParams* params, PTPContainer* req);
+typedef uint16_t (* PTPIOSendData)	(PTPParams* params, PTPContainer* ptp,
+					 uint64_t size, PTPDataHandler*getter);
+
+typedef uint16_t (* PTPIOGetResp)	(PTPParams* params, PTPContainer* resp);
+typedef uint16_t (* PTPIOGetData)	(PTPParams* params, PTPContainer* ptp,
+	                                 PTPDataHandler *putter);
+typedef uint16_t (* PTPIOCancelReq)	(PTPParams* params, uint32_t transaction_id);
+
+/* debug functions */
+typedef void (* PTPErrorFunc) (void *data, const char *format, va_list args)
+#if (__GNUC__ >= 3)
+	__attribute__((__format__(printf,2,0)))
+#endif
+;
+typedef void (* PTPDebugFunc) (void *data, const char *format, va_list args)
+#if (__GNUC__ >= 3)
+	__attribute__((__format__(printf,2,0)))
+#endif
+;
+
+struct _PTPObject {
+	uint32_t	oid;
+	unsigned int	flags;
+#define PTPOBJECT_OBJECTINFO_LOADED	(1<<0)
+#define PTPOBJECT_CANONFLAGS_LOADED	(1<<1)
+#define PTPOBJECT_MTPPROPLIST_LOADED	(1<<2)
+#define PTPOBJECT_DIRECTORY_LOADED	(1<<3)
+#define PTPOBJECT_PARENTOBJECT_LOADED	(1<<4)
+#define PTPOBJECT_STORAGEID_LOADED	(1<<5)
+
+	PTPObjectInfo	oi;
+	uint32_t	canon_flags;
+	MTPProperties	*mtpprops;
+	unsigned int	nrofmtpprops;
+};
+typedef struct _PTPObject PTPObject;
+
+/* The Device Property Cache */
+struct _PTPDeviceProperty {
+	time_t			timestamp;
+	PTPDevicePropDesc	desc;
+	PTPPropertyValue	value;
+};
+typedef struct _PTPDeviceProperty PTPDeviceProperty;
+
+struct _PTPParams {
+	/* device flags */
+	uint32_t	device_flags;
+
+	/* data layer byteorder */
+	uint8_t		byteorder;
+	uint16_t	maxpacketsize;
+
+	/* PTP IO: Custom IO functions */
+	PTPIOSendReq	sendreq_func;
+	PTPIOSendData	senddata_func;
+	PTPIOGetResp	getresp_func;
+	PTPIOGetData	getdata_func;
+	PTPIOGetResp	event_check;
+	PTPIOGetResp	event_wait;
+	PTPIOCancelReq	cancelreq_func;
+
+	/* Custom error and debug function */
+	PTPErrorFunc	error_func;
+	PTPDebugFunc	debug_func;
+
+	/* Data passed to above functions */
+	void		*data;
+
+	/* ptp transaction ID */
+	uint32_t	transaction_id;
+	/* ptp session ID */
+	uint32_t	session_id;
+
+	/* PTP IO: if we have MTP style split header/data transfers */
+	int		split_header_data;
+	int		ocs64; /* 64bit objectsize */
+
+	/* PTP: internal structures used by ptp driver */
+	PTPObject	*objects;
+	unsigned int	nrofobjects;
+
+	PTPDeviceInfo	deviceinfo;
+
+	/* PTP: the current event queue */
+	PTPContainer	*events;
+	int		nrofevents;
+
+	/* live view enabled */
+	int			inliveview;
+
+	/* PTP: Device Property Caching */
+	PTPDeviceProperty	*deviceproperties;
+	unsigned int		nrofdeviceproperties;
+
+	/* PTP: Canon specific flags list */
+	PTPCanon_Property	*canon_props;
+	unsigned int		nrofcanon_props;
+	int			canon_viewfinder_on;
+	int			canon_event_mode;
+
+	/* PTP: Canon EOS event queue */
+	PTPCanon_changes_entry	*backlogentries;
+	unsigned int		nrofbacklogentries;
+	int			eos_captureenabled;
+	int			eos_camerastatus;
+
+	/* PTP: Nikon specifics */
+	int			controlmode;
+	int			event90c7works;
+
+	/* PTP: Wifi profiles */
+	uint8_t 	wifi_profiles_version;
+	uint8_t		wifi_profiles_number;
+	PTPNIKONWifiProfile *wifi_profiles;
+
+	/* IO: PTP/IP related data */
+	int		cmdfd, evtfd;
+	uint8_t		cameraguid[16];
+	uint32_t	eventpipeid;
+	char		*cameraname;
+
+	/* Olympus UMS wrapping related data */
+	PTPDeviceInfo	outer_deviceinfo;
+	char		*olympus_cmd;
+	char		*olympus_reply;
+	struct _PTPParams *outer_params;
+
+#if defined(HAVE_ICONV) && defined(HAVE_LANGINFO_H)
+	/* PTP: iconv converters */
+	iconv_t	cd_locale_to_ucs2;
+	iconv_t cd_ucs2_to_locale;
+#endif
+
+	/* IO: Sometimes the response packet get send in the dataphase
+	 * too. This only happens for a Samsung player now.
+	 */
+	uint8_t		*response_packet;
+	uint16_t	response_packet_size;
+};
+
+/* last, but not least - ptp functions */
+uint16_t ptp_usb_sendreq	(PTPParams* params, PTPContainer* req);
+uint16_t ptp_usb_senddata	(PTPParams* params, PTPContainer* ptp,
+				 uint64_t size, PTPDataHandler *handler);
+uint16_t ptp_usb_getresp	(PTPParams* params, PTPContainer* resp);
+uint16_t ptp_usb_getdata	(PTPParams* params, PTPContainer* ptp, 
+	                         PTPDataHandler *handler);
+uint16_t ptp_usb_event_check	(PTPParams* params, PTPContainer* event);
+uint16_t ptp_usb_event_wait	(PTPParams* params, PTPContainer* event);
+
+uint16_t ptp_usb_control_get_extended_event_data (PTPParams *params, char *buffer, int *size);
+uint16_t ptp_usb_control_device_reset_request (PTPParams *params);
+uint16_t ptp_usb_control_get_device_status (PTPParams *params, char *buffer, int *size);
+uint16_t ptp_usb_control_cancel_request (PTPParams *params, uint32_t transid);
+
+
+int      ptp_ptpip_connect	(PTPParams* params, const char *port);
+uint16_t ptp_ptpip_sendreq	(PTPParams* params, PTPContainer* req);
+uint16_t ptp_ptpip_senddata	(PTPParams* params, PTPContainer* ptp,
+				uint64_t size, PTPDataHandler *handler);
+uint16_t ptp_ptpip_getresp	(PTPParams* params, PTPContainer* resp);
+uint16_t ptp_ptpip_getdata	(PTPParams* params, PTPContainer* ptp, 
+	                         PTPDataHandler *handler);
+uint16_t ptp_ptpip_event_wait	(PTPParams* params, PTPContainer* event);
+uint16_t ptp_ptpip_event_check	(PTPParams* params, PTPContainer* event);
+
+uint16_t ptp_getdeviceinfo	(PTPParams* params, PTPDeviceInfo* deviceinfo);
+
+uint16_t ptp_generic_no_data	(PTPParams* params, uint16_t opcode, unsigned int cnt, ...);
+
+uint16_t ptp_opensession	(PTPParams *params, uint32_t session);
+
+uint16_t ptp_transaction_new (PTPParams* params, PTPContainer* ptp, 
+                uint16_t flags, uint64_t sendlen,
+                PTPDataHandler *handler
+);
+uint16_t ptp_transaction (PTPParams* params, PTPContainer* ptp,
+                uint16_t flags, uint64_t sendlen,
+                unsigned char **data, unsigned int *recvlen
+);
+
+/**
+ * ptp_closesession:
+ * params:      PTPParams*
+ *
+ * Closes session.
+ *
+ * Return values: Some PTP_RC_* code.
+ **/
+#define ptp_closesession(params) ptp_generic_no_data(params,PTP_OC_CloseSession,0)
+
+/**
+ * ptp_powerdown:
+ * params:      PTPParams*
+ *
+ * Powers down device.
+ *
+ * Return values: Some PTP_RC_* code.
+ **/
+#define ptp_powerdown(params) ptp_generic_no_data(params,PTP_OC_PowerDown,0)
+/**
+ * ptp_resetdevice:
+ * params:      PTPParams*
+ *              
+ * Uses the built-in function to reset the device
+ *
+ * Return values: Some PTP_RC_* code.
+ *
+ */
+#define ptp_resetdevice(params) ptp_generic_no_data(params,PTP_OC_ResetDevice,0)
+
+uint16_t ptp_getstorageids	(PTPParams* params, PTPStorageIDs* storageids);
+uint16_t ptp_getstorageinfo 	(PTPParams* params, uint32_t storageid,
+				PTPStorageInfo* storageinfo);
+/**
+ * ptp_formatstore:
+ * params:      PTPParams*
+ *              storageid               - StorageID
+ *
+ * Formats the storage on the device.
+ *
+ * Return values: Some PTP_RC_* code.
+ **/
+#define ptp_formatstore(params,storageid) ptp_generic_no_data(params,PTP_OC_FormatStore,1,storageid)
+
+uint16_t ptp_getobjecthandles 	(PTPParams* params, uint32_t storage,
+				uint32_t objectformatcode,
+				uint32_t associationOH,
+				PTPObjectHandles* objecthandles);
+
+
+uint16_t ptp_getnumobjects 	(PTPParams* params, uint32_t storage,
+				uint32_t objectformatcode,
+				uint32_t associationOH,
+				uint32_t* numobs);
+
+uint16_t ptp_getobjectinfo	(PTPParams *params, uint32_t handle,
+				PTPObjectInfo* objectinfo);
+
+uint16_t ptp_getobject		(PTPParams *params, uint32_t handle,
+				unsigned char** object);
+uint16_t ptp_getobject_tofd     (PTPParams* params, uint32_t handle, int fd);
+uint16_t ptp_getobject_to_handler (PTPParams* params, uint32_t handle, PTPDataHandler*);
+uint16_t ptp_getpartialobject	(PTPParams* params, uint32_t handle, uint32_t offset,
+				uint32_t maxbytes, unsigned char** object,
+				uint32_t *len);
+uint16_t ptp_getpartialobject_to_handler (PTPParams* params, uint32_t handle, uint32_t offset,
+                        	uint32_t maxbytes, PTPDataHandler *handler);
+
+uint16_t ptp_getthumb		(PTPParams *params, uint32_t handle,
+				unsigned char** object, unsigned int *len);
+
+uint16_t ptp_deleteobject	(PTPParams* params, uint32_t handle,
+				uint32_t ofc);
+
+uint16_t ptp_sendobjectinfo	(PTPParams* params, uint32_t* store,
+				uint32_t* parenthandle, uint32_t* handle,
+				PTPObjectInfo* objectinfo);
+/**
+ * ptp_setobjectprotection:
+ * params:      PTPParams*
+ *              uint16_t newprot        - object protection flag
+ *              
+ * Set protection of object.
+ *
+ * Return values: Some PTP_RC_* code.
+ *
+ */
+#define ptp_setobjectprotection(params,oid,newprot) ptp_generic_no_data(params,PTP_OC_SetObjectProtection,2,oid,newprot)
+uint16_t ptp_sendobject		(PTPParams* params, unsigned char* object,
+				 uint64_t size);
+uint16_t ptp_sendobject_fromfd  (PTPParams* params, int fd, uint64_t size);
+uint16_t ptp_sendobject_from_handler  (PTPParams* params, PTPDataHandler*, uint64_t size);
+/**
+ * ptp_initiatecapture:
+ * params:      PTPParams*
+ *              storageid               - destination StorageID on Responder
+ *              ofc                     - object format code
+ * 
+ * Causes device to initiate the capture of one or more new data objects
+ * according to its current device properties, storing the data into store
+ * indicated by storageid. If storageid is 0x00000000, the object(s) will
+ * be stored in a store that is determined by the capturing device.
+ * The capturing of new data objects is an asynchronous operation.
+ *
+ * Return values: Some PTP_RC_* code.
+ **/
+#define ptp_initiatecapture(params,storageid,ofc) ptp_generic_no_data(params,PTP_OC_InitiateCapture,2,storageid,ofc)
+
+uint16_t ptp_getdevicepropdesc	(PTPParams* params, uint16_t propcode,
+				PTPDevicePropDesc *devicepropertydesc);
+uint16_t ptp_generic_getdevicepropdesc (PTPParams *params, uint16_t propcode,
+				PTPDevicePropDesc *dpd);
+uint16_t ptp_getdevicepropvalue	(PTPParams* params, uint16_t propcode,
+				PTPPropertyValue* value, uint16_t datatype);
+uint16_t ptp_setdevicepropvalue (PTPParams* params, uint16_t propcode,
+                        	PTPPropertyValue* value, uint16_t datatype);
+uint16_t ptp_generic_setdevicepropvalue (PTPParams* params, uint16_t propcode,
+                        	PTPPropertyValue* value, uint16_t datatype);
+uint16_t ptp_getfilesystemmanifest (PTPParams* params, uint32_t storage,
+                        uint32_t objectformatcode, uint32_t associationOH,
+                        unsigned char** data);
+
+
+
+uint16_t ptp_check_event (PTPParams *params);
+uint16_t ptp_wait_event (PTPParams *params);
+uint16_t ptp_add_event (PTPParams *params, PTPContainer *evt);
+int ptp_get_one_event (PTPParams *params, PTPContainer *evt);
+uint16_t ptp_check_eos_events (PTPParams *params);
+int ptp_get_one_eos_event (PTPParams *params, PTPCanon_changes_entry *entry);
+
+
+/* Microsoft MTP extensions */
+uint16_t ptp_mtp_getobjectpropdesc (PTPParams* params, uint16_t opc, uint16_t ofc,
+				PTPObjectPropDesc *objectpropertydesc);
+uint16_t ptp_mtp_getobjectpropvalue (PTPParams* params, uint32_t oid, uint16_t opc, 
+				PTPPropertyValue *value, uint16_t datatype);
+uint16_t ptp_mtp_setobjectpropvalue (PTPParams* params, uint32_t oid, uint16_t opc,
+				PTPPropertyValue *value, uint16_t datatype);
+uint16_t ptp_mtp_getobjectreferences (PTPParams* params, uint32_t handle, uint32_t** ohArray, uint32_t* arraylen);
+uint16_t ptp_mtp_setobjectreferences (PTPParams* params, uint32_t handle, uint32_t* ohArray, uint32_t arraylen);
+uint16_t ptp_mtp_getobjectproplist (PTPParams* params, uint32_t handle, MTPProperties **props, int *nrofprops);
+uint16_t ptp_mtp_getobjectproplist_single (PTPParams* params, uint32_t handle, MTPProperties **props, int *nrofprops);
+uint16_t ptp_mtp_sendobjectproplist (PTPParams* params, uint32_t* store, uint32_t* parenthandle, uint32_t* handle,
+				     uint16_t objecttype, uint64_t objectsize, MTPProperties *props, int nrofprops);
+uint16_t ptp_mtp_setobjectproplist (PTPParams* params, MTPProperties *props, int nrofprops);
+
+/* Microsoft MTPZ (Zune) extensions */
+uint16_t ptp_mtpz_sendwmdrmpdapprequest (PTPParams*, unsigned char *, uint32_t);
+#define  ptp_mtpz_resethandshake(params) ptp_generic_no_data(params, PTP_OC_MTP_WMDRMPD_EndTrustedAppSession, 0)
+uint16_t ptp_mtpz_getwmdrmpdappresponse (PTPParams*, unsigned char **, uint32_t*);
+#define  ptp_mtpz_wmdrmpd_enabletrustedfilesoperations(params,hash1,hash2,hash3,hash4) \
+	 ptp_generic_no_data(params, PTP_OC_MTP_WMDRMPD_EnableTrustedFilesOperations, 4,\
+		hash1, hash2, hash3, hash4)
+
+/* Eastman Kodak extensions */
+uint16_t ptp_ek_9007 (PTPParams* params, unsigned char **serial, unsigned int *size);
+uint16_t ptp_ek_9009 (PTPParams* params, uint32_t*, uint32_t*);
+uint16_t ptp_ek_900c (PTPParams* params, unsigned char **serial, unsigned int *size);
+uint16_t ptp_ek_getserial (PTPParams* params, unsigned char **serial, unsigned int *size);
+uint16_t ptp_ek_setserial (PTPParams* params, unsigned char *serial, unsigned int size);
+uint16_t ptp_ek_settext (PTPParams* params, PTPEKTextParams *text);
+uint16_t ptp_ek_sendfileobjectinfo (PTPParams* params, uint32_t* store,
+				uint32_t* parenthandle, uint32_t* handle,
+				PTPObjectInfo* objectinfo);
+uint16_t ptp_ek_sendfileobject	(PTPParams* params, unsigned char* object,
+				uint32_t size);
+uint16_t ptp_ek_sendfileobject_from_handler	(PTPParams* params, PTPDataHandler*,
+				uint32_t size);
+
+/* Canon PTP extensions */
+#define ptp_canon_9012(params) ptp_generic_no_data(params,0x9012,0)
+uint16_t ptp_canon_gettreeinfo (PTPParams* params, uint32_t* out);
+uint16_t ptp_canon_gettreesize (PTPParams* params, PTPCanon_directtransfer_entry**, unsigned int*cnt);
+uint16_t ptp_canon_getpartialobjectinfo (PTPParams* params, uint32_t handle,
+				uint32_t p2, uint32_t* size, uint32_t* rp2);
+
+uint16_t ptp_canon_get_mac_address (PTPParams* params, unsigned char **mac);
+/**
+ * ptp_canon_startshootingmode:
+ * params:      PTPParams*
+ * 
+ * Starts shooting session. It emits a StorageInfoChanged
+ * event via the interrupt pipe and pushes the StorageInfoChanged
+ * and CANON_CameraModeChange events onto the event stack
+ * (see operation PTP_OC_CANON_CheckEvent).
+ *
+ * Return values: Some PTP_RC_* code.
+ *
+ **/
+#define ptp_canon_startshootingmode(params) ptp_generic_no_data(params,PTP_OC_CANON_InitiateReleaseControl,0)
+/**
+ * ptp_canon_endshootingmode:
+ * params:      PTPParams*
+ * 
+ * This operation is observed after pressing the Disconnect 
+ * button on the Remote Capture app. It emits a StorageInfoChanged 
+ * event via the interrupt pipe and pushes the StorageInfoChanged
+ * and CANON_CameraModeChange events onto the event stack
+ * (see operation PTP_OC_CANON_CheckEvent).
+ *
+ * Return values: Some PTP_RC_* code.
+ *
+ **/
+#define ptp_canon_endshootingmode(params) ptp_generic_no_data(params,PTP_OC_CANON_TerminateReleaseControl,0)
+/**
+ * ptp_canon_viewfinderon:
+ * params:      PTPParams*
+ * 
+ * Prior to start reading viewfinder images, one  must call this operation.
+ * Supposedly, this operation affects the value of the CANON_ViewfinderMode
+ * property.
+ *
+ * Return values: Some PTP_RC_* code.
+ *
+ **/
+#define ptp_canon_viewfinderon(params) ptp_generic_no_data(params,PTP_OC_CANON_ViewfinderOn,0)
+/**
+ * ptp_canon_viewfinderoff:
+ * params:      PTPParams*
+ * 
+ * Before changing the shooting mode, or when one doesn't need to read
+ * viewfinder images any more, one must call this operation.
+ * Supposedly, this operation affects the value of the CANON_ViewfinderMode
+ * property.
+ *
+ * Return values: Some PTP_RC_* code.
+ *
+ **/
+#define ptp_canon_viewfinderoff(params) ptp_generic_no_data(params,PTP_OC_CANON_ViewfinderOff,0)
+/**
+ * ptp_canon_reset_aeafawb:
+ * params:      PTPParams*
+ *              uint32_t flags  - what shall be reset.
+ *                      1 - autoexposure
+ *                      2 - autofocus
+ *                      4 - autowhitebalance
+ * 
+ * Called "Reset AeAfAwb" (auto exposure, focus, white balance)
+ *
+ * Return values: Some PTP_RC_* code.
+ **/
+#define PTP_CANON_RESET_AE	0x1
+#define PTP_CANON_RESET_AF	0x2
+#define PTP_CANON_RESET_AWB	0x4
+#define ptp_canon_reset_aeafawb(params,flags) ptp_generic_no_data(params,PTP_OC_CANON_DoAeAfAwb,1,flags)
+uint16_t ptp_canon_checkevent (PTPParams* params, 
+				PTPContainer* event, int* isevent);
+/**
+ * ptp_canon_focuslock:
+ *
+ * This operation locks the focus. It is followed by the CANON_GetChanges(?)
+ * operation in the log. 
+ * It affects the CANON_MacroMode property. 
+ *
+ * params:      PTPParams*
+ *
+ * Return values: Some PTP_RC_* code.
+ *
+ **/
+#define ptp_canon_focuslock(params) ptp_generic_no_data(params,PTP_OC_CANON_FocusLock,0)
+/**
+ * ptp_canon_focusunlock:
+ *
+ * This operation unlocks the focus. It is followed by the CANON_GetChanges(?)
+ * operation in the log. 
+ * It sets the CANON_MacroMode property value to 1 (where it occurs in the log).
+ * 
+ * params:      PTPParams*
+ *
+ * Return values: Some PTP_RC_* code.
+ *
+ **/
+#define ptp_canon_focusunlock(params) ptp_generic_no_data(params,PTP_OC_CANON_FocusUnlock,0)
+/**
+ * ptp_canon_keepdeviceon:
+ *
+ * This operation sends a "ping" style message to the camera.
+ * 
+ * params:      PTPParams*
+ *
+ * Return values: Some PTP_RC_* code.
+ *
+ **/
+#define ptp_canon_keepdeviceon(params) ptp_generic_no_data(params,PTP_OC_CANON_KeepDeviceOn,0)
+/**
+ * ptp_canon_eos_keepdeviceon:
+ *
+ * This operation sends a "ping" style message to the camera.
+ * 
+ * params:      PTPParams*
+ *
+ * Return values: Some PTP_RC_* code.
+ *
+ **/
+#define ptp_canon_eos_keepdeviceon(params) ptp_generic_no_data(params,PTP_OC_CANON_EOS_KeepDeviceOn,0)
+/**
+ * ptp_canon_initiatecaptureinmemory:
+ * 
+ * This operation starts the image capture according to the current camera
+ * settings. When the capture has happened, the camera emits a CaptureComplete
+ * event via the interrupt pipe and pushes the CANON_RequestObjectTransfer,
+ * CANON_DeviceInfoChanged and CaptureComplete events onto the event stack
+ * (see operation CANON_CheckEvent). From the CANON_RequestObjectTransfer
+ * event's parameter one can learn the just captured image's ObjectHandle.
+ * The image is stored in the camera's own RAM.
+ * On the next capture the image will be overwritten!
+ *
+ * params:      PTPParams*
+ *
+ * Return values: Some PTP_RC_* code.
+ *
+ **/
+#define ptp_canon_initiatecaptureinmemory(params) ptp_generic_no_data(params,PTP_OC_CANON_InitiateCaptureInMemory,0)
+/**
+ * ptp_canon_eos_requestdevicepropvalue:
+ *
+ * This operation sends a "ping" style message to the camera.
+ * 
+ * params:      PTPParams*
+ *
+ * Return values: Some PTP_RC_* code.
+ *
+ **/
+#define CANON_EOS_OLC_BUTTON 		0x0001
+#define CANON_EOS_OLC_SHUTTERSPEED 	0x0002
+#define CANON_EOS_OLC_APERTURE 		0x0004
+#define CANON_EOS_OLC_ISO 		0x0008
+
+#define ptp_canon_eos_setrequestolcinfogroup(params,igmask) ptp_generic_no_data(params,PTP_OC_CANON_EOS_SetRequestOLCInfoGroup,1,igmask)
+#define ptp_canon_eos_requestdevicepropvalue(params,prop) ptp_generic_no_data(params,PTP_OC_CANON_EOS_RequestDevicePropValue,1,prop)
+uint16_t ptp_canon_eos_capture (PTPParams* params, uint32_t *result);
+uint16_t ptp_canon_eos_getevent (PTPParams* params, PTPCanon_changes_entry **entries, int *nrofentries);
+uint16_t ptp_canon_getpartialobject (PTPParams* params, uint32_t handle, 
+				uint32_t offset, uint32_t size,
+				uint32_t pos, unsigned char** block, 
+				uint32_t* readnum);
+uint16_t ptp_canon_getviewfinderimage (PTPParams* params, unsigned char** image,
+				uint32_t* size);
+uint16_t ptp_canon_getchanges (PTPParams* params, uint16_t** props,
+				uint32_t* propnum); 
+uint16_t ptp_canon_getobjectinfo (PTPParams* params, uint32_t store,
+				uint32_t p2, uint32_t parenthandle,
+				uint32_t handle, 
+				PTPCANONFolderEntry** entries,
+				uint32_t* entnum);
+uint16_t ptp_canon_eos_getdeviceinfo (PTPParams* params, PTPCanonEOSDeviceInfo*di);
+/**
+ * ptp_canon_eos_setuilock:
+ *
+ * This command sets UI lock
+ *  
+ * params:      PTPParams*
+ *
+ * Return values: Some PTP_RC_* code.
+ *
+ **/
+#define ptp_canon_eos_setuilock(params) ptp_generic_no_data(params,PTP_OC_CANON_EOS_SetUILock,0)
+/**
+ * ptp_canon_eos_resetuilock:
+ *
+ * This command sets UI lock
+ *  
+ * params:      PTPParams*
+ *
+ * Return values: Some PTP_RC_* code.
+ *
+ **/
+#define ptp_canon_eos_resetuilock(params) ptp_generic_no_data(params,PTP_OC_CANON_EOS_ResetUILock,0)
+/**
+ * ptp_canon_eos_start_viewfinder:
+ *
+ * This command starts Viewfinder mode of newer Canon DSLRs.
+ *  
+ * params:      PTPParams*
+ *
+ * Return values: Some PTP_RC_* code.
+ *
+ **/
+#define ptp_canon_eos_start_viewfinder(params) ptp_generic_no_data(params,PTP_OC_CANON_EOS_InitiateViewfinder,0)
+/**
+ * ptp_canon_eos_end_viewfinder:
+ *
+ * This command ends Viewfinder mode of newer Canon DSLRs.
+ *  
+ * params:      PTPParams*
+ *
+ * Return values: Some PTP_RC_* code.
+ *
+ **/
+#define ptp_canon_eos_end_viewfinder(params) ptp_generic_no_data(params,PTP_OC_CANON_EOS_TerminateViewfinder,0)
+uint16_t ptp_canon_eos_get_viewfinder_image (PTPParams* params, unsigned char **data, unsigned int *size);
+uint16_t ptp_canon_eos_get_viewfinder_image_handler (PTPParams* params, PTPDataHandler*);
+uint16_t ptp_canon_get_objecthandle_by_name (PTPParams* params, char* name, uint32_t* objectid);
+uint16_t ptp_canon_get_directory (PTPParams* params, PTPObjectHandles *handles, PTPObjectInfo **oinfos, uint32_t **flags);
+/**
+ * ptp_canon_setobjectarchive:
+ *
+ * params:      PTPParams*
+ *              uint32_t        objectid
+ *              uint32_t        flags
+ *
+ * Return values: Some PTP_RC_* code.
+ *
+ **/
+#define ptp_canon_setobjectarchive(params,oid,flags) ptp_generic_no_data(params,PTP_OC_CANON_SetObjectArchive,2,oid,flags)
+uint16_t ptp_canon_get_customize_data (PTPParams* params, uint32_t themenr,
+				unsigned char **data, unsigned int *size);
+uint16_t ptp_canon_getpairinginfo (PTPParams* params, uint32_t nr, unsigned char**, unsigned int*);
+
+uint16_t ptp_canon_eos_getstorageids (PTPParams* params, PTPStorageIDs* storageids);
+uint16_t ptp_canon_eos_getstorageinfo (PTPParams* params, uint32_t p1, unsigned char**, unsigned int*);
+uint16_t ptp_canon_eos_getpartialobject (PTPParams* params, uint32_t oid, uint32_t off, uint32_t xsize, unsigned char**data);
+uint16_t ptp_canon_eos_getobjectinfoex (PTPParams* params, uint32_t storageid, uint32_t objectid, uint32_t unk,
+        PTPCANONFolderEntry **entries, unsigned int *nrofentries);
+uint16_t ptp_canon_eos_setdevicepropvalueex (PTPParams* params, unsigned char* data, unsigned int size);
+#define ptp_canon_eos_setremotemode(params,p1) ptp_generic_no_data(params,PTP_OC_CANON_EOS_SetRemoteMode,1,p1)
+#define ptp_canon_eos_seteventmode(params,p1) ptp_generic_no_data(params,PTP_OC_CANON_EOS_SetEventMode,1,p1)
+/**
+ * ptp_canon_eos_transfercomplete:
+ * 
+ * This ends a direct object transfer from an EOS camera.
+ *
+ * params:      PTPParams*
+ *              oid             Object ID
+ *
+ * Return values: Some PTP_RC_* code.
+ *
+ */
+#define ptp_canon_eos_transfercomplete(params,oid) ptp_generic_no_data(params,PTP_OC_CANON_EOS_TransferComplete,1,oid)
+/* inHDD = %d, inLength =%d, inReset = %d */
+#define ptp_canon_eos_pchddcapacity(params,p1,p2,p3) ptp_generic_no_data(params,PTP_OC_CANON_EOS_PCHDDCapacity,3,p1,p2,p3)
+uint16_t ptp_canon_eos_bulbstart (PTPParams* params);
+uint16_t ptp_canon_eos_bulbend (PTPParams* params);
+uint16_t ptp_canon_eos_getdevicepropdesc (PTPParams* params, uint16_t propcode,
+				PTPDevicePropDesc *devicepropertydesc);
+uint16_t ptp_canon_eos_setdevicepropvalue (PTPParams* params, uint16_t propcode,
+                        	PTPPropertyValue* value, uint16_t datatype);
+uint16_t ptp_nikon_get_vendorpropcodes (PTPParams* params, uint16_t **props, unsigned int *size);
+uint16_t ptp_nikon_curve_download (PTPParams* params, 
+				unsigned char **data, unsigned int *size);
+uint16_t ptp_nikon_getptpipinfo (PTPParams* params, unsigned char **data, unsigned int *size);
+uint16_t ptp_nikon_getwifiprofilelist (PTPParams* params);
+uint16_t ptp_nikon_writewifiprofile (PTPParams* params, PTPNIKONWifiProfile* profile);
+
+uint16_t ptp_sony_sdioconnect (PTPParams* params, uint32_t p1, uint32_t p2, uint32_t p3);
+uint16_t ptp_sony_get_vendorpropcodes (PTPParams* params, uint16_t **props, unsigned int *size);
+uint16_t ptp_sony_getdevicepropdesc (PTPParams* params, uint16_t propcode,
+				PTPDevicePropDesc *devicepropertydesc);
+uint16_t ptp_sony_getalldevicepropdesc (PTPParams* params);
+uint16_t ptp_sony_setdevicecontrolvaluea (PTPParams* params, uint16_t propcode,
+                        	PTPPropertyValue* value, uint16_t datatype);
+uint16_t ptp_sony_setdevicecontrolvalueb (PTPParams* params, uint16_t propcode,
+                        	PTPPropertyValue* value, uint16_t datatype);
+/**
+ * ptp_nikon_deletewifiprofile:
+ *
+ * This command deletes a wifi profile.
+ *  
+ * params:      PTPParams*
+ *      unsigned int profilenr  - profile number
+ *
+ * Return values: Some PTP_RC_* code.
+ *
+ **/
+#define ptp_nikon_deletewifiprofile(params,profilenr) ptp_generic_no_data(params,PTP_OC_NIKON_DeleteProfile,1,profilenr)
+/**
+ * ptp_nikon_setcontrolmode:
+ *
+ * This command can switch the camera to full PC control mode.
+ *  
+ * params:      PTPParams*
+ *      uint32_t mode - mode
+ *
+ * Return values: Some PTP_RC_* code.
+ *
+ **/
+#define ptp_nikon_setcontrolmode(params,mode) ptp_generic_no_data(params,PTP_OC_NIKON_SetControlMode,1,mode)
+/**
+ * ptp_nikon_terminatecapture:
+ *
+ * This command appears to terminate a longer capture
+ *  
+ * params:      PTPParams*
+ *      uint32_t a 
+ *      uint32_t b 
+ *
+ * Return values: Some PTP_RC_* code.
+ *
+ **/
+#define ptp_nikon_terminatecapture(params,p1,p2) ptp_generic_no_data(params,PTP_OC_NIKON_TerminateCapture,2,p1,p2)
+/**
+ * ptp_nikon_afdrive:
+ *
+ * This command runs (drives) the lens autofocus.
+ *  
+ * params:      PTPParams*
+ *
+ * Return values: Some PTP_RC_* code.
+ *
+ **/
+#define ptp_nikon_afdrive(params) ptp_generic_no_data(params,PTP_OC_NIKON_AfDrive,0)
+/**
+ * ptp_nikon_changeafarea:
+ *
+ * This command starts movie capture (to card)
+ *  
+ * params:      PTPParams*
+ * x: x coordinate
+ * y: y coordinate
+ *
+ * Return values: Some PTP_RC_* code.
+ *
+ **/
+#define ptp_nikon_changeafarea(params,x,y) ptp_generic_no_data(params,PTP_OC_NIKON_ChangeAfArea,2,x,y)
+/**
+ * ptp_nikon_startmovie:
+ *
+ * This command starts movie capture (to card)
+ *  
+ * params:      PTPParams*
+ *
+ * Return values: Some PTP_RC_* code.
+ *
+ **/
+#define ptp_nikon_startmovie(params) ptp_generic_no_data(params,PTP_OC_NIKON_StartMovieRecInCard,0)
+/**
+ * ptp_nikon_stopmovie:
+ *
+ * This command stops movie capture (to card)
+ *  
+ * params:      PTPParams*
+ *
+ * Return values: Some PTP_RC_* code.
+ *
+ **/
+#define ptp_nikon_stopmovie(params) ptp_generic_no_data(params,PTP_OC_NIKON_EndMovieRec,0)
+/**
+ * ptp_canon_eos_afdrive:
+ *
+ * This command runs (drives) the lens autofocus.
+ *  
+ * params:      PTPParams*
+ *
+ * Return values: Some PTP_RC_* code.
+ *
+ **/
+#define ptp_canon_eos_afdrive(params) ptp_generic_no_data(params,PTP_OC_CANON_EOS_DoAf,0)
+/**
+ * ptp_canon_eos_afcancel:
+ *
+ * This command cancels the lens autofocus.
+ *  
+ * params:      PTPParams*
+ *
+ * Return values: Some PTP_RC_* code.
+ *
+ **/
+#define ptp_canon_eos_afcancel(params) ptp_generic_no_data(params,PTP_OC_CANON_EOS_AfCancel,0)
+/**
+ * ptp_canon_eos_zoom:
+ *
+ * This command runs (drives) the lens autofocus.
+ *  
+ * params:      PTPParams*
+ * params:      arg1 unknown
+ *
+ * Return values: Some PTP_RC_* code.
+ *
+ **/
+#define ptp_canon_eos_zoom(params,x) ptp_generic_no_data(params,PTP_OC_CANON_EOS_Zoom,1,x)
+#define ptp_canon_eos_zoomposition(params,x,y) ptp_generic_no_data(params,PTP_OC_CANON_EOS_ZoomPosition,2,x,y)
+
+#define ptp_canon_eos_remotereleaseon(params,x,y) ptp_generic_no_data(params,PTP_OC_CANON_EOS_RemoteReleaseOn,2,x,y)
+#define ptp_canon_eos_remotereleaseoff(params,x) ptp_generic_no_data(params,PTP_OC_CANON_EOS_RemoteReleaseOff,1,x)
+/**
+ * ptp_nikon_mfdrive:
+ *
+ * This command runs (drives) the lens focus manually.
+ *  
+ * params:      PTPParams*
+ * flag:        0x1 for (no limit - closest), 0x2 for (closest - no limit)
+ * amount:      amount of steps
+ *
+ * Return values: Some PTP_RC_* code.
+ *
+ **/
+#define ptp_nikon_mfdrive(params,flag,amount) ptp_generic_no_data(params,PTP_OC_NIKON_MfDrive,2,flag,amount)
+
+/**
+ * ptp_canon_eos_drivelens:
+ *
+ * This command runs (drives) the lens focus manually.
+ *  
+ * params:      PTPParams*
+ * amount:      0x1-0x3 for near range, 0x8001-0x8003 for far range.
+ *
+ * Return values: Some PTP_RC_* code.
+ *
+ **/
+#define ptp_canon_eos_drivelens(params,amount) ptp_generic_no_data(params,PTP_OC_CANON_EOS_DriveLens,1,amount)
+/**
+ * ptp_nikon_capture:
+ *
+ * This command captures a picture on the Nikon.
+ *  
+ * params:      PTPParams*
+ *      uint32_t x: unknown parameter. seen to be -1.
+ *
+ * Return values: Some PTP_RC_* code.
+ *
+ **/
+#define ptp_nikon_capture(params,x) ptp_generic_no_data(params,PTP_OC_NIKON_Capture,1,x)
+
+/**
+ * ptp_nikon_capture2:
+ *
+ * This command captures a picture on the Nikon.
+ *  
+ * params:      PTPParams*
+ * af: 		autofocus before capture (1 yes , 0 no)
+ * target:	sdram 1, card 0
+ *
+ * Return values: Some PTP_RC_* code.
+ * 2 params:
+ * 0xffffffff == No AF before,  0xfffffffe == AF before capture
+ * sdram=1, card=0
+ */
+#define ptp_nikon_capture2(params,af,target) ptp_generic_no_data(params,PTP_OC_NIKON_InitiateCaptureRecInMedia,2,af?0xfffffffe:0xffffffff,target)
+/**
+ * ptp_nikon_capture_sdram:
+ *
+ * This command captures a picture on the Nikon.
+ *  
+ * params:      PTPParams*
+ *
+ * Return values: Some PTP_RC_* code.
+ *
+ **/
+#define ptp_nikon_capture_sdram(params) ptp_generic_no_data(params,PTP_OC_NIKON_AfCaptureSDRAM,0)
+/**
+ * ptp_nikon_delete_sdram_image:
+ *
+ * This command deletes the current SDRAM image
+ *  
+ * params:      PTPParams*
+ * uint32_t	oid
+ *
+ * Return values: Some PTP_RC_* code.
+ *
+ **/
+#define ptp_nikon_delete_sdram_image(params,oid) ptp_generic_no_data(params,PTP_OC_NIKON_DelImageSDRAM,1,oid)
+/**
+ * ptp_nikon_start_liveview:
+ *
+ * This command starts LiveView mode of newer Nikons DSLRs.
+ *  
+ * params:      PTPParams*
+ *
+ * Return values: Some PTP_RC_* code.
+ *
+ **/
+#define ptp_nikon_start_liveview(params) ptp_generic_no_data(params,PTP_OC_NIKON_StartLiveView,0)
+uint16_t ptp_nikon_get_liveview_image (PTPParams* params, unsigned char**,unsigned int*);
+uint16_t ptp_nikon_get_preview_image (PTPParams* params, unsigned char**, unsigned int*, uint32_t*);
+/**
+ * ptp_nikon_end_liveview:
+ *
+ * This command ends LiveView mode of newer Nikons DSLRs.
+ *  
+ * params:      PTPParams*
+ *
+ * Return values: Some PTP_RC_* code.
+ *
+ **/
+#define ptp_nikon_end_liveview(params) ptp_generic_no_data(params,PTP_OC_NIKON_EndLiveView,0)
+uint16_t ptp_nikon_check_event (PTPParams* params, PTPContainer **evt, unsigned int *evtcnt);
+uint16_t ptp_nikon_getfileinfoinblock (PTPParams* params, uint32_t p1, uint32_t p2, uint32_t p3,
+					unsigned char **data, unsigned int *size);
+/**
+ * ptp_nikon_device_ready:
+ *
+ * This command checks if the device is ready. Used after
+ * a capture.
+ *  
+ * params:      PTPParams*
+ *
+ * Return values: Some PTP_RC_* code.
+ *
+ **/
+#define ptp_nikon_device_ready(params) ptp_generic_no_data (params, PTP_OC_NIKON_DeviceReady, 0)
+uint16_t ptp_mtp_getobjectpropssupported (PTPParams* params, uint16_t ofc, uint32_t *propnum, uint16_t **props);
+
+
+/* Android MTP Extensions */
+uint16_t ptp_android_getpartialobject64	(PTPParams* params, uint32_t handle, uint64_t offset,
+					uint32_t maxbytes, unsigned char** object,
+					uint32_t *len);
+#define ptp_android_begineditobject(params,handle) ptp_generic_no_data (params, PTP_OC_ANDROID_BeginEditObject, 1, handle);
+#define ptp_android_truncate(params,handle,offset) ptp_generic_no_data (params, PTP_OC_ANDROID_TruncateObject, 3, handle, (offset & 0xFFFFFFFF), (offset >> 32));
+uint16_t ptp_android_sendpartialobject (PTPParams *params, uint32_t handle,
+					uint64_t offset, unsigned char *object, uint32_t len);
+#define ptp_android_endeditobject(params,handle) ptp_generic_no_data (params, PTP_OC_ANDROID_EndEditObject, 1, handle);
+
+uint16_t ptp_olympus_getdeviceinfo (PTPParams*, PTPDeviceInfo*);
+#define ptp_olympus_setcameracontrolmode(params,p1) ptp_generic_no_data (params, PTP_OC_OLYMPUS_SetCameraControlMode, 1, p1);
+uint16_t ptp_olympus_opensession (PTPParams*, unsigned char**, unsigned int *);
+#define ptp_olympus_capture(params,p1) ptp_generic_no_data (params, PTP_OC_OLYMPUS_Capture, 1, p1);
+uint16_t ptp_olympus_getcameraid (PTPParams*, unsigned char**, unsigned int *);
+
+/* Non PTP protocol functions */
+static inline int
+ptp_operation_issupported(PTPParams* params, uint16_t operation)
+{
+	unsigned int i=0;
+
+	for (;i<params->deviceinfo.OperationsSupported_len;i++) {
+		if (params->deviceinfo.OperationsSupported[i]==operation)
+			return 1;
+	}
+	return 0;
+}
+
+int ptp_event_issupported	(PTPParams* params, uint16_t event);
+int ptp_property_issupported	(PTPParams* params, uint16_t property);
+
+void ptp_free_params		(PTPParams *params);
+void ptp_free_objectpropdesc	(PTPObjectPropDesc*);
+void ptp_free_devicepropdesc	(PTPDevicePropDesc*);
+void ptp_free_devicepropvalue	(uint16_t, PTPPropertyValue*);
+void ptp_free_objectinfo	(PTPObjectInfo *oi);
+void ptp_free_object		(PTPObject *oi);
+
+const char *ptp_strerror	(uint16_t ret, uint16_t vendor);
+void ptp_debug			(PTPParams *params, const char *format, ...);
+void ptp_error			(PTPParams *params, const char *format, ...);
+
+
+const char*
+ptp_get_property_description(PTPParams* params, uint16_t dpc);
+
+int
+ptp_render_property_value(PTPParams* params, uint16_t dpc,
+                          PTPDevicePropDesc *dpd, unsigned int length, char *out);
+int ptp_render_ofc(PTPParams* params, uint16_t ofc, int spaceleft, char *txt);
+int ptp_render_opcode(PTPParams* params, uint16_t opcode, int spaceleft, char *txt);
+int ptp_render_mtp_propname(uint16_t propid, int spaceleft, char *txt);
+MTPProperties *ptp_get_new_object_prop_entry(MTPProperties **props, int *nrofprops);
+void ptp_destroy_object_prop(MTPProperties *prop);
+void ptp_destroy_object_prop_list(MTPProperties *props, int nrofprops);
+MTPProperties *ptp_find_object_prop_in_cache(PTPParams *params, uint32_t const handle, uint32_t const attribute_id);
+uint16_t ptp_remove_object_from_cache(PTPParams *params, uint32_t handle);
+uint16_t ptp_add_object_to_cache(PTPParams *params, uint32_t handle);
+uint16_t ptp_object_want (PTPParams *, uint32_t handle, unsigned int want, PTPObject**retob);
+void ptp_objects_sort (PTPParams *);
+uint16_t ptp_object_find (PTPParams *params, uint32_t handle, PTPObject **retob);
+uint16_t ptp_object_find_or_insert (PTPParams *params, uint32_t handle, PTPObject **retob);
+/* ptpip.c */
+void ptp_nikon_getptpipguid (unsigned char* guid);
+
+/* CHDK specifics */
+#define PTP_OC_CHDK	0x9999
+typedef struct tagptp_chdk_videosettings {
+	long live_image_buffer_width;
+	long live_image_width;
+	long live_image_height;
+	long bitmap_buffer_width;
+	long bitmap_width;
+	long bitmap_height;
+	unsigned palette[16]; 
+} ptp_chdk_videosettings;
+
+/* Nafraf: Test this!!!*/
+#define ptp_chdk_switch_mode(params,mode) ptp_generic_no_data(params,PTP_OC_CHDK,2,PTP_CHDK_SwitchMode,mode)
+
+/* include CHDK ptp protocol definitions from a CHDK source tree */
+#include "chdk_ptp.h"
+#if (PTP_CHDK_VERSION_MAJOR < 2 || (PTP_CHDK_VERSION_MAJOR == 2 && PTP_CHDK_VERSION_MINOR < 5))
+#error your chdk headers are too old, unset CHDK_SRC_DIR in config.mk
+#endif
+#include "chdk_live_view.h"
+
+/* the following happens to match what is used in CHDK, but is not part of the protocol */
+typedef struct {
+    unsigned size;
+    unsigned script_id; /* id of script message is to/from  */
+    unsigned type;
+    unsigned subtype;
+    char data[];
+} ptp_chdk_script_msg;
+
+/*
+chunk for remote capture
+*/
+typedef struct {
+	uint32_t size; /* length of data */
+	int last; /* is it the last chunk? */
+	uint32_t offset; /* offset within file, or -1 */
+	unsigned char *data; /* data, must be free'd by caller when done */
+} ptp_chdk_rc_chunk;
+
+
+uint16_t ptp_chdk_get_memory(PTPParams* params, int start, int num, unsigned char **);
+uint16_t ptp_chdk_set_memory_long(PTPParams* params, int addr, int val);
+int ptp_chdk_upload(PTPParams* params, char *local_fn, char *remote_fn);
+uint16_t ptp_chdk_download(PTPParams* params, char *remote_fn, PTPDataHandler *handler);
+
+/* remote capture */
+uint16_t ptp_chdk_rcisready(PTPParams* params, int *isready,int *imgnum);
+uint16_t ptp_chdk_rcgetchunk(PTPParams* params,int fmt, ptp_chdk_rc_chunk *chunk);
+
+uint16_t ptp_chdk_exec_lua(PTPParams* params, char *script, int flags, int *script_id,int *status);
+uint16_t ptp_chdk_get_version(PTPParams* params, int *major, int *minor);
+uint16_t ptp_chdk_get_script_support(PTPParams* params, unsigned *status);
+uint16_t ptp_chdk_get_script_status(PTPParams* params, unsigned *status);
+uint16_t ptp_chdk_write_script_msg(PTPParams* params, char *data, unsigned size, int target_script_id, int *status);
+uint16_t ptp_chdk_read_script_msg(PTPParams* params, ptp_chdk_script_msg **msg);
+uint16_t ptp_chdk_get_live_data(PTPParams* params, unsigned flags, unsigned char **data, unsigned int *data_size);
+uint16_t ptp_chdk_call_function(PTPParams* params, int *args, int size, int *ret);
+
+/*uint16_t ptp_chdk_get_script_output(PTPParams* params, char **output ); */
+/*uint16_t ptp_chdk_get_video_settings(PTPParams* params, ptp_chdk_videosettings* vsettings);*/
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif /* __PTP_H__ */
